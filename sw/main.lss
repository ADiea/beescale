
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000062  00800100  0000330c  000033a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000330c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000068  00800162  00800162  00003402  2**0
                  ALLOC
  3 .debug_aranges 00000468  00000000  00000000  00003402  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000ddb  00000000  00000000  0000386a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000340a  00000000  00000000  00004645  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000109e  00000000  00000000  00007a4f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003563  00000000  00000000  00008aed  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000006f0  00000000  00000000  0000c050  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000ddd  00000000  00000000  0000c740  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000019bf  00000000  00000000  0000d51d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000003f0  00000000  00000000  0000eedc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
#include "hx711.h"
#include "button.h"
#include "LCD_functions.h"

void showLongDec(long input)
{
       0:	e5 c5       	rjmp	.+3018   	; 0xbcc <__ctors_end>

    return 0;
}

void Timer0_SetCountdownTimer(char timer, char value)
{
       2:	00 00       	nop
*
*   Purpose :       Receives one byte from the USART
*
*****************************************************************************/
char Usart_Rx(void)
{
       4:	ff c5       	rjmp	.+3070   	; 0xc04 <__bad_interrupt>
*
*	Purpose :		Transfers a page from flash to dataflash SRAM buffer
*					
******************************************************************************/
void Page_To_Buffer (unsigned int PageAdr, unsigned char BufferNo)
{
       6:	00 00       	nop

void HX711_set_scale(float scale) {
	SCALE = scale;
}

float HX711_get_scale() {
       8:	0c 94 4c 11 	jmp	0x2298	; 0x2298 <__vector_2>
       c:	0c 94 29 11 	jmp	0x2252	; 0x2252 <__vector_3>
      10:	f9 c5       	rjmp	.+3058   	; 0xc04 <__bad_interrupt>
      12:	00 00       	nop
      14:	0c 94 f5 0b 	jmp	0x17ea	; 0x17ea <__vector_5>
      18:	f5 c5       	rjmp	.+3050   	; 0xc04 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	f3 c5       	rjmp	.+3046   	; 0xc04 <__bad_interrupt>
      1e:	00 00       	nop
      20:	f1 c5       	rjmp	.+3042   	; 0xc04 <__bad_interrupt>
      22:	00 00       	nop
      24:	ef c5       	rjmp	.+3038   	; 0xc04 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 fd 08 	jmp	0x11fa	; 0x11fa <__vector_10>
      2c:	eb c5       	rjmp	.+3030   	; 0xc04 <__bad_interrupt>
      2e:	00 00       	nop
      30:	e9 c5       	rjmp	.+3026   	; 0xc04 <__bad_interrupt>
      32:	00 00       	nop
      34:	e7 c5       	rjmp	.+3022   	; 0xc04 <__bad_interrupt>
      36:	00 00       	nop
      38:	e5 c5       	rjmp	.+3018   	; 0xc04 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	e3 c5       	rjmp	.+3014   	; 0xc04 <__bad_interrupt>
      3e:	00 00       	nop
      40:	e1 c5       	rjmp	.+3010   	; 0xc04 <__bad_interrupt>
      42:	00 00       	nop
      44:	df c5       	rjmp	.+3006   	; 0xc04 <__bad_interrupt>
      46:	00 00       	nop
      48:	dd c5       	rjmp	.+3002   	; 0xc04 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	db c5       	rjmp	.+2998   	; 0xc04 <__bad_interrupt>
      4e:	00 00       	nop
      50:	d9 c5       	rjmp	.+2994   	; 0xc04 <__bad_interrupt>
      52:	00 00       	nop
      54:	d7 c5       	rjmp	.+2990   	; 0xc04 <__bad_interrupt>
      56:	00 00       	nop
      58:	0c 94 aa 13 	jmp	0x2754	; 0x2754 <__vector_22>

0000005c <MT_AVRBF>:
	...

0000005d <MT_TIME>:
      5d:	54 69 6d 65 00                                      Time.

00000062 <MT_TIME_CLOCK>:
      62:	43 6c 6f 63 6b 00                                   Clock.

00000068 <MT_TIME_CLOCK_ADJUST>:
      68:	41 64 6a 75 73 74 20 43 6c 6f 63 6b 00              Adjust Clock.

00000075 <MT_TIME_CLOCKFORMAT_ADJUST>:
      75:	43 68 61 6e 67 65 20 43 6c 6f 63 6b 20 46 6f 72     Change Clock For
      85:	6d 61 74 00                                         mat.

00000089 <MT_TIME_DATE>:
      89:	44 61 74 65 00                                      Date.

0000008e <MT_TIME_DATE_ADJUST>:
      8e:	41 64 6a 75 73 74 20 44 61 74 65 00                 Adjust Date.

0000009a <MT_TIME_DATEFORMAT_ADJUST>:
      9a:	43 68 61 6e 67 65 20 44 61 74 65 20 46 6f 72 6d     Change Date Form
      aa:	61 74 00                                            at.

000000ad <MT_MUSIC>:
      ad:	4d 75 73 69 63 00                                   Music.

000000b3 <MT_TEMPERATURE>:
      b3:	54 65 6d 70 65 72 61 74 75 72 65 00                 Temperature.

000000bf <MT_VOLTAGE>:
      bf:	56 6f 6c 74 61 67 65 00                             Voltage.

000000c7 <MT_LIGHT>:
      c7:	4c 69 67 68 74 00                                   Light.

000000cd <MT_OPTIONS>:
      cd:	4f 70 74 69 6f 6e 73 00                             Options.

000000d5 <MT_OPTIONS_DISPLAY>:
      d5:	44 69 73 70 6c 61 79 00                             Display.

000000dd <MT_OPTIONS_DISPLAY_CONTRAST>:
      dd:	41 64 6a 75 73 74 20 63 6f 6e 74 72 61 73 74 00     Adjust contrast.

000000ed <MT_OPTIONS_BOOT>:
      ed:	42 6f 6f 74 6c 6f 61 64 65 72 00                    Bootloader.

000000f8 <MT_OPTIONS_POWER_SAVE>:
      f8:	50 6f 77 65 72 20 53 61 76 65 20 4d 6f 64 65 00     Power Save Mode.

00000108 <MT_OPTIONS_AUTO_POWER_SAVE>:
     108:	41 75 74 6f 20 50 6f 77 65 72 20 53 61 76 65 00     Auto Power Save.

00000118 <MT_OPTIONS_KEYCLICK>:
     118:	4b 65 79 20 43 6c 69 63 6b 00                       Key Click.

00000122 <menu_nextstate>:
     122:	14 04 66 14 02 15 14 05 28 15 04 1b 15 02 16 15     ..f.....(.......
     132:	03 14 15 05 1b 17 04 19 17 01 18 17 03 16 17 05     ................
     142:	19 19 04 17 19 01 24 19 03 16 19 05 17 1b 04 15     ......$.........
     152:	1b 02 1c 1b 03 14 1b 05 15 1d 04 1f 1d 01 1e 1d     ................
     162:	03 1c 1d 05 1f 1f 04 1d 1f 01 20 1f 03 1c 1f 05     .......... .....
     172:	1d 28 04 14 28 02 2a 28 05 3c 29 02 2a 29 03 28     .(..(.*(.<).*).(
     182:	3c 04 28 3c 02 3d 3c 05 46 46 04 3c 46 02 47 46     <.(<.=<.FF.<F.GF
     192:	05 50 50 04 46 50 02 51 50 05 5a 5a 04 50 5a 02     .PP.FP.QP.ZZ.PZ.
     1a2:	5b 5a 05 66 5b 04 64 5b 02 5c 5b 03 5a 5b 05 5e     [Z.f[.d[.\[.Z[.^
     1b2:	5c 01 5d 5c 03 5b 5e 04 5b 5e 02 5f 5e 03 5a 5e     \.]\.[^.[^._^.Z^
     1c2:	05 60 60 04 5e 60 02 61 60 03 5a 60 05 62 62 04     .``.^`.a`.Z`.bb.
     1d2:	60 62 02 63 62 03 5a 62 05 64 64 04 62 64 02 65     `b.cb.Zb.dd.bd.e
     1e2:	64 03 5a 64 05 5b 66 04 5a 66 02 67 66 05 14 67     d.Zd.[f.Zf.gf..g
     1f2:	03 66 00 00 00                                      .f...

000001f7 <menu_state>:
     1f7:	14 5d 00 00 00 15 62 00 00 00 16 00 00 9d 0f 17     .]....b.........
     207:	68 00 00 00 18 00 00 9f 0e 19 75 00 00 00 24 00     h.........u...$.
     217:	00 d1 0c 1b 89 00 00 00 1c 00 00 1d 0e 1d 8e 00     ................
     227:	00 00 1e 00 00 10 0d 1f 9a 00 00 00 20 00 00 93     ............ ...
     237:	0c 28 ad 00 00 00 2a 00 00 20 15 2b 00 00 ac 15     .(....*.. .+....
     247:	3c b3 00 00 00 3d 00 00 4b 0a 46 bf 00 00 00 47     <....=..K.F....G
     257:	00 00 2c 0a 50 c7 00 00 00 51 00 00 0d 0a 5a cd     ..,.P....Q....Z.
     267:	00 00 00 5b d5 00 00 00 5c dd 00 00 00 5d 00 00     ...[....\....]..
     277:	e5 12 5e ed 00 00 00 5f 00 00 a4 06 60 f8 00 00     ..^...._....`...
     287:	00 61 00 00 86 06 62 08 01 00 00 63 00 00 1c 07     .a....b....c....
     297:	64 18 01 00 00 65 00 00 c0 06 66 00 00 83 08 67     d....e....f....g
     2a7:	00 00 c8 08 00 00 00 00 00                          .........

000002b0 <__c.1710>:
     2b0:	4f 66 66 00                                         Off.

000002b4 <__c.1708>:
     2b4:	4f 6e 00                                            On.

000002b7 <__c.1695>:
     2b7:	4f 66 66 00                                         Off.

000002bb <__c.1693>:
     2bb:	4f 66 66 00                                         Off.

000002bf <__c.1676>:
     2bf:	50 72 65 73 73 20 65 6e 74 65 72 20 74 6f 20 73     Press enter to s
     2cf:	6c 65 65 70 00                                      leep.

000002d4 <__c.1666>:
     2d4:	4a 75 6d 70 20 74 6f 20 62 6f 6f 74 6c 6f 61 64     Jump to bootload
     2e4:	65 72 00                                            er.

000002e7 <TEMP_Celsius_pos>:
     2e7:	26 03 1c 03 12 03 07 03 fd 02 f2 02 e7 02 dc 02     &...............
     2f7:	d0 02 c5 02 b9 02 ad 02 a1 02 95 02 89 02 7c 02     ..............|.
     307:	70 02 63 02 57 02 4a 02 3e 02 32 02 25 02 19 02     p.c.W.J.>.2.%...
     317:	0c 02 00 02 f4 01 e8 01 dc 01 d0 01 c4 01 b8 01     ................
     327:	ad 01 a2 01 96 01 8c 01 81 01 76 01 6c 01 62 01     ..........v.l.b.
     337:	58 01 4e 01 44 01 3b 01 32 01 29 01 20 01 17 01     X.N.D.;.2.). ...
     347:	0f 01 07 01 ff 00 f7 00 f0 00 e9 00 e1 00 db 00     ................
     357:	d4 00 cd 00 c7 00 c1 00 bb 00                       ..........

00000361 <TEMP_Celsius_neg>:
     361:	2f 03 39 03 42 03 4b 03 53 03 5c 03 64 03 6c 03     /.9.B.K.S.\.d.l.
     371:	73 03 7b 03 82 03 88 03 8f 03 95 03 9b 03           s.{...........

0000037f <TEMP_Fahrenheit_pos>:
     37f:	aa 03 a7 03 a4 03 a1 03 9e 03 9b 03 98 03 94 03     ................
     38f:	91 03 8d 03 8a 03 86 03 82 03 7e 03 7b 03 77 03     ..........~.{.w.
     39f:	72 03 6e 03 6a 03 66 03 61 03 5d 03 58 03 53 03     r.n.j.f.a.].X.S.
     3af:	4f 03 4a 03 45 03 40 03 3b 03 36 03 30 03 2b 03     O.J.E.@.;.6.0.+.
     3bf:	26 03 20 03 1b 03 15 03 0f 03 0a 03 04 03 fe 02     &. .............
     3cf:	f8 02 f2 02 ec 02 e6 02 df 02 d9 02 d3 02 cc 02     ................
     3df:	c6 02 bf 02 b9 02 b2 02 ac 02 a5 02 9e 02 97 02     ................
     3ef:	91 02 8a 02 83 02 7c 02 75 02 6e 02 68 02 61 02     ......|.u.n.h.a.
     3ff:	5a 02 53 02 4c 02 45 02 3e 02 37 02 30 02 29 02     Z.S.L.E.>.7.0.).
     40f:	22 02 1b 02 15 02 0e 02 07 02 00 02 f9 01 f2 01     "...............
     41f:	ec 01 e5 01 de 01 d8 01 d1 01 cb 01 c4 01 be 01     ................
     42f:	b7 01 b1 01 aa 01 a4 01 9e 01 98 01 92 01 8c 01     ................
     43f:	86 01 80 01 7a 01 74 01 6e 01 68 01 63 01 5d 01     ....z.t.n.h.c.].
     44f:	58 01 52 01 4d 01 47 01 42 01 3d 01 38 01 33 01     X.R.M.G.B.=.8.3.
     45f:	2e 01 29 01 24 01 1f 01 1a 01 15 01 11 01 0c 01     ..).$...........
     46f:	08 01 03 01 ff 00 fb 00 f6 00 f2 00 ee 00 ea 00     ................
     47f:	e6 00 e2 00 de 00 db 00 d7 00 d3 00 cf 00 cc 00     ................
     48f:	c8 00 c5 00 c2 00 be 00 bb 00                       ..........

00000499 <LIGHT_ADC>:
     499:	35 00 60 00 80 00 b0 00 1d 01 3d 01 5a 01 7a 01     5.`.......=.Z.z.
     4a9:	97 01 b9 01 da 01 f9 01 16 02 40 02 6d 02 82 02     ..........@.m...
     4b9:	a2 02 ef 02 32 03 b0 03 f2 03                       ....2.....

000004c3 <LIGHT_VOLTAGE>:
     4c3:	1d 5a 34 40 e1 7a 34 40 6a bc 34 40 91 ed 34 40     .Z4@.z4@j.4@..4@
     4d3:	7d 3f 35 40 a4 70 35 40 2d b2 35 40 f2 d2 35 40     }?5@.p5@-.5@..5@
     4e3:	b6 f3 35 40 3f 35 36 40 66 66 36 40 8d 97 36 40     ..5@?56@ff6@..6@
     4f3:	17 d9 36 40 64 3b 37 40 ee 7c 37 40 14 ae 37 40     ..6@d;7@.|7@..7@
     503:	9e ef 37 40 b0 72 38 40 e9 26 39 40 21 b0 3a 40     ..7@.r8@.&9@!.:@
     513:	93 18 3c 40                                         ..<@

00000517 <EUROPEAN_DATE_TEXT>:
     517:	44 44 4d 4d 59 59 00                                DDMMYY.

0000051e <AMERICAN_DATE_TEXT>:
     51e:	4d 4d 44 44 59 59 00                                MMDDYY.

00000525 <CANADIAN_DATE_TEXT>:
     525:	59 59 4d 4d 44 44 00                                YYMMDD.

0000052c <EUROPEAN_DATE_NR>:
     52c:	04 05 02 03 00 01                                   ......

00000532 <AMERICAN_DATE_NR>:
     532:	04 05 00 01 02 03                                   ......

00000538 <CANADIAN_DATE_NR>:
     538:	00 01 02 03 04 05                                   ......

0000053e <DATE_FORMAT_NR>:
     53e:	2c 05 32 05 38 05                                   ,.2.8.

00000544 <__c.1550>:
     544:	31 32 48 00                                         12H.

00000548 <__c.1548>:
     548:	32 34 48 00                                         24H.

0000054c <__c.1546>:
     54c:	32 34 48 00                                         24H.

00000550 <__c.1544>:
     550:	31 32 48 00                                         12H.

00000554 <__c.1542>:
     554:	31 32 48 00                                         12H.

00000558 <__c.1540>:
     558:	32 34 48 00                                         24H.

0000055c <DF_pagebits>:
     55c:	09 09 09 09 09 0a 0a 0b                             ........

00000564 <DF_pagesize>:
     564:	08 01 08 01 08 01 08 01 08 01 10 02 10 02 20 04     .............. .

00000574 <LCD_character_table>:
     574:	51 0a 80 2a 00 00 00 0a 51 0a 00 00 59 55 18 01     Q..*....Q...YU..
     584:	11 1e 11 1b 50 0b 41 1b 41 1f 11 01 51 1f 51 1b     ....P.A.A...Q.Q.
	...
     5a0:	00 00 51 0f 91 39 41 14 91 31 41 1e 41 0e 41 1d     ..Q..9A..1A.A.A.
     5b0:	50 0f 80 20 10 15 48 86 40 14 78 05 70 85 51 15     P.. ..H.@.x.p.Q.
     5c0:	51 0e 51 95 51 8e 21 90 81 20 50 15 48 44 50 c5     Q.Q.Q.!.. P.HDP.
     5d0:	28 c0 28 20 09 50 00 00 00 00 00 00 00 00 00 00     (.( .P..........

000005e0 <TEXT_SONG1>:
     5e0:	46 75 72 20 45 6c 69 73 65 00                       Fur Elise.

000005ea <FurElise>:
     5ea:	03 00 08 00 7b 01 08 00 92 01 08 00 7b 01 08 00     ....{.......{...
     5fa:	92 01 08 00 7b 01 08 00 fa 01 08 00 aa 01 08 00     ....{...........
     60a:	de 01 04 00 38 02 08 00 01 00 08 00 bc 03 08 00     ....8...........
     61a:	f6 02 08 00 38 02 04 00 fa 01 08 00 01 00 08 00     ....8...........
     62a:	f6 02 08 00 5a 02 08 00 fa 01 04 00 de 01 08 00     ....Z...........
     63a:	01 00 08 00 f6 02 08 00 7b 01 08 00 92 01 08 00     ........{.......
     64a:	7b 01 08 00 92 01 08 00 7b 01 08 00 fa 01 08 00     {.......{.......
     65a:	aa 01 08 00 de 01 04 00 38 02 08 00 01 00 08 00     ........8.......
     66a:	bc 03 08 00 f6 02 08 00 38 02 04 00 fa 01 08 00     ........8.......
     67a:	01 00 08 00 f6 02 08 00 de 01 08 00 fa 01 04 00     ................
     68a:	38 02 00 00 01 00                                   8.....

00000690 <TEXT_SONG2>:
     690:	54 75 72 6b 65 79 20 6d 61 72 63 68 00              Turkey march.

0000069d <Mozart>:
     69d:	03 00 10 00 a4 02 10 00 f6 02 10 00 24 03 10 00     ............$...
     6ad:	f6 02 04 00 7e 02 10 00 38 02 10 00 7e 02 10 00     ....~...8...~...
     6bd:	a4 02 10 00 7e 02 04 00 fa 01 10 00 de 01 10 00     ....~...........
     6cd:	fa 01 10 00 18 02 10 00 fa 01 10 00 52 01 10 00     ............R...
     6dd:	7b 01 10 00 92 01 10 00 7b 01 10 00 52 01 10 00     {.......{...R...
     6ed:	7b 01 10 00 92 01 10 00 7b 01 04 00 3f 01 08 00     {.......{...?...
     6fd:	7b 01 08 00 3f 01 20 00 aa 01 20 00 7b 01 10 00     {...?. ... .{...
     70d:	52 01 08 00 7b 01 08 00 aa 01 08 00 7b 01 20 00     R...{.......{. .
     71d:	aa 01 20 00 7b 01 10 00 52 01 08 00 7b 01 08 00     .. .{...R...{...
     72d:	aa 01 08 00 7b 01 20 00 aa 01 20 00 7b 01 10 00     ....{. ... .{...
     73d:	52 01 08 00 7b 01 08 00 aa 01 08 00 c3 01 04 00     R...{...........
     74d:	fa 01 00 00 01 00                                   ......

00000753 <TEXT_SONG3>:
     753:	4d 69 6e 75 65 74 00                                Minuet.

0000075a <Minuet>:
     75a:	02 00 04 00 aa 01 08 00 7e 02 08 00 38 02 08 00     ........~...8...
     76a:	fa 01 08 00 de 01 04 00 aa 01 04 00 7e 02 04 00     ............~...
     77a:	7e 02 04 00 7b 01 08 00 de 01 08 00 aa 01 08 00     ~...{...........
     78a:	7b 01 08 00 52 01 04 00 3f 01 04 00 7e 02 04 00     {...R...?...~...
     79a:	7e 02 04 00 de 01 08 00 aa 01 08 00 de 01 08 00     ~...............
     7aa:	fa 01 08 00 38 02 04 00 fa 01 08 00 de 01 08 00     ....8...........
     7ba:	fa 01 08 00 38 02 08 00 7e 02 04 00 a4 02 08 00     ....8...~.......
     7ca:	7e 02 08 00 38 02 08 00 fa 01 08 00 7e 02 04 00     ~...8.......~...
     7da:	fa 01 02 00 38 02 00 00 01 00                       ....8.....

000007e4 <TEXT_SONG4>:
     7e4:	41 75 6c 64 20 4c 61 6e 67 20 53 79 6e 65 00        Auld Lang Syne.

000007f3 <AuldLangSyne>:
     7f3:	03 00 04 00 3f 01 02 00 ef 00 08 00 ef 00 04 00     ....?...........
     803:	ef 00 04 00 be 00 02 00 d5 00 08 00 ef 00 04 00     ................
     813:	d5 00 08 00 be 00 08 00 d5 00 02 00 ef 00 08 00     ................
     823:	ef 00 04 00 be 00 04 00 9f 00 02 00 8e 00 08 00     ................
     833:	01 00 04 00 8e 00 02 00 9f 00 08 00 be 00 04 00     ................
     843:	be 00 04 00 ef 00 02 00 d5 00 08 00 ef 00 04 00     ................
     853:	d5 00 08 00 be 00 08 00 d5 00 02 00 ef 00 08 00     ................
     863:	1c 01 04 00 1c 01 04 00 3f 01 02 00 ef 00 04 00     ........?.......
     873:	01 00 00 00 01 00                                   ......

00000879 <TEXT_SONG5>:
     879:	53 69 72 65 6e 65 31 00                             Sirene1.

00000881 <Sirene1>:
     881:	00 00 20 00 90 01 20 00 8d 01 20 00 8a 01 20 00     .. ... ... ... .
     891:	87 01 20 00 84 01 20 00 81 01 20 00 7e 01 20 00     .. ... ... .~. .
     8a1:	7b 01 20 00 78 01 20 00 75 01 20 00 72 01 20 00     {. .x. .u. .r. .
     8b1:	6f 01 20 00 6c 01 20 00 69 01 20 00 66 01 20 00     o. .l. .i. .f. .
     8c1:	63 01 20 00 60 01 20 00 5d 01 20 00 5a 01 20 00     c. .`. .]. .Z. .
     8d1:	57 01 20 00 54 01 20 00 51 01 20 00 4e 01 20 00     W. .T. .Q. .N. .
     8e1:	4b 01 20 00 48 01 20 00 45 01 20 00 42 01 20 00     K. .H. .E. .B. .
     8f1:	3f 01 20 00 3c 01 20 00 39 01 20 00 36 01 20 00     ?. .<. .9. .6. .
     901:	33 01 20 00 30 01 20 00 2d 01 20 00 2a 01 20 00     3. .0. .-. .*. .
     911:	2a 01 20 00 2d 01 20 00 30 01 20 00 33 01 20 00     *. .-. .0. .3. .
     921:	36 01 20 00 39 01 20 00 3c 01 20 00 3f 01 20 00     6. .9. .<. .?. .
     931:	42 01 20 00 45 01 20 00 48 01 20 00 4b 01 20 00     B. .E. .H. .K. .
     941:	4e 01 20 00 51 01 20 00 54 01 20 00 57 01 20 00     N. .Q. .T. .W. .
     951:	5a 01 20 00 5d 01 20 00 60 01 20 00 63 01 20 00     Z. .]. .`. .c. .
     961:	66 01 20 00 69 01 20 00 6c 01 20 00 6f 01 20 00     f. .i. .l. .o. .
     971:	72 01 20 00 75 01 20 00 78 01 20 00 7b 01 20 00     r. .u. .x. .{. .
     981:	7e 01 20 00 81 01 20 00 84 01 20 00 87 01 20 00     ~. ... ... ... .
     991:	8a 01 20 00 8d 01 20 00 90 01 00 00 01 00           .. ... .......

0000099f <TEXT_SONG6>:
     99f:	53 69 72 65 6e 65 32 00                             Sirene2.

000009a7 <Sirene2>:
     9a7:	03 00 04 00 de 01 04 00 3f 01 00 00 01 00           ........?.....

000009b5 <TEXT_SONG7>:
     9b5:	57 68 69 73 74 6c 65 00                             Whistle.

000009bd <Whistle>:
     9bd:	00 00 20 00 c8 00 20 00 c3 00 20 00 be 00 20 00     .. ... ... ... .
     9cd:	b9 00 20 00 b4 00 20 00 af 00 20 00 aa 00 20 00     .. ... ... ... .
     9dd:	a5 00 20 00 a0 00 20 00 9b 00 20 00 96 00 20 00     .. ... ... ... .
     9ed:	91 00 20 00 8c 00 20 00 87 00 20 00 82 00 20 00     .. ... ... ... .
     9fd:	7d 00 20 00 78 00 20 00 73 00 20 00 6e 00 20 00     }. .x. .s. .n. .
     a0d:	69 00 20 00 64 00 08 00 01 00 20 00 c8 00 20 00     i. .d..... ... .
     a1d:	c3 00 20 00 be 00 20 00 b9 00 20 00 b4 00 20 00     .. ... ... ... .
     a2d:	af 00 20 00 aa 00 20 00 a5 00 20 00 a0 00 20 00     .. ... ... ... .
     a3d:	9b 00 20 00 96 00 20 00 91 00 20 00 8c 00 20 00     .. ... ... ... .
     a4d:	87 00 20 00 82 00 20 00 7d 00 20 00 7d 00 20 00     .. ... .}. .}. .
     a5d:	82 00 20 00 87 00 20 00 8c 00 20 00 91 00 20 00     .. ... ... ... .
     a6d:	96 00 20 00 9b 00 20 00 a0 00 20 00 a5 00 20 00     .. ... ... ... .
     a7d:	aa 00 20 00 af 00 20 00 b4 00 20 00 b9 00 20 00     .. ... ... ... .
     a8d:	be 00 20 00 c3 00 20 00 c8 00 00 00 00 00           .. ... .......

00000a9b <TEXT_SONG8>:
     a9b:	45 78 6f 72 7a 69 73 74 00                          Exorzist.

00000aa4 <Exorcist>:
     aa4:	15 00 90 00 7b 01 90 00 1c 01 90 00 7b 01 90 00     ....{.......{...
     ab4:	fd 00 90 00 7b 01 90 00 3f 01 90 00 1c 01 90 00     ....{...?.......
     ac4:	7b 01 90 00 ef 00 90 00 1c 01 90 00 d5 00 90 00     {...............
     ad4:	7b 01 90 00 fd 00 90 00 ef 00 90 00 7b 01 90 00     {...........{...
     ae4:	fd 00 90 00 7b 01 90 00 1c 01 90 00 7b 01 90 00     ....{.......{...
     af4:	fd 00 90 00 3f 01 90 00 1c 01 90 00 7b 01 90 00     ....?.......{...
     b04:	ef 00 90 00 7b 01 90 00 d5 00 90 00 7b 01 90 00     ....{.......{...
     b14:	fd 00 90 00 ef 00 90 00 7b 01 90 00 fd 00 90 00     ........{.......
     b24:	7b 01 90 00 1c 01 90 00 7b 01 90 00 fd 00 90 00     {.......{.......
     b34:	7b 01 90 00 3f 01 40 02 1c 01 00 00 01 00           {...?.@.......

00000b42 <Songs>:
     b42:	ea 05 9d 06 5a 07 f3 07 81 08 a7 09 bd 09 a4 0a     ....Z...........
	...

00000b54 <TEXT_SONG_TBL>:
     b54:	e0 05 90 06 53 07 e4 07 79 08 9f 09 b5 09 9b 0a     ....S...y.......
	...

00000b66 <PLAYING>:
     b66:	50 4c 41 59 49 4e 47 00                             PLAYING.

00000b6e <__c.1543>:
     b6e:	45 72 72 6f 72 20 44 61 74 61 46 6c 61 73 68 00     Error DataFlash.

00000b7e <__c.1535>:
     b7e:	4c 69 67 68 74 00                                   Light.

00000b84 <__c.1533>:
     b84:	45 72 72 6f 72 20 56 6f 6c 74 61 67 65 00           Error Voltage.

00000b92 <__c.1531>:
     b92:	45 72 72 6f 72 20 54 65 6d 70 65 72 61 74 75 72     Error Temperatur
     ba2:	65 00                                               e.

00000ba4 <__c.1517>:
     ba4:	4c 43 44 20 74 65 73 74 00                          LCD test.

00000bad <__c.1512>:
     bad:	53 6f 75 6e 64 00                                   Sound.

00000bb3 <__c.1507>:
     bb3:	44 6f 77 6e 00                                      Down.

00000bb8 <__c.1502>:
     bb8:	52 69 67 68 74 00                                   Right.

00000bbe <__c.1497>:
     bbe:	55 70 00                                            Up.

00000bc1 <__c.1492>:
     bc1:	4c 65 66 74 00                                      Left.

00000bc6 <__c.1490>:
     bc6:	54 65 73 74 00 00                                   Test..

00000bcc <__ctors_end>:
     bcc:	11 24       	eor	r1, r1
     bce:	1f be       	out	0x3f, r1	; 63
     bd0:	cf ef       	ldi	r28, 0xFF	; 255
     bd2:	d4 e0       	ldi	r29, 0x04	; 4
     bd4:	de bf       	out	0x3e, r29	; 62
     bd6:	cd bf       	out	0x3d, r28	; 61

00000bd8 <__do_copy_data>:
     bd8:	11 e0       	ldi	r17, 0x01	; 1
     bda:	a0 e0       	ldi	r26, 0x00	; 0
     bdc:	b1 e0       	ldi	r27, 0x01	; 1
     bde:	ec e0       	ldi	r30, 0x0C	; 12
     be0:	f3 e3       	ldi	r31, 0x33	; 51
     be2:	02 c0       	rjmp	.+4      	; 0xbe8 <.do_copy_data_start>

00000be4 <.do_copy_data_loop>:
     be4:	05 90       	lpm	r0, Z+
     be6:	0d 92       	st	X+, r0

00000be8 <.do_copy_data_start>:
     be8:	a2 36       	cpi	r26, 0x62	; 98
     bea:	b1 07       	cpc	r27, r17
     bec:	d9 f7       	brne	.-10     	; 0xbe4 <.do_copy_data_loop>

00000bee <__do_clear_bss>:
     bee:	11 e0       	ldi	r17, 0x01	; 1
     bf0:	a2 e6       	ldi	r26, 0x62	; 98
     bf2:	b1 e0       	ldi	r27, 0x01	; 1
     bf4:	01 c0       	rjmp	.+2      	; 0xbf8 <.do_clear_bss_start>

00000bf6 <.do_clear_bss_loop>:
     bf6:	1d 92       	st	X+, r1

00000bf8 <.do_clear_bss_start>:
     bf8:	aa 3c       	cpi	r26, 0xCA	; 202
     bfa:	b1 07       	cpc	r27, r17
     bfc:	e1 f7       	brne	.-8      	; 0xbf6 <.do_clear_bss_loop>
     bfe:	80 d1       	rcall	.+768    	; 0xf00 <main>
     c00:	0c 94 84 19 	jmp	0x3308	; 0x3308 <_exit>

00000c04 <__bad_interrupt>:
     c04:	fd c9       	rjmp	.-3078   	; 0x0 <__vectors>

00000c06 <StateMachine>:
*
*   Purpose :       Shifts between the different states
*
*****************************************************************************/
unsigned char StateMachine(char state, unsigned char stimuli)
{
     c06:	58 2f       	mov	r21, r24
     c08:	40 e0       	ldi	r20, 0x00	; 0
     c0a:	0e c0       	rjmp	.+28     	; 0xc28 <StateMachine+0x22>
    // mt: for (i=0; menu_nextstate[i].state; i++)
    for (i=0; ( j=pgm_read_byte(&menu_nextstate[i].state) ); i++ )
    {
        // mt: if (menu_nextstate[i].state == state && menu_nextstate[i].input == stimuli)
        // mt 1/06 : if (pgm_read_byte(&menu_nextstate[i].state) == state && 
        if ( j == state && 
     c0c:	85 17       	cp	r24, r21
     c0e:	59 f4       	brne	.+22     	; 0xc26 <StateMachine+0x20>
             pgm_read_byte(&menu_nextstate[i].input) == stimuli)
     c10:	f9 01       	movw	r30, r18
     c12:	ed 5d       	subi	r30, 0xDD	; 221
     c14:	fe 4f       	sbci	r31, 0xFE	; 254
     c16:	e4 91       	lpm	r30, Z+
    // mt: for (i=0; menu_nextstate[i].state; i++)
    for (i=0; ( j=pgm_read_byte(&menu_nextstate[i].state) ); i++ )
    {
        // mt: if (menu_nextstate[i].state == state && menu_nextstate[i].input == stimuli)
        // mt 1/06 : if (pgm_read_byte(&menu_nextstate[i].state) == state && 
        if ( j == state && 
     c18:	e6 17       	cp	r30, r22
     c1a:	29 f4       	brne	.+10     	; 0xc26 <StateMachine+0x20>
             pgm_read_byte(&menu_nextstate[i].input) == stimuli)
        {
            // This is the one!
            // mt: nextstate = menu_nextstate[i].nextstate;
            nextstate = pgm_read_byte(&menu_nextstate[i].nextstate);
     c1c:	f9 01       	movw	r30, r18
     c1e:	ec 5d       	subi	r30, 0xDC	; 220
     c20:	fe 4f       	sbci	r31, 0xFE	; 254
     c22:	84 91       	lpm	r24, Z+
     c24:	08 95       	ret
{
    unsigned char nextstate = state;    // Default stay in same state
    unsigned char i, j;

    // mt: for (i=0; menu_nextstate[i].state; i++)
    for (i=0; ( j=pgm_read_byte(&menu_nextstate[i].state) ); i++ )
     c26:	4f 5f       	subi	r20, 0xFF	; 255
     c28:	84 2f       	mov	r24, r20
     c2a:	90 e0       	ldi	r25, 0x00	; 0
     c2c:	9c 01       	movw	r18, r24
     c2e:	22 0f       	add	r18, r18
     c30:	33 1f       	adc	r19, r19
     c32:	28 0f       	add	r18, r24
     c34:	39 1f       	adc	r19, r25
     c36:	f9 01       	movw	r30, r18
     c38:	ee 5d       	subi	r30, 0xDE	; 222
     c3a:	fe 4f       	sbci	r31, 0xFE	; 254
     c3c:	84 91       	lpm	r24, Z+
     c3e:	88 23       	and	r24, r24
     c40:	29 f7       	brne	.-54     	; 0xc0c <StateMachine+0x6>
     c42:	85 2f       	mov	r24, r21
            break;
        }
    }

    return nextstate;
}
     c44:	08 95       	ret

00000c46 <Delay>:
*
*   Purpose :       Delay-loop
*
*****************************************************************************/
void Delay(unsigned int millisec)
{
     c46:	06 c0       	rjmp	.+12     	; 0xc54 <Delay+0xe>
	// mt, int i did not work in the simulator:  int i; 
	uint8_t i;

	while (millisec--) {
     c48:	20 e0       	ldi	r18, 0x00	; 0
		for (i=0; i<125; i++) {
			asm volatile ("nop"::);
     c4a:	00 00       	nop
{
	// mt, int i did not work in the simulator:  int i; 
	uint8_t i;

	while (millisec--) {
		for (i=0; i<125; i++) {
     c4c:	2f 5f       	subi	r18, 0xFF	; 255
     c4e:	2d 37       	cpi	r18, 0x7D	; 125
     c50:	e1 f7       	brne	.-8      	; 0xc4a <Delay+0x4>
     c52:	01 97       	sbiw	r24, 0x01	; 1
void Delay(unsigned int millisec)
{
	// mt, int i did not work in the simulator:  int i; 
	uint8_t i;

	while (millisec--) {
     c54:	00 97       	sbiw	r24, 0x00	; 0
     c56:	c1 f7       	brne	.-16     	; 0xc48 <Delay+0x2>
		for (i=0; i<125; i++) {
			asm volatile ("nop"::);
		}
	}
}
     c58:	08 95       	ret

00000c5a <OSCCAL_calibration>:
{
    unsigned char calibrate = FALSE;
    int temp;
    unsigned char tempL;

    CLKPR = (1<<CLKPCE);        // set Clock Prescaler Change Enable
     c5a:	80 e8       	ldi	r24, 0x80	; 128
     c5c:	80 93 61 00 	sts	0x0061, r24
    // set prescaler = 8, Inter RC 8Mhz / 8 = 1Mhz
    CLKPR = (1<<CLKPS1) | (1<<CLKPS0);
     c60:	83 e0       	ldi	r24, 0x03	; 3
     c62:	80 93 61 00 	sts	0x0061, r24
    
    TIMSK2 = 0;             //disable OCIE2A and TOIE2
     c66:	10 92 70 00 	sts	0x0070, r1

    ASSR = (1<<AS2);        //select asynchronous operation of timer2 (32,768kHz)
     c6a:	88 e0       	ldi	r24, 0x08	; 8
     c6c:	80 93 b6 00 	sts	0x00B6, r24
    
    OCR2A = 200;            // set timer2 compare value 
     c70:	88 ec       	ldi	r24, 0xC8	; 200
     c72:	80 93 b3 00 	sts	0x00B3, r24

    TIMSK0 = 0;             // delete any interrupt sources
     c76:	10 92 6e 00 	sts	0x006E, r1
        
    TCCR1B = (1<<CS10);     // start timer1 with no prescaling
     c7a:	81 e0       	ldi	r24, 0x01	; 1
     c7c:	80 93 81 00 	sts	0x0081, r24
    TCCR2A = (1<<CS20);     // start timer2 with no prescaling
     c80:	80 93 b0 00 	sts	0x00B0, r24

    while((ASSR & 0x01) | (ASSR & 0x04));       //wait for TCN2UB and TCR2UB to be cleared
     c84:	20 91 b6 00 	lds	r18, 0x00B6
     c88:	80 91 b6 00 	lds	r24, 0x00B6
     c8c:	90 e0       	ldi	r25, 0x00	; 0
     c8e:	84 70       	andi	r24, 0x04	; 4
     c90:	90 70       	andi	r25, 0x00	; 0
     c92:	30 e0       	ldi	r19, 0x00	; 0
     c94:	21 70       	andi	r18, 0x01	; 1
     c96:	30 70       	andi	r19, 0x00	; 0
     c98:	82 2b       	or	r24, r18
     c9a:	93 2b       	or	r25, r19
     c9c:	89 2b       	or	r24, r25
     c9e:	91 f7       	brne	.-28     	; 0xc84 <OSCCAL_calibration+0x2a>

    Delay(1000);    // wait for external crystal to stabilise
     ca0:	88 ee       	ldi	r24, 0xE8	; 232
     ca2:	93 e0       	ldi	r25, 0x03	; 3
     ca4:	d0 df       	rcall	.-96     	; 0xc46 <Delay>
    
    while(!calibrate)
    {
        cli(); // mt __disable_interrupt();  // disable global interrupt
        
        TIFR1 = 0xFF;   // delete TIFR1 flags
     ca6:	3f ef       	ldi	r19, 0xFF	; 255
    
        if (temp > 6250)
        {
            OSCCAL--;   // the internRC oscillator runs to fast, decrease the OSCCAL
        }
        else if (temp < 6120)
     ca8:	41 e0       	ldi	r20, 0x01	; 1

    Delay(1000);    // wait for external crystal to stabilise
    
    while(!calibrate)
    {
        cli(); // mt __disable_interrupt();  // disable global interrupt
     caa:	f8 94       	cli
        
        TIFR1 = 0xFF;   // delete TIFR1 flags
     cac:	36 bb       	out	0x16, r19	; 22
        TIFR2 = 0xFF;   // delete TIFR2 flags
     cae:	37 bb       	out	0x17, r19	; 23
        
        TCNT1H = 0;     // clear timer1 counter
     cb0:	10 92 85 00 	sts	0x0085, r1
        TCNT1L = 0;
     cb4:	10 92 84 00 	sts	0x0084, r1
        TCNT2 = 0;      // clear timer2 counter
     cb8:	10 92 b2 00 	sts	0x00B2, r1
           
        // shc/mt while ( !(TIFR2 && (1<<OCF2A)) );   // wait for timer2 compareflag    
        while ( !(TIFR2 & (1<<OCF2A)) );   // wait for timer2 compareflag
     cbc:	b9 9b       	sbis	0x17, 1	; 23
     cbe:	fe cf       	rjmp	.-4      	; 0xcbc <OSCCAL_calibration+0x62>

        TCCR1B = 0; // stop timer1
     cc0:	10 92 81 00 	sts	0x0081, r1

        sei(); // __enable_interrupt();  // enable global interrupt
     cc4:	78 94       	sei
    
        // shc/mt if ( (TIFR1 && (1<<TOV1)) )
        if ( (TIFR1 & (1<<TOV1)) )
     cc6:	b0 99       	sbic	0x16, 0	; 22
     cc8:	16 c0       	rjmp	.+44     	; 0xcf6 <OSCCAL_calibration+0x9c>
        {
            temp = 0xFFFF;      // if timer1 overflows, set the temp to 0xFFFF
        }
        else
        {   // read out the timer1 counter value
            tempL = TCNT1L;
     cca:	20 91 84 00 	lds	r18, 0x0084
            temp = TCNT1H;
     cce:	80 91 85 00 	lds	r24, 0x0085
     cd2:	90 e0       	ldi	r25, 0x00	; 0
            temp = (temp << 8);
     cd4:	98 2f       	mov	r25, r24
     cd6:	88 27       	eor	r24, r24
            temp += tempL;
     cd8:	82 0f       	add	r24, r18
     cda:	91 1d       	adc	r25, r1
        }
    
        if (temp > 6250)
     cdc:	28 e1       	ldi	r18, 0x18	; 24
     cde:	8b 36       	cpi	r24, 0x6B	; 107
     ce0:	92 07       	cpc	r25, r18
     ce2:	24 f0       	brlt	.+8      	; 0xcec <OSCCAL_calibration+0x92>
        {
            OSCCAL--;   // the internRC oscillator runs to fast, decrease the OSCCAL
     ce4:	80 91 66 00 	lds	r24, 0x0066
     ce8:	81 50       	subi	r24, 0x01	; 1
     cea:	08 c0       	rjmp	.+16     	; 0xcfc <OSCCAL_calibration+0xa2>
        }
        else if (temp < 6120)
     cec:	88 5e       	subi	r24, 0xE8	; 232
     cee:	97 41       	sbci	r25, 0x17	; 23
     cf0:	14 f0       	brlt	.+4      	; 0xcf6 <OSCCAL_calibration+0x9c>
     cf2:	81 e0       	ldi	r24, 0x01	; 1
     cf4:	06 c0       	rjmp	.+12     	; 0xd02 <OSCCAL_calibration+0xa8>
        {
            OSCCAL++;   // the internRC oscillator runs to slow, increase the OSCCAL
     cf6:	80 91 66 00 	lds	r24, 0x0066
     cfa:	8f 5f       	subi	r24, 0xFF	; 255
     cfc:	80 93 66 00 	sts	0x0066, r24
     d00:	80 e0       	ldi	r24, 0x00	; 0
        }
        else
            calibrate = TRUE;   // the interRC is correct

        TCCR1B = (1<<CS10); // start timer1
     d02:	40 93 81 00 	sts	0x0081, r20

    while((ASSR & 0x01) | (ASSR & 0x04));       //wait for TCN2UB and TCR2UB to be cleared

    Delay(1000);    // wait for external crystal to stabilise
    
    while(!calibrate)
     d06:	88 23       	and	r24, r24
     d08:	81 f2       	breq	.-96     	; 0xcaa <OSCCAL_calibration+0x50>
        else
            calibrate = TRUE;   // the interRC is correct

        TCCR1B = (1<<CS10); // start timer1
    }
}
     d0a:	08 95       	ret

00000d0c <PowerSaveFunc>:
*****************************************************************************/
// mt __flash char TEXT_POWER[]                     = "Press enter to sleep";
// mt jw const char TEXT_POWER[]  PROGMEM  = "Press enter to sleep";

char PowerSaveFunc(char input)
{
     d0c:	98 2f       	mov	r25, r24
    static char enter = 1;    
    
    if(enter)
     d0e:	80 91 1a 01 	lds	r24, 0x011A
     d12:	88 23       	and	r24, r24
     d14:	41 f0       	breq	.+16     	; 0xd26 <PowerSaveFunc+0x1a>
    {
        enter = 0;
     d16:	10 92 1a 01 	sts	0x011A, r1
        //mt jw LCD_puts_f(TEXT_POWER, 1);
        LCD_puts_f(PSTR("Press enter to sleep"), 1);
     d1a:	8f eb       	ldi	r24, 0xBF	; 191
     d1c:	92 e0       	ldi	r25, 0x02	; 2
     d1e:	61 e0       	ldi	r22, 0x01	; 1
     d20:	0e 94 5d 12 	call	0x24ba	; 0x24ba <LCD_puts_f>
     d24:	0a c0       	rjmp	.+20     	; 0xd3a <PowerSaveFunc+0x2e>
    }
    else if(input == KEY_ENTER)
     d26:	91 30       	cpi	r25, 0x01	; 1
     d28:	31 f4       	brne	.+12     	; 0xd36 <PowerSaveFunc+0x2a>
    {
        PowerSave = TRUE;
     d2a:	90 93 63 01 	sts	0x0163, r25
        enter = 1;
     d2e:	90 93 1a 01 	sts	0x011A, r25
     d32:	8a e0       	ldi	r24, 0x0A	; 10
     d34:	08 95       	ret
        return ST_AVRBF;
    }
    else if (input == KEY_PREV)
     d36:	93 30       	cpi	r25, 0x03	; 3
     d38:	11 f0       	breq	.+4      	; 0xd3e <PowerSaveFunc+0x32>
     d3a:	81 e6       	ldi	r24, 0x61	; 97
     d3c:	08 95       	ret
    {
        enter = 1;
     d3e:	81 e0       	ldi	r24, 0x01	; 1
     d40:	80 93 1a 01 	sts	0x011A, r24
     d44:	80 e6       	ldi	r24, 0x60	; 96
        return ST_OPTIONS_POWER_SAVE;
    }
        
    return ST_OPTIONS_POWER_SAVE_FUNC;

}
     d46:	08 95       	ret

00000d48 <BootFunc>:
*****************************************************************************/
// mt __flash char TEXT_BOOT[]                     
// mt - as in jw-patch: const char TEXT_BOOT[] PROGMEM	= "Jump to bootloader";

char BootFunc(char input)
{
     d48:	98 2f       	mov	r25, r24
    static char enter = 1;
    
    if(enter)
     d4a:	80 91 1b 01 	lds	r24, 0x011B
     d4e:	88 23       	and	r24, r24
     d50:	41 f0       	breq	.+16     	; 0xd62 <BootFunc+0x1a>
    {
        enter = 0;
     d52:	10 92 1b 01 	sts	0x011B, r1
        // mt jw LCD_puts_f(TEXT_BOOT, 1);
        LCD_puts_f(PSTR("Jump to bootloader"), 1);
     d56:	84 ed       	ldi	r24, 0xD4	; 212
     d58:	92 e0       	ldi	r25, 0x02	; 2
     d5a:	61 e0       	ldi	r22, 0x01	; 1
     d5c:	0e 94 5d 12 	call	0x24ba	; 0x24ba <LCD_puts_f>
     d60:	08 c0       	rjmp	.+16     	; 0xd72 <BootFunc+0x2a>
    }
    else if(input == KEY_ENTER)
     d62:	91 30       	cpi	r25, 0x01	; 1
     d64:	21 f4       	brne	.+8      	; 0xd6e <BootFunc+0x26>
    {
        WDTCR = (1<<WDCE) | (1<<WDE);     //Enable Watchdog Timer to give reset
     d66:	88 e1       	ldi	r24, 0x18	; 24
     d68:	80 93 60 00 	sts	0x0060, r24
     d6c:	ff cf       	rjmp	.-2      	; 0xd6c <BootFunc+0x24>
        while(1);   // wait for watchdog-reset, since the BOOTRST-fuse is 
                    // programmed, the Boot-section will be entered upon reset.
    }
    else if (input == KEY_PREV)
     d6e:	93 30       	cpi	r25, 0x03	; 3
     d70:	11 f0       	breq	.+4      	; 0xd76 <BootFunc+0x2e>
     d72:	8f e5       	ldi	r24, 0x5F	; 95
     d74:	08 95       	ret
    {
        enter = 1;
     d76:	81 e0       	ldi	r24, 0x01	; 1
     d78:	80 93 1b 01 	sts	0x011B, r24
     d7c:	8e e5       	ldi	r24, 0x5E	; 94
        return ST_OPTIONS_BOOT;
    }
    
    return ST_OPTIONS_BOOT_FUNC;
}
     d7e:	08 95       	ret

00000d80 <KeyClick>:
*
*   Purpose :       Enable/Disable keyclick
*
*****************************************************************************/
char KeyClick(char input)
{
     d80:	98 2f       	mov	r25, r24
	static uint8_t enter = 1;
	uint8_t show;

	if ( enter ) {
     d82:	80 91 18 01 	lds	r24, 0x0118
     d86:	88 23       	and	r24, r24
     d88:	19 f0       	breq	.+6      	; 0xd90 <KeyClick+0x10>
		enter = 0;
     d8a:	10 92 18 01 	sts	0x0118, r1
     d8e:	81 e0       	ldi	r24, 0x01	; 1
	}
	else {
		show = 0;
	}
		
	if (input == KEY_ENTER)
     d90:	91 30       	cpi	r25, 0x01	; 1
     d92:	21 f4       	brne	.+8      	; 0xd9c <KeyClick+0x1c>
	{
		enter = 1;
     d94:	90 93 18 01 	sts	0x0118, r25
     d98:	84 e6       	ldi	r24, 0x64	; 100
     d9a:	08 95       	ret
		return ST_OPTIONS_KEYCLICK;
	}

	if ( (input == KEY_PLUS) || (input == KEY_MINUS) ) {
     d9c:	94 50       	subi	r25, 0x04	; 4
     d9e:	92 30       	cpi	r25, 0x02	; 2
     da0:	30 f4       	brcc	.+12     	; 0xdae <KeyClick+0x2e>
		gKeyClickStatus = ~gKeyClickStatus;
     da2:	80 91 62 01 	lds	r24, 0x0162
     da6:	80 95       	com	r24
     da8:	80 93 62 01 	sts	0x0162, r24
     dac:	04 c0       	rjmp	.+8      	; 0xdb6 <KeyClick+0x36>
		show = 1;
	}

	if ( show ) {
     dae:	88 23       	and	r24, r24
     db0:	11 f4       	brne	.+4      	; 0xdb6 <KeyClick+0x36>
     db2:	85 e6       	ldi	r24, 0x65	; 101
     db4:	08 95       	ret
		if ( gKeyClickStatus )
     db6:	80 91 62 01 	lds	r24, 0x0162
     dba:	88 23       	and	r24, r24
     dbc:	19 f0       	breq	.+6      	; 0xdc4 <KeyClick+0x44>
			LCD_puts_f(PSTR("On"),1);
     dbe:	84 eb       	ldi	r24, 0xB4	; 180
     dc0:	92 e0       	ldi	r25, 0x02	; 2
     dc2:	02 c0       	rjmp	.+4      	; 0xdc8 <KeyClick+0x48>
		else
			LCD_puts_f(PSTR("Off"),1);
     dc4:	80 eb       	ldi	r24, 0xB0	; 176
     dc6:	92 e0       	ldi	r25, 0x02	; 2
     dc8:	61 e0       	ldi	r22, 0x01	; 1
     dca:	0e 94 5d 12 	call	0x24ba	; 0x24ba <LCD_puts_f>
		LCD_UpdateRequired(TRUE, 0);
     dce:	81 e0       	ldi	r24, 0x01	; 1
     dd0:	60 e0       	ldi	r22, 0x00	; 0
     dd2:	0e 94 d6 12 	call	0x25ac	; 0x25ac <LCD_UpdateRequired>
     dd6:	85 e6       	ldi	r24, 0x65	; 101
	}

	return ST_OPTIONS_KEYCLICK_FUNC;
}
     dd8:	08 95       	ret

00000dda <AutoPowerShowMin>:
*   Purpose :       Enable/Disable auto power save
*
*****************************************************************************/

static void AutoPowerShowMin(void)
{
     dda:	0f 93       	push	r16
     ddc:	1f 93       	push	r17
	char PH,PL; 
	
	PH = CHAR2BCD2(PowerSaveTimeout);
     dde:	80 91 16 01 	lds	r24, 0x0116
     de2:	a6 d2       	rcall	.+1356   	; 0x1330 <CHAR2BCD2>
     de4:	18 2f       	mov	r17, r24
	PL = (PH & 0x0F) + '0';
	PH = (PH >> 4) + '0';
     de6:	08 2f       	mov	r16, r24
     de8:	02 95       	swap	r16
     dea:	0f 70       	andi	r16, 0x0F	; 15
	
	LCD_putc(0, 'M');
     dec:	80 e0       	ldi	r24, 0x00	; 0
     dee:	6d e4       	ldi	r22, 0x4D	; 77
     df0:	0e 94 bd 12 	call	0x257a	; 0x257a <LCD_putc>
	LCD_putc(1, 'I');
     df4:	81 e0       	ldi	r24, 0x01	; 1
     df6:	69 e4       	ldi	r22, 0x49	; 73
     df8:	0e 94 bd 12 	call	0x257a	; 0x257a <LCD_putc>
	LCD_putc(2, 'N');
     dfc:	82 e0       	ldi	r24, 0x02	; 2
     dfe:	6e e4       	ldi	r22, 0x4E	; 78
     e00:	0e 94 bd 12 	call	0x257a	; 0x257a <LCD_putc>
	LCD_putc(3, ' ');
     e04:	83 e0       	ldi	r24, 0x03	; 3
     e06:	60 e2       	ldi	r22, 0x20	; 32
     e08:	0e 94 bd 12 	call	0x257a	; 0x257a <LCD_putc>
	LCD_putc(4, PH);
     e0c:	00 5d       	subi	r16, 0xD0	; 208
     e0e:	84 e0       	ldi	r24, 0x04	; 4
     e10:	60 2f       	mov	r22, r16
     e12:	0e 94 bd 12 	call	0x257a	; 0x257a <LCD_putc>
	LCD_putc(5, PL);
     e16:	1f 70       	andi	r17, 0x0F	; 15
     e18:	10 5d       	subi	r17, 0xD0	; 208
     e1a:	85 e0       	ldi	r24, 0x05	; 5
     e1c:	61 2f       	mov	r22, r17
     e1e:	0e 94 bd 12 	call	0x257a	; 0x257a <LCD_putc>
	LCD_putc(6, '\0');
     e22:	86 e0       	ldi	r24, 0x06	; 6
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	0e 94 bd 12 	call	0x257a	; 0x257a <LCD_putc>
	
	LCD_UpdateRequired(TRUE, 0);
     e2a:	81 e0       	ldi	r24, 0x01	; 1
     e2c:	60 e0       	ldi	r22, 0x00	; 0
     e2e:	0e 94 d6 12 	call	0x25ac	; 0x25ac <LCD_UpdateRequired>
}
     e32:	1f 91       	pop	r17
     e34:	0f 91       	pop	r16
     e36:	08 95       	ret

00000e38 <AutoPower>:

char AutoPower(char input)
{
     e38:	98 2f       	mov	r25, r24
    static char enter = 1;    
    
    if(enter)
     e3a:	80 91 19 01 	lds	r24, 0x0119
     e3e:	88 23       	and	r24, r24
     e40:	49 f0       	breq	.+18     	; 0xe54 <AutoPower+0x1c>
    {
        enter = 0;
     e42:	10 92 19 01 	sts	0x0119, r1
        
        if(AutoPowerSave)  
     e46:	80 91 17 01 	lds	r24, 0x0117
     e4a:	88 23       	and	r24, r24
     e4c:	c9 f4       	brne	.+50     	; 0xe80 <AutoPower+0x48>
            AutoPowerShowMin();
        else
            LCD_puts_f(PSTR("Off"),1);	// mt LCD_puts("Off", 1);        
     e4e:	8b eb       	ldi	r24, 0xBB	; 187
     e50:	92 e0       	ldi	r25, 0x02	; 2
     e52:	2b c0       	rjmp	.+86     	; 0xeaa <AutoPower+0x72>
    }
    else if(input == KEY_ENTER)
     e54:	91 30       	cpi	r25, 0x01	; 1
     e56:	21 f4       	brne	.+8      	; 0xe60 <AutoPower+0x28>
    {
         enter = 1;
     e58:	90 93 19 01 	sts	0x0119, r25
     e5c:	82 e6       	ldi	r24, 0x62	; 98
     e5e:	08 95       	ret

         return ST_OPTIONS_AUTO_POWER_SAVE;
    }
    else if (input == KEY_PLUS)
     e60:	94 30       	cpi	r25, 0x04	; 4
     e62:	81 f4       	brne	.+32     	; 0xe84 <AutoPower+0x4c>
    {

        PowerSaveTimeout += 5;
     e64:	80 91 16 01 	lds	r24, 0x0116
     e68:	8b 5f       	subi	r24, 0xFB	; 251
     e6a:	80 93 16 01 	sts	0x0116, r24
         
        if(PowerSaveTimeout > 90)
     e6e:	8b 35       	cpi	r24, 0x5B	; 91
     e70:	20 f0       	brcs	.+8      	; 0xe7a <AutoPower+0x42>
        {
            PowerSaveTimeout = 90;
     e72:	8a e5       	ldi	r24, 0x5A	; 90
     e74:	80 93 16 01 	sts	0x0116, r24
     e78:	1b c0       	rjmp	.+54     	; 0xeb0 <AutoPower+0x78>
        }
        else
        {    
            AutoPowerSave = TRUE;
     e7a:	81 e0       	ldi	r24, 0x01	; 1
     e7c:	80 93 17 01 	sts	0x0117, r24
            AutoPowerShowMin();
     e80:	ac df       	rcall	.-168    	; 0xdda <AutoPowerShowMin>
     e82:	16 c0       	rjmp	.+44     	; 0xeb0 <AutoPower+0x78>
        }
    }
    else if (input == KEY_MINUS)
     e84:	95 30       	cpi	r25, 0x05	; 5
     e86:	a1 f4       	brne	.+40     	; 0xeb0 <AutoPower+0x78>
    {
        if(PowerSaveTimeout)
     e88:	80 91 16 01 	lds	r24, 0x0116
     e8c:	88 23       	and	r24, r24
     e8e:	19 f0       	breq	.+6      	; 0xe96 <AutoPower+0x5e>
            PowerSaveTimeout -= 5;
     e90:	85 50       	subi	r24, 0x05	; 5
     e92:	80 93 16 01 	sts	0x0116, r24

        if(PowerSaveTimeout < 5)
     e96:	80 91 16 01 	lds	r24, 0x0116
     e9a:	85 30       	cpi	r24, 0x05	; 5
     e9c:	58 f4       	brcc	.+22     	; 0xeb4 <AutoPower+0x7c>
        {
            AutoPowerSave = FALSE;
     e9e:	10 92 17 01 	sts	0x0117, r1
            PowerSaveTimeout = 0;
     ea2:	10 92 16 01 	sts	0x0116, r1
            LCD_puts_f(PSTR("Off"),1);	// mt LCD_puts("Off", 1);
     ea6:	87 eb       	ldi	r24, 0xB7	; 183
     ea8:	92 e0       	ldi	r25, 0x02	; 2
     eaa:	61 e0       	ldi	r22, 0x01	; 1
     eac:	0e 94 5d 12 	call	0x24ba	; 0x24ba <LCD_puts_f>
     eb0:	83 e6       	ldi	r24, 0x63	; 99
     eb2:	08 95       	ret
        }
        else
        {   
            AutoPowerSave = TRUE;
     eb4:	81 e0       	ldi	r24, 0x01	; 1
     eb6:	80 93 17 01 	sts	0x0117, r24
            AutoPowerShowMin();
     eba:	8f df       	rcall	.-226    	; 0xdda <AutoPowerShowMin>
     ebc:	83 e6       	ldi	r24, 0x63	; 99
        }
    }
        
    return ST_OPTIONS_AUTO_POWER_SAVE_FUNC;    
}
     ebe:	08 95       	ret

00000ec0 <Initialization>:
*****************************************************************************/
void Initialization(void)
{
    char tst;           // dummy

    OSCCAL_calibration();       // calibrate the OSCCAL byte
     ec0:	cc de       	rcall	.-616    	; 0xc5a <OSCCAL_calibration>
        
    CLKPR = (1<<CLKPCE);        // set Clock Prescaler Change Enable
     ec2:	e1 e6       	ldi	r30, 0x61	; 97
     ec4:	f0 e0       	ldi	r31, 0x00	; 0
     ec6:	90 e8       	ldi	r25, 0x80	; 128
     ec8:	90 83       	st	Z, r25

    // set prescaler = 8, Inter RC 8Mhz / 8 = 1Mhz
    CLKPR = (1<<CLKPS1) | (1<<CLKPS0);
     eca:	83 e0       	ldi	r24, 0x03	; 3
     ecc:	80 83       	st	Z, r24

    // Disable Analog Comparator (power save)
    ACSR = (1<<ACD);
     ece:	90 bf       	out	0x30, r25	; 48

    // Disable Digital input on PF0-2 (power save)
    DIDR0 = (7<<ADC0D);
     ed0:	87 e0       	ldi	r24, 0x07	; 7
     ed2:	80 93 7e 00 	sts	0x007E, r24

    // mt PORTB = (15<<PORTB0);       // Enable pullup on 
    PORTB = (15<<PB0);       // Enable pullup on 
     ed6:	8f e0       	ldi	r24, 0x0F	; 15
     ed8:	85 b9       	out	0x05, r24	; 5
    // mt PORTE = (15<<PORTE4);
    PORTE = (15<<PE4);
     eda:	80 ef       	ldi	r24, 0xF0	; 240
     edc:	8e b9       	out	0x0e, r24	; 14

    sbiBF(DDRB, 5);               // set OC1A as output
     ede:	25 9a       	sbi	0x04, 5	; 4
    sbiBF(PORTB, 5);              // set OC1A high
     ee0:	2d 9a       	sbi	0x05, 5	; 5
            
    Button_Init();              // Initialize pin change interrupt on joystick
     ee2:	0e 94 6f 11 	call	0x22de	; 0x22de <Button_Init>
    
    RTC_init();                 // Start timer2 asynchronous, used for RTC clock
     ee6:	0e 94 03 10 	call	0x2006	; 0x2006 <RTC_init>

    Timer0_Init();              // Used when playing music etc.
     eea:	66 d1       	rcall	.+716    	; 0x11b8 <Timer0_Init>

    USART_Init(12);             // Baud rate = 9600bps
     eec:	8c e0       	ldi	r24, 0x0C	; 12
     eee:	90 e0       	ldi	r25, 0x00	; 0
     ef0:	46 d2       	rcall	.+1164   	; 0x137e <USART_Init>
    
    DF_SPI_init();              // init the SPI interface to communicate with the DataFlash
     ef2:	0e 94 40 10 	call	0x2080	; 0x2080 <DF_SPI_init>
    
    tst = Read_DF_status();
     ef6:	0e 94 51 10 	call	0x20a2	; 0x20a2 <Read_DF_status>

    DF_CS_inactive;             // disable DataFlash
     efa:	28 9a       	sbi	0x05, 0	; 5
        
    LCD_Init();                 // initialize the LCD
     efc:	0c 94 90 13 	jmp	0x2720	; 0x2720 <LCD_Init>

00000f00 <main>:
    char last_buttons;

    last_buttons='\0';  // mt

    // Initial state variables
    state = ST_TIME;
     f00:	84 e1       	ldi	r24, 0x14	; 20
     f02:	80 93 84 01 	sts	0x0184, r24
    statetext = MT_TIME;
    pStateFunc = NULL;


    // Program initalization
    Initialization();
     f06:	dc df       	rcall	.-72     	; 0xec0 <Initialization>
    sei(); // mt __enable_interrupt();
     f08:	78 94       	sei
     f0a:	14 e1       	ldi	r17, 0x14	; 20
     f0c:	d1 2e       	mov	r13, r17
     f0e:	cd e5       	ldi	r28, 0x5D	; 93
     f10:	d0 e0       	ldi	r29, 0x00	; 0
     f12:	ee 24       	eor	r14, r14
     f14:	ff 24       	eor	r15, r15
     f16:	00 e0       	ldi	r16, 0x00	; 0
        //enable ATmega169 power save modus if autopowersave
        if(AutoPowerSave)
        {
            if(gPowerSaveTimer >= PowerSaveTimeout)
            {
                state = ST_AVRBF;
     f18:	ba e0       	ldi	r27, 0x0A	; 10
     f1a:	bb 2e       	mov	r11, r27
            {
                PinChangeInterrupt();
                gAutoPressJoystick = AUTO;
            }
            else    
                gAutoPressJoystick = AUTO;
     f1c:	a3 e0       	ldi	r26, 0x03	; 3
     f1e:	ca 2e       	mov	r12, r26
     f20:	01 c0       	rjmp	.+2      	; 0xf24 <main+0x24>
    pStateFunc = NULL;


    // Program initalization
    Initialization();
    sei(); // mt __enable_interrupt();
     f22:	01 2f       	mov	r16, r17

    for (;;)            // Main loop
    {
        if(!PowerSave)          // Do not enter main loop in power-save
     f24:	80 91 63 01 	lds	r24, 0x0163
     f28:	88 23       	and	r24, r24
     f2a:	09 f0       	breq	.+2      	; 0xf2e <main+0x2e>
     f2c:	3f c0       	rjmp	.+126    	; 0xfac <main+0xac>
        {
            // Plain menu text
            if (statetext)
     f2e:	20 97       	sbiw	r28, 0x00	; 0
     f30:	39 f0       	breq	.+14     	; 0xf40 <main+0x40>
            {
                LCD_puts_f(statetext, 1);
     f32:	ce 01       	movw	r24, r28
     f34:	61 e0       	ldi	r22, 0x01	; 1
     f36:	0e 94 5d 12 	call	0x24ba	; 0x24ba <LCD_puts_f>
                LCD_Colon(0);
     f3a:	80 e0       	ldi	r24, 0x00	; 0
     f3c:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <LCD_Colon>
                statetext = NULL;
            }
 
            input = getkey();           // Read buttons
     f40:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <getkey>
     f44:	68 2f       	mov	r22, r24
    
            if (pStateFunc)
     f46:	e1 14       	cp	r14, r1
     f48:	f1 04       	cpc	r15, r1
     f4a:	19 f0       	breq	.+6      	; 0xf52 <main+0x52>
            {
                // When in this state, we must call the state function
                nextstate = pStateFunc(input);
     f4c:	f7 01       	movw	r30, r14
     f4e:	09 95       	icall
     f50:	05 c0       	rjmp	.+10     	; 0xf5c <main+0x5c>
            }
            else if (input != KEY_NULL)
     f52:	88 23       	and	r24, r24
     f54:	21 f0       	breq	.+8      	; 0xf5e <main+0x5e>
            {
                // Plain menu, clock the state machine
                nextstate = StateMachine(state, input);
     f56:	80 91 84 01 	lds	r24, 0x0184
     f5a:	55 de       	rcall	.-854    	; 0xc06 <StateMachine>
     f5c:	d8 2e       	mov	r13, r24
            }
    
            if (nextstate != state)
     f5e:	80 91 84 01 	lds	r24, 0x0184
     f62:	d8 16       	cp	r13, r24
     f64:	09 f1       	breq	.+66     	; 0xfa8 <main+0xa8>
            {
                state = nextstate;
     f66:	d0 92 84 01 	sts	0x0184, r13
     f6a:	40 e0       	ldi	r20, 0x00	; 0
     f6c:	0e c0       	rjmp	.+28     	; 0xf8a <main+0x8a>
                // mt: for (i=0; menu_state[i].state; i++)
                for (i=0; (j=pgm_read_byte(&menu_state[i].state)); i++)
                {
                    //mt: if (menu_state[i].state == state)
                    //mt 1/06 if (pgm_read_byte(&menu_state[i].state) == state)
                    if (j == state)
     f6e:	8d 15       	cp	r24, r13
     f70:	59 f4       	brne	.+22     	; 0xf88 <main+0x88>
                    {
                        // mtA
                        // mt - original: statetext =  menu_state[i].pText;
                        // mt - original: pStateFunc = menu_state[i].pFunc;
                        /// mt this is like the example from an avr-gcc guru (mailing-list):
                        statetext =  (PGM_P) pgm_read_word(&menu_state[i].pText);
     f72:	f9 01       	movw	r30, r18
     f74:	e8 50       	subi	r30, 0x08	; 8
     f76:	fe 4f       	sbci	r31, 0xFE	; 254
     f78:	c5 91       	lpm	r28, Z+
     f7a:	d4 91       	lpm	r29, Z+
                        // mt - store pointer to function from menu_state[i].pFunc in pStateFunc
                        //// pStateFunc = pmttemp;	// oh je - wie soll ich das jemals debuggen - ?
                        pStateFunc = (PGM_VOID_P) pgm_read_word(&menu_state[i].pFunc);
     f7c:	f9 01       	movw	r30, r18
     f7e:	e6 50       	subi	r30, 0x06	; 6
     f80:	fe 4f       	sbci	r31, 0xFE	; 254
     f82:	e5 90       	lpm	r14, Z+
     f84:	f4 90       	lpm	r15, Z+
     f86:	12 c0       	rjmp	.+36     	; 0xfac <main+0xac>
    
            if (nextstate != state)
            {
                state = nextstate;
                // mt: for (i=0; menu_state[i].state; i++)
                for (i=0; (j=pgm_read_byte(&menu_state[i].state)); i++)
     f88:	4f 5f       	subi	r20, 0xFF	; 255
     f8a:	84 2f       	mov	r24, r20
     f8c:	90 e0       	ldi	r25, 0x00	; 0
     f8e:	9c 01       	movw	r18, r24
     f90:	22 0f       	add	r18, r18
     f92:	33 1f       	adc	r19, r19
     f94:	22 0f       	add	r18, r18
     f96:	33 1f       	adc	r19, r19
     f98:	28 0f       	add	r18, r24
     f9a:	39 1f       	adc	r19, r25
     f9c:	f9 01       	movw	r30, r18
     f9e:	e9 50       	subi	r30, 0x09	; 9
     fa0:	fe 4f       	sbci	r31, 0xFE	; 254
     fa2:	84 91       	lpm	r24, Z+
     fa4:	88 23       	and	r24, r24
     fa6:	19 f7       	brne	.-58     	; 0xf6e <main+0x6e>
     fa8:	c0 e0       	ldi	r28, 0x00	; 0
     faa:	d0 e0       	ldi	r29, 0x00	; 0
            }
        }
        
        
        //enable ATmega169 power save modus if autopowersave
        if(AutoPowerSave)
     fac:	80 91 17 01 	lds	r24, 0x0117
     fb0:	88 23       	and	r24, r24
     fb2:	69 f0       	breq	.+26     	; 0xfce <main+0xce>
        {
            if(gPowerSaveTimer >= PowerSaveTimeout)
     fb4:	90 91 64 01 	lds	r25, 0x0164
     fb8:	80 91 16 01 	lds	r24, 0x0116
     fbc:	98 17       	cp	r25, r24
     fbe:	38 f0       	brcs	.+14     	; 0xfce <main+0xce>
            {
                state = ST_AVRBF;
     fc0:	b0 92 84 01 	sts	0x0184, r11
                gPowerSaveTimer = 0;
     fc4:	10 92 64 01 	sts	0x0164, r1
                PowerSave = TRUE;
     fc8:	81 e0       	ldi	r24, 0x01	; 1
     fca:	80 93 63 01 	sts	0x0163, r24
        
        // If the joystick is held in the UP and DOWN position at the same time,
        // activate test-mode
        // mtA
        // if( !(PINB & (1<<PORTB7)) && !(PINB & (1<<PORTB6)) )    
        if( !(PINB & (1<<PINB7)) && !(PINB & (1<<PINB6)) ) {
     fce:	1f 99       	sbic	0x03, 7	; 3
     fd0:	04 c0       	rjmp	.+8      	; 0xfda <main+0xda>
     fd2:	1e 99       	sbic	0x03, 6	; 3
     fd4:	02 c0       	rjmp	.+4      	; 0xfda <main+0xda>
            Test();
     fd6:	0e 94 6f 16 	call	0x2cde	; 0x2cde <Test>
        }
        // mtE
        
        // Check if the joystick has been in the same position for some time, 
        // then activate auto press of the joystick
        buttons = (~PINB) & PINB_MASK;
     fda:	83 b1       	in	r24, 0x03	; 3
        buttons |= (~PINE) & PINE_MASK;
     fdc:	1c b1       	in	r17, 0x0c	; 12
     fde:	10 95       	com	r17
     fe0:	1c 70       	andi	r17, 0x0C	; 12
     fe2:	80 95       	com	r24
     fe4:	80 7d       	andi	r24, 0xD0	; 208
     fe6:	18 2b       	or	r17, r24
        
        if( buttons != last_buttons ) 
     fe8:	10 17       	cp	r17, r16
     fea:	19 f0       	breq	.+6      	; 0xff2 <main+0xf2>
        {
            last_buttons = buttons;
            gAutoPressJoystick = FALSE;
     fec:	10 92 78 01 	sts	0x0178, r1
     ff0:	0a c0       	rjmp	.+20     	; 0x1006 <main+0x106>
        }
        else if( buttons )
     ff2:	00 23       	and	r16, r16
     ff4:	41 f0       	breq	.+16     	; 0x1006 <main+0x106>
        {
            if( gAutoPressJoystick == TRUE)
     ff6:	80 91 78 01 	lds	r24, 0x0178
     ffa:	81 30       	cpi	r24, 0x01	; 1
     ffc:	11 f4       	brne	.+4      	; 0x1002 <main+0x102>
            {
                PinChangeInterrupt();
     ffe:	0e 94 f6 10 	call	0x21ec	; 0x21ec <PinChangeInterrupt>
                gAutoPressJoystick = AUTO;
            }
            else    
                gAutoPressJoystick = AUTO;
    1002:	c0 92 78 01 	sts	0x0178, r12
        }

        
        
        // go to SLEEP
        if(!gPlaying )              // Do not enter Power save if using UART or playing tunes
    1006:	80 91 7f 01 	lds	r24, 0x017F
    100a:	88 23       	and	r24, r24
    100c:	51 f5       	brne	.+84     	; 0x1062 <main+0x162>
        {
            if(PowerSave)
    100e:	90 91 63 01 	lds	r25, 0x0163
    1012:	99 23       	and	r25, r25
    1014:	29 f0       	breq	.+10     	; 0x1020 <main+0x120>
                cbiBF(LCDCRA, 7);             // disable LCD
    1016:	80 91 e4 00 	lds	r24, 0x00E4
    101a:	8f 77       	andi	r24, 0x7F	; 127
    101c:	80 93 e4 00 	sts	0x00E4, r24

            set_sleep_mode(SLEEP_MODE_PWR_SAVE);
    1020:	83 b7       	in	r24, 0x33	; 51
    1022:	81 7f       	andi	r24, 0xF1	; 241
    1024:	86 60       	ori	r24, 0x06	; 6
    1026:	83 bf       	out	0x33, r24	; 51
            sleep_mode();
    1028:	83 b7       	in	r24, 0x33	; 51
    102a:	81 60       	ori	r24, 0x01	; 1
    102c:	83 bf       	out	0x33, r24	; 51
    102e:	88 95       	sleep
    1030:	83 b7       	in	r24, 0x33	; 51
    1032:	8e 7f       	andi	r24, 0xFE	; 254
    1034:	83 bf       	out	0x33, r24	; 51

            if(PowerSave)
    1036:	99 23       	and	r25, r25
    1038:	09 f4       	brne	.+2      	; 0x103c <main+0x13c>
    103a:	73 cf       	rjmp	.-282    	; 0xf22 <main+0x22>
            {
                if(!(PINB & 0x40))              // press UP to wake from SLEEP
    103c:	1e 99       	sbic	0x03, 6	; 3
    103e:	71 cf       	rjmp	.-286    	; 0xf22 <main+0x22>
                {
                    PowerSave = FALSE;
    1040:	10 92 63 01 	sts	0x0163, r1
    1044:	ec ee       	ldi	r30, 0xEC	; 236
    1046:	f0 e0       	ldi	r31, 0x00	; 0
                    
                    for(i = 0; i < 20; i++ ) // set all LCD segment register to the variable ucSegments
                    {
                        *(&pLCDREG_test + i) = 0x00;
    1048:	11 92       	st	Z+, r1
            {
                if(!(PINB & 0x40))              // press UP to wake from SLEEP
                {
                    PowerSave = FALSE;
                    
                    for(i = 0; i < 20; i++ ) // set all LCD segment register to the variable ucSegments
    104a:	81 e0       	ldi	r24, 0x01	; 1
    104c:	e0 30       	cpi	r30, 0x00	; 0
    104e:	f8 07       	cpc	r31, r24
    1050:	d9 f7       	brne	.-10     	; 0x1048 <main+0x148>
                    {
                        *(&pLCDREG_test + i) = 0x00;
                    }
                    
                    sbiBF(LCDCRA, 7);           // enable LCD
    1052:	80 91 e4 00 	lds	r24, 0x00E4
    1056:	80 68       	ori	r24, 0x80	; 128
    1058:	80 93 e4 00 	sts	0x00E4, r24
                    input = getkey();           // Read buttons
    105c:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <getkey>
    1060:	60 cf       	rjmp	.-320    	; 0xf22 <main+0x22>
                }
            }
        }
        else
        {
           set_sleep_mode(SLEEP_MODE_IDLE);
    1062:	83 b7       	in	r24, 0x33	; 51
    1064:	81 7f       	andi	r24, 0xF1	; 241
    1066:	83 bf       	out	0x33, r24	; 51
           sleep_mode();
    1068:	83 b7       	in	r24, 0x33	; 51
    106a:	81 60       	ori	r24, 0x01	; 1
    106c:	83 bf       	out	0x33, r24	; 51
    106e:	88 95       	sleep
    1070:	83 b7       	in	r24, 0x33	; 51
    1072:	8e 7f       	andi	r24, 0xFE	; 254
    1074:	83 bf       	out	0x33, r24	; 51
    1076:	55 cf       	rjmp	.-342    	; 0xf22 <main+0x22>

00001078 <showLongHex>:
LCD_putc(6, '\0');
LCD_UpdateRequired(TRUE, 0);
}

void showLongHex(long input)
{
    1078:	df 93       	push	r29
    107a:	cf 93       	push	r28
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	6a 97       	sbiw	r28, 0x1a	; 26
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	9b 01       	movw	r18, r22
    108e:	ac 01       	movw	r20, r24
char hf[]="0123456789ABCDEF"; //todo progmem
    1090:	de 01       	movw	r26, r28
    1092:	1a 96       	adiw	r26, 0x0a	; 10
    1094:	e0 e0       	ldi	r30, 0x00	; 0
    1096:	f1 e0       	ldi	r31, 0x01	; 1
    1098:	81 e1       	ldi	r24, 0x11	; 17
    109a:	01 90       	ld	r0, Z+
    109c:	0d 92       	st	X+, r0
    109e:	81 50       	subi	r24, 0x01	; 1
    10a0:	e1 f7       	brne	.-8      	; 0x109a <showLongHex+0x22>
    10a2:	de 01       	movw	r26, r28
    10a4:	18 96       	adiw	r26, 0x08	; 8
char i;


for(i=0;i<8;i++)
{
	screen[7-i] = hf[(input & 0xF)];
    10a6:	be 01       	movw	r22, r28
    10a8:	66 5f       	subi	r22, 0xF6	; 246
    10aa:	7f 4f       	sbci	r23, 0xFF	; 255
    10ac:	f9 01       	movw	r30, r18
    10ae:	ef 70       	andi	r30, 0x0F	; 15
    10b0:	f0 70       	andi	r31, 0x00	; 0
    10b2:	e6 0f       	add	r30, r22
    10b4:	f7 1f       	adc	r31, r23
    10b6:	80 81       	ld	r24, Z
    10b8:	8c 93       	st	X, r24
	
	input = input >> 4;
    10ba:	84 e0       	ldi	r24, 0x04	; 4
    10bc:	55 95       	asr	r21
    10be:	47 95       	ror	r20
    10c0:	37 95       	ror	r19
    10c2:	27 95       	ror	r18
    10c4:	8a 95       	dec	r24
    10c6:	d1 f7       	brne	.-12     	; 0x10bc <showLongHex+0x44>
    10c8:	11 97       	sbiw	r26, 0x01	; 1
char hf[]="0123456789ABCDEF"; //todo progmem
char screen[9];
char i;


for(i=0;i<8;i++)
    10ca:	ac 17       	cp	r26, r28
    10cc:	bd 07       	cpc	r27, r29
    10ce:	71 f7       	brne	.-36     	; 0x10ac <showLongHex+0x34>
	screen[7-i] = hf[(input & 0xF)];
	
	input = input >> 4;
}

screen[8]=0;
    10d0:	19 86       	std	Y+9, r1	; 0x09

LCD_puts(screen, 1);
    10d2:	ce 01       	movw	r24, r28
    10d4:	01 96       	adiw	r24, 0x01	; 1
    10d6:	61 e0       	ldi	r22, 0x01	; 1
    10d8:	0e 94 8d 12 	call	0x251a	; 0x251a <LCD_puts>

}
    10dc:	6a 96       	adiw	r28, 0x1a	; 26
    10de:	0f b6       	in	r0, 0x3f	; 63
    10e0:	f8 94       	cli
    10e2:	de bf       	out	0x3e, r29	; 62
    10e4:	0f be       	out	0x3f, r0	; 63
    10e6:	cd bf       	out	0x3d, r28	; 61
    10e8:	cf 91       	pop	r28
    10ea:	df 91       	pop	r29
    10ec:	08 95       	ret

000010ee <doScaleMeasure>:
}

void doScaleMeasure(void)
{

float units = HX711_get_units(10);
    10ee:	8a e0       	ldi	r24, 0x0A	; 10
    10f0:	0e 94 39 12 	call	0x2472	; 0x2472 <HX711_get_units>


long val = (long)(units*10);
showLongHex(val);
    10f4:	20 e0       	ldi	r18, 0x00	; 0
    10f6:	30 e0       	ldi	r19, 0x00	; 0
    10f8:	40 e2       	ldi	r20, 0x20	; 32
    10fa:	51 e4       	ldi	r21, 0x41	; 65
    10fc:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <__mulsf3>
    1100:	0e 94 11 18 	call	0x3022	; 0x3022 <__fixsfsi>
    LCD_putc(4, 'k');
    LCD_putc(5, 'g');
    LCD_putc(6, '\0');
LCD_UpdateRequired(TRUE, 0);
*/
}
    1104:	b9 cf       	rjmp	.-142    	; 0x1078 <showLongHex>

00001106 <StateScaleMeasureFunc>:

char StateScaleMeasureFunc(char input)
{
    1106:	98 2f       	mov	r25, r24
    static char enter = 1;
	static char nr=0;
    
    if (enter)
    1108:	80 91 1d 01 	lds	r24, 0x011D
    110c:	88 23       	and	r24, r24
    110e:	81 f0       	breq	.+32     	; 0x1130 <StateScaleMeasureFunc+0x2a>
    {
        enter = 0;
    1110:	10 92 1d 01 	sts	0x011D, r1
		
		LCD_puts("TARE", 1);
    1114:	81 e1       	ldi	r24, 0x11	; 17
    1116:	91 e0       	ldi	r25, 0x01	; 1
    1118:	61 e0       	ldi	r22, 0x01	; 1
    111a:	0e 94 8d 12 	call	0x251a	; 0x251a <LCD_puts>
    
        HX711_begin(128); 
    111e:	80 e8       	ldi	r24, 0x80	; 128
    1120:	0e 94 04 12 	call	0x2408	; 0x2408 <HX711_begin>
		HX711_power_up();
    1124:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <HX711_power_up>
		HX711_tare(10);
    1128:	8a e0       	ldi	r24, 0x0A	; 10
    112a:	0e 94 56 12 	call	0x24ac	; 0x24ac <HX711_tare>
    112e:	02 c0       	rjmp	.+4      	; 0x1134 <StateScaleMeasureFunc+0x2e>
		doScaleMeasure();
    }
	else
	{
    
		if (input == KEY_PREV)
    1130:	93 30       	cpi	r25, 0x03	; 3
    1132:	19 f4       	brne	.+6      	; 0x113a <StateScaleMeasureFunc+0x34>
		{
			doScaleMeasure();
    1134:	dc df       	rcall	.-72     	; 0x10ee <doScaleMeasure>
    1136:	86 e6       	ldi	r24, 0x66	; 102
    1138:	08 95       	ret
			
			return ST_SCALE_MEASURE;
		}
		if (input == KEY_NEXT)
    113a:	92 30       	cpi	r25, 0x02	; 2
    113c:	11 f4       	brne	.+4      	; 0x1142 <StateScaleMeasureFunc+0x3c>
    113e:	87 e6       	ldi	r24, 0x67	; 103
    1140:	08 95       	ret
		{
			return ST_SCALE_CALIB;
		}
		else if (input == KEY_PLUS)
    1142:	94 30       	cpi	r25, 0x04	; 4
    1144:	11 f4       	brne	.+4      	; 0x114a <StateScaleMeasureFunc+0x44>
    1146:	8a e5       	ldi	r24, 0x5A	; 90
    1148:	08 95       	ret
		{   
			//HX711_power_down();
			//enter = 1;
			return ST_OPTIONS;
		}
		else if (input == KEY_MINUS)
    114a:	95 30       	cpi	r25, 0x05	; 5
    114c:	11 f4       	brne	.+4      	; 0x1152 <StateScaleMeasureFunc+0x4c>
    114e:	84 e1       	ldi	r24, 0x14	; 20
    1150:	08 95       	ret
    1152:	86 e6       	ldi	r24, 0x66	; 102
			return ST_TIME;
		}
	}
    
    return ST_SCALE_MEASURE;
}
    1154:	08 95       	ret

00001156 <doCalibration>:

}


void doCalibration(void)
{
    1156:	ef 92       	push	r14
    1158:	ff 92       	push	r15
    115a:	0f 93       	push	r16
    115c:	1f 93       	push	r17
float val = HX711_get_value(10);
    115e:	8a e0       	ldi	r24, 0x0A	; 10
    1160:	0e 94 2b 12 	call	0x2456	; 0x2456 <HX711_get_value>
    1164:	0e 94 44 18 	call	0x3088	; 0x3088 <__floatsisf>
    1168:	7b 01       	movw	r14, r22
    116a:	8c 01       	movw	r16, r24
HX711_set_scale(val / 2);
    116c:	20 e0       	ldi	r18, 0x00	; 0
    116e:	30 e0       	ldi	r19, 0x00	; 0
    1170:	40 e0       	ldi	r20, 0x00	; 0
    1172:	5f e3       	ldi	r21, 0x3F	; 63
    1174:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <__mulsf3>
    1178:	0e 94 44 12 	call	0x2488	; 0x2488 <HX711_set_scale>
showLongHex(val);
    117c:	c8 01       	movw	r24, r16
    117e:	b7 01       	movw	r22, r14
    1180:	0e 94 11 18 	call	0x3022	; 0x3022 <__fixsfsi>
    1184:	79 df       	rcall	.-270    	; 0x1078 <showLongHex>
    LCD_putc(4, 'x');
    LCD_putc(5, 'x');
    LCD_putc(6, '\0');
LCD_UpdateRequired(TRUE, 0);
*/
}
    1186:	1f 91       	pop	r17
    1188:	0f 91       	pop	r16
    118a:	ff 90       	pop	r15
    118c:	ef 90       	pop	r14
    118e:	08 95       	ret

00001190 <StateScaleCalibFunc>:
    
    return ST_SCALE_MEASURE;
}

char StateScaleCalibFunc(char input)
{
    1190:	98 2f       	mov	r25, r24
static char enter = 1;
    
    if (enter)
    1192:	80 91 1c 01 	lds	r24, 0x011C
    1196:	88 23       	and	r24, r24
    1198:	21 f0       	breq	.+8      	; 0x11a2 <StateScaleCalibFunc+0x12>
    {
        enter = 0;
    119a:	10 92 1c 01 	sts	0x011C, r1
		
		doCalibration();
    119e:	db df       	rcall	.-74     	; 0x1156 <doCalibration>
    11a0:	06 c0       	rjmp	.+12     	; 0x11ae <StateScaleCalibFunc+0x1e>
    }
	else
	{
    
		if (input == KEY_PREV)
    11a2:	93 30       	cpi	r25, 0x03	; 3
    11a4:	11 f4       	brne	.+4      	; 0x11aa <StateScaleCalibFunc+0x1a>
    11a6:	86 e6       	ldi	r24, 0x66	; 102
    11a8:	08 95       	ret
		{
			return ST_SCALE_MEASURE;
		}
		if (input == KEY_NEXT)
    11aa:	92 30       	cpi	r25, 0x02	; 2
    11ac:	11 f0       	breq	.+4      	; 0x11b2 <StateScaleCalibFunc+0x22>
    11ae:	87 e6       	ldi	r24, 0x67	; 103
    11b0:	08 95       	ret
		{
			doCalibration();
    11b2:	d1 df       	rcall	.-94     	; 0x1156 <doCalibration>
    11b4:	87 e6       	ldi	r24, 0x67	; 103
			
		}
	}

	return ST_SCALE_CALIB;
    11b6:	08 95       	ret

000011b8 <Timer0_Init>:
    //mt char i;
    uint8_t i;

    // Initialize array of callback functions
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
        CallbackFunc[i] = NULL;
    11b8:	10 92 8a 01 	sts	0x018A, r1
    11bc:	10 92 89 01 	sts	0x0189, r1
    11c0:	10 92 8c 01 	sts	0x018C, r1
    11c4:	10 92 8b 01 	sts	0x018B, r1
    11c8:	10 92 8e 01 	sts	0x018E, r1
    11cc:	10 92 8d 01 	sts	0x018D, r1
    11d0:	10 92 90 01 	sts	0x0190, r1
    11d4:	10 92 8f 01 	sts	0x018F, r1

    // Initialize countdown timers
    for (i=0; i<TIMER0_NUM_COUNTDOWNTIMERS; i++)
        CountDownTimers[i] = 255;
    11d8:	8f ef       	ldi	r24, 0xFF	; 255
    11da:	80 93 85 01 	sts	0x0185, r24
    11de:	80 93 86 01 	sts	0x0186, r24
    11e2:	80 93 87 01 	sts	0x0187, r24
    11e6:	80 93 88 01 	sts	0x0188, r24

    // Initialize Timer0.
    // Used to give the correct time-delays in the song

    // Enable timer0 compare interrupt
    TIMSK0 = (1<<OCIE0A);
    11ea:	82 e0       	ldi	r24, 0x02	; 2
    11ec:	80 93 6e 00 	sts	0x006E, r24

    // Sets the compare value
    OCR0A = 38;
    11f0:	86 e2       	ldi	r24, 0x26	; 38
    11f2:	87 bd       	out	0x27, r24	; 39

    // Set Clear on Timer Compare (CTC) mode, CLK/256 prescaler
    TCCR0A = (1<<WGM01)|(0<<WGM00)|(4<<CS00);
    11f4:	8c e0       	ldi	r24, 0x0C	; 12
    11f6:	84 bd       	out	0x24, r24	; 36
}
    11f8:	08 95       	ret

000011fa <__vector_10>:
// #pragma vector = TIMER0_COMP_vect
// __interrupt void TIMER0_COMP_interrupt(void)
// SIGNAL(SIG_OUTPUT_COMPARE0)
ISR(TIMER0_COMP_vect)
// mtE
{
    11fa:	1f 92       	push	r1
    11fc:	0f 92       	push	r0
    11fe:	0f b6       	in	r0, 0x3f	; 63
    1200:	0f 92       	push	r0
    1202:	11 24       	eor	r1, r1
    1204:	2f 93       	push	r18
    1206:	3f 93       	push	r19
    1208:	4f 93       	push	r20
    120a:	5f 93       	push	r21
    120c:	6f 93       	push	r22
    120e:	7f 93       	push	r23
    1210:	8f 93       	push	r24
    1212:	9f 93       	push	r25
    1214:	af 93       	push	r26
    1216:	bf 93       	push	r27
    1218:	ef 93       	push	r30
    121a:	ff 93       	push	r31
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
        if (CallbackFunc[i] != NULL)
    121c:	e0 91 89 01 	lds	r30, 0x0189
    1220:	f0 91 8a 01 	lds	r31, 0x018A
    1224:	30 97       	sbiw	r30, 0x00	; 0
    1226:	09 f0       	breq	.+2      	; 0x122a <__vector_10+0x30>
            CallbackFunc[i]();
    1228:	09 95       	icall
{
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
        if (CallbackFunc[i] != NULL)
    122a:	e0 91 8b 01 	lds	r30, 0x018B
    122e:	f0 91 8c 01 	lds	r31, 0x018C
    1232:	30 97       	sbiw	r30, 0x00	; 0
    1234:	09 f0       	breq	.+2      	; 0x1238 <__vector_10+0x3e>
            CallbackFunc[i]();
    1236:	09 95       	icall
{
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
        if (CallbackFunc[i] != NULL)
    1238:	e0 91 8d 01 	lds	r30, 0x018D
    123c:	f0 91 8e 01 	lds	r31, 0x018E
    1240:	30 97       	sbiw	r30, 0x00	; 0
    1242:	09 f0       	breq	.+2      	; 0x1246 <__vector_10+0x4c>
            CallbackFunc[i]();
    1244:	09 95       	icall
{
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
        if (CallbackFunc[i] != NULL)
    1246:	e0 91 8f 01 	lds	r30, 0x018F
    124a:	f0 91 90 01 	lds	r31, 0x0190
    124e:	30 97       	sbiw	r30, 0x00	; 0
    1250:	09 f0       	breq	.+2      	; 0x1254 <__vector_10+0x5a>
            CallbackFunc[i]();
    1252:	09 95       	icall
    1254:	e5 e8       	ldi	r30, 0x85	; 133
    1256:	f1 e0       	ldi	r31, 0x01	; 1
    
    // Count down timers
    for (i=0; i<TIMER0_NUM_COUNTDOWNTIMERS; i++)
        if (CountDownTimers[i] != 255 && CountDownTimers[i] != 0)
    1258:	80 81       	ld	r24, Z
    125a:	81 50       	subi	r24, 0x01	; 1
    125c:	8e 3f       	cpi	r24, 0xFE	; 254
    125e:	08 f4       	brcc	.+2      	; 0x1262 <__vector_10+0x68>
            CountDownTimers[i]--;
    1260:	80 83       	st	Z, r24
    1262:	31 96       	adiw	r30, 0x01	; 1
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
        if (CallbackFunc[i] != NULL)
            CallbackFunc[i]();
    
    // Count down timers
    for (i=0; i<TIMER0_NUM_COUNTDOWNTIMERS; i++)
    1264:	81 e0       	ldi	r24, 0x01	; 1
    1266:	e9 38       	cpi	r30, 0x89	; 137
    1268:	f8 07       	cpc	r31, r24
    126a:	b1 f7       	brne	.-20     	; 0x1258 <__vector_10+0x5e>
        if (CountDownTimers[i] != 255 && CountDownTimers[i] != 0)
            CountDownTimers[i]--;

}
    126c:	ff 91       	pop	r31
    126e:	ef 91       	pop	r30
    1270:	bf 91       	pop	r27
    1272:	af 91       	pop	r26
    1274:	9f 91       	pop	r25
    1276:	8f 91       	pop	r24
    1278:	7f 91       	pop	r23
    127a:	6f 91       	pop	r22
    127c:	5f 91       	pop	r21
    127e:	4f 91       	pop	r20
    1280:	3f 91       	pop	r19
    1282:	2f 91       	pop	r18
    1284:	0f 90       	pop	r0
    1286:	0f be       	out	0x3f, r0	; 63
    1288:	0f 90       	pop	r0
    128a:	1f 90       	pop	r1
    128c:	18 95       	reti

0000128e <Timer0_RegisterCallbackFunction>:
*   Purpose :       Set up functions to be called from the 
*                   TIMER0_COMP_interrupt
*
*****************************************************************************/
BOOL Timer0_RegisterCallbackFunction(TIMER_CALLBACK_FUNC pFunc)
{
    128e:	9c 01       	movw	r18, r24
    1290:	a9 e8       	ldi	r26, 0x89	; 137
    1292:	b1 e0       	ldi	r27, 0x01	; 1
    1294:	fd 01       	movw	r30, r26
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
    {
        if (CallbackFunc[i] == pFunc)
    1296:	80 81       	ld	r24, Z
    1298:	91 81       	ldd	r25, Z+1	; 0x01
    129a:	82 17       	cp	r24, r18
    129c:	93 07       	cpc	r25, r19
    129e:	91 f0       	breq	.+36     	; 0x12c4 <Timer0_RegisterCallbackFunction+0x36>
    12a0:	32 96       	adiw	r30, 0x02	; 2
BOOL Timer0_RegisterCallbackFunction(TIMER_CALLBACK_FUNC pFunc)
{
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
    12a2:	81 e0       	ldi	r24, 0x01	; 1
    12a4:	e1 39       	cpi	r30, 0x91	; 145
    12a6:	f8 07       	cpc	r31, r24
    12a8:	b1 f7       	brne	.-20     	; 0x1296 <Timer0_RegisterCallbackFunction+0x8>
    12aa:	e0 e0       	ldi	r30, 0x00	; 0
    12ac:	f0 e0       	ldi	r31, 0x00	; 0
            return TRUE;
    }
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
    {
        if (CallbackFunc[i] == NULL)
    12ae:	8d 91       	ld	r24, X+
    12b0:	9c 91       	ld	r25, X
    12b2:	11 97       	sbiw	r26, 0x01	; 1
    12b4:	89 2b       	or	r24, r25
    12b6:	41 f4       	brne	.+16     	; 0x12c8 <Timer0_RegisterCallbackFunction+0x3a>
        {
            CallbackFunc[i] = pFunc;
    12b8:	ee 0f       	add	r30, r30
    12ba:	ff 1f       	adc	r31, r31
    12bc:	e7 57       	subi	r30, 0x77	; 119
    12be:	fe 4f       	sbci	r31, 0xFE	; 254
    12c0:	31 83       	std	Z+1, r19	; 0x01
    12c2:	20 83       	st	Z, r18
    12c4:	81 e0       	ldi	r24, 0x01	; 1
    12c6:	08 95       	ret
            return TRUE;
    12c8:	31 96       	adiw	r30, 0x01	; 1
    12ca:	12 96       	adiw	r26, 0x02	; 2
    {
        if (CallbackFunc[i] == pFunc)
            return TRUE;
    }
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
    12cc:	e4 30       	cpi	r30, 0x04	; 4
    12ce:	f1 05       	cpc	r31, r1
    12d0:	71 f7       	brne	.-36     	; 0x12ae <Timer0_RegisterCallbackFunction+0x20>
    12d2:	80 e0       	ldi	r24, 0x00	; 0
            return TRUE;
        }   
    }
    
    return FALSE;
}
    12d4:	08 95       	ret

000012d6 <Timer0_RemoveCallbackFunction>:
*   Purpose :       Remove functions from the list which is called int the
*                   TIMER0_COMP_interrupt
*
*****************************************************************************/
BOOL Timer0_RemoveCallbackFunction(TIMER_CALLBACK_FUNC pFunc)
{
    12d6:	9c 01       	movw	r18, r24
    12d8:	a9 e8       	ldi	r26, 0x89	; 137
    12da:	b1 e0       	ldi	r27, 0x01	; 1
    12dc:	e0 e0       	ldi	r30, 0x00	; 0
    12de:	f0 e0       	ldi	r31, 0x00	; 0
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
    {
        if (CallbackFunc[i] == pFunc)
    12e0:	8d 91       	ld	r24, X+
    12e2:	9c 91       	ld	r25, X
    12e4:	11 97       	sbiw	r26, 0x01	; 1
    12e6:	82 17       	cp	r24, r18
    12e8:	93 07       	cpc	r25, r19
    12ea:	41 f4       	brne	.+16     	; 0x12fc <Timer0_RemoveCallbackFunction+0x26>
        {
            CallbackFunc[i] = NULL;
    12ec:	ee 0f       	add	r30, r30
    12ee:	ff 1f       	adc	r31, r31
    12f0:	e7 57       	subi	r30, 0x77	; 119
    12f2:	fe 4f       	sbci	r31, 0xFE	; 254
    12f4:	11 82       	std	Z+1, r1	; 0x01
    12f6:	10 82       	st	Z, r1
    12f8:	81 e0       	ldi	r24, 0x01	; 1
    12fa:	08 95       	ret
            return TRUE;
    12fc:	31 96       	adiw	r30, 0x01	; 1
    12fe:	12 96       	adiw	r26, 0x02	; 2
BOOL Timer0_RemoveCallbackFunction(TIMER_CALLBACK_FUNC pFunc)
{
    // mt char i;
    uint8_t i;
    
    for (i=0; i<TIMER0_NUM_CALLBACKS; i++)
    1300:	e4 30       	cpi	r30, 0x04	; 4
    1302:	f1 05       	cpc	r31, r1
    1304:	69 f7       	brne	.-38     	; 0x12e0 <Timer0_RemoveCallbackFunction+0xa>
    1306:	80 e0       	ldi	r24, 0x00	; 0
            return TRUE;
        }
    }
        
    return FALSE;
}
    1308:	08 95       	ret

0000130a <Timer0_AllocateCountdownTimer>:


char Timer0_AllocateCountdownTimer()
{
    130a:	20 e0       	ldi	r18, 0x00	; 0
    130c:	30 e0       	ldi	r19, 0x00	; 0
    // mt char i;
    uint8_t i;

    for (i=0; i<TIMER0_NUM_COUNTDOWNTIMERS; i++)
        if (CountDownTimers[i] == 255)
    130e:	f9 01       	movw	r30, r18
    1310:	eb 57       	subi	r30, 0x7B	; 123
    1312:	fe 4f       	sbci	r31, 0xFE	; 254
    1314:	80 81       	ld	r24, Z
    1316:	8f 3f       	cpi	r24, 0xFF	; 255
    1318:	21 f4       	brne	.+8      	; 0x1322 <Timer0_AllocateCountdownTimer+0x18>
        {
            CountDownTimers[i] = 0;
    131a:	10 82       	st	Z, r1
            return i+1;
    131c:	82 2f       	mov	r24, r18
    131e:	8f 5f       	subi	r24, 0xFF	; 255
    1320:	08 95       	ret
    1322:	2f 5f       	subi	r18, 0xFF	; 255
    1324:	3f 4f       	sbci	r19, 0xFF	; 255
char Timer0_AllocateCountdownTimer()
{
    // mt char i;
    uint8_t i;

    for (i=0; i<TIMER0_NUM_COUNTDOWNTIMERS; i++)
    1326:	24 30       	cpi	r18, 0x04	; 4
    1328:	31 05       	cpc	r19, r1
    132a:	89 f7       	brne	.-30     	; 0x130e <Timer0_AllocateCountdownTimer+0x4>
    132c:	80 e0       	ldi	r24, 0x00	; 0
            CountDownTimers[i] = 0;
            return i+1;
        }

    return 0;
}
    132e:	08 95       	ret

00001330 <CHAR2BCD2>:
*                   The result is byte where the high and low nibbles
*                   contain the tens and ones of the input.
*
*****************************************************************************/
char CHAR2BCD2(char input)
{
    1330:	98 2f       	mov	r25, r24
    1332:	80 e0       	ldi	r24, 0x00	; 0
    1334:	02 c0       	rjmp	.+4      	; 0x133a <CHAR2BCD2+0xa>
    char high = 0;
    
    
    while (input >= 10)                 // Count tens
    {
        high++;
    1336:	8f 5f       	subi	r24, 0xFF	; 255
        input -= 10;
    1338:	9a 50       	subi	r25, 0x0A	; 10
char CHAR2BCD2(char input)
{
    char high = 0;
    
    
    while (input >= 10)                 // Count tens
    133a:	9a 30       	cpi	r25, 0x0A	; 10
    133c:	e0 f7       	brcc	.-8      	; 0x1336 <CHAR2BCD2+0x6>
    133e:	82 95       	swap	r24
    1340:	80 7f       	andi	r24, 0xF0	; 240
        high++;
        input -= 10;
    }

    return  (high << 4) | input;        // Add ones and return answer
}
    1342:	89 2b       	or	r24, r25
    1344:	08 95       	ret

00001346 <CHAR2BCD3>:
*                   The result is an integer where the three lowest nibbles
*                   contain the ones, tens and hundreds of the input.
*
*****************************************************************************/
unsigned int CHAR2BCD3(char input)
{
    1346:	20 e0       	ldi	r18, 0x00	; 0
    1348:	30 e0       	ldi	r19, 0x00	; 0
    134a:	03 c0       	rjmp	.+6      	; 0x1352 <CHAR2BCD3+0xc>
    int high = 0;
        
    while (input >= 100)                // Count hundreds
    {
        high++;
    134c:	2f 5f       	subi	r18, 0xFF	; 255
    134e:	3f 4f       	sbci	r19, 0xFF	; 255
        input -= 100;
    1350:	84 56       	subi	r24, 0x64	; 100
*****************************************************************************/
unsigned int CHAR2BCD3(char input)
{
    int high = 0;
        
    while (input >= 100)                // Count hundreds
    1352:	84 36       	cpi	r24, 0x64	; 100
    1354:	d8 f7       	brcc	.-10     	; 0x134c <CHAR2BCD3+0x6>
    {
        high++;
        input -= 100;
    }

    high <<= 4;
    1356:	54 e0       	ldi	r21, 0x04	; 4
    1358:	22 0f       	add	r18, r18
    135a:	33 1f       	adc	r19, r19
    135c:	5a 95       	dec	r21
    135e:	e1 f7       	brne	.-8      	; 0x1358 <CHAR2BCD3+0x12>
    1360:	03 c0       	rjmp	.+6      	; 0x1368 <CHAR2BCD3+0x22>
    
    while (input >= 10)                 // Count tens
    {
        high++;
    1362:	2f 5f       	subi	r18, 0xFF	; 255
    1364:	3f 4f       	sbci	r19, 0xFF	; 255
        input -= 10;
    1366:	8a 50       	subi	r24, 0x0A	; 10
        input -= 100;
    }

    high <<= 4;
    
    while (input >= 10)                 // Count tens
    1368:	8a 30       	cpi	r24, 0x0A	; 10
    136a:	d8 f7       	brcc	.-10     	; 0x1362 <CHAR2BCD3+0x1c>
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	44 e0       	ldi	r20, 0x04	; 4
    1370:	22 0f       	add	r18, r18
    1372:	33 1f       	adc	r19, r19
    1374:	4a 95       	dec	r20
    1376:	e1 f7       	brne	.-8      	; 0x1370 <CHAR2BCD3+0x2a>
        high++;
        input -= 10;
    }

    return  (high << 4) | input;        // Add ones and return answer
}
    1378:	82 2b       	or	r24, r18
    137a:	93 2b       	or	r25, r19
    137c:	08 95       	ret

0000137e <USART_Init>:
*
*****************************************************************************/
void USART_Init(unsigned int baudrate)
{
    // Set baud rate
    UBRRH = (unsigned char)(baudrate>>8);
    137e:	29 2f       	mov	r18, r25
    1380:	33 27       	eor	r19, r19
    1382:	20 93 c5 00 	sts	0x00C5, r18
    UBRRL = (unsigned char)baudrate;
    1386:	80 93 c4 00 	sts	0x00C4, r24

    // Enable 2x speed
    UCSRA = (1<<U2X);
    138a:	82 e0       	ldi	r24, 0x02	; 2
    138c:	80 93 c0 00 	sts	0x00C0, r24
    UCSRB = (1<<RXEN)|(1<<TXEN)|(0<<RXCIE)|(0<<UDRIE);
#else
    // Enable receive. transmit stays disabled
    // In the default BF demo-application no data gets 
    // send (only receive in vcard).
    UCSRB = (1<<RXEN)|(0<<TXEN)|(0<<RXCIE)|(0<<UDRIE);
    1390:	80 e1       	ldi	r24, 0x10	; 16
    1392:	80 93 c1 00 	sts	0x00C1, r24
#endif

    // Async. mode, 8N1
    UCSRC = (0<<UMSEL)|(0<<UPM0)|(0<<USBS)|(3<<UCSZ0)|(0<<UCPOL);
    1396:	86 e0       	ldi	r24, 0x06	; 6
    1398:	80 93 c2 00 	sts	0x00C2, r24
}
    139c:	08 95       	ret

0000139e <ADC_read>:
    // mt int ADC = 0 ;
    int ADCr = 0;
    
    // To save power, the voltage over the LDR and the NTC is turned off when not used
    // This is done by controlling the voltage from a I/O-pin (PORTF3)
    sbiBF(PORTF, PF3); // mt sbi(PORTF, PORTF3);     // Enable the VCP (VC-peripheral)
    139e:	8b 9a       	sbi	0x11, 3	; 17
    sbiBF(DDRF, DDF3); // sbi(DDRF, PORTF3);        
    13a0:	83 9a       	sbi	0x10, 3	; 16

    sbiBF(ADCSRA, ADEN);     // Enable the ADC
    13a2:	80 91 7a 00 	lds	r24, 0x007A
    13a6:	80 68       	ori	r24, 0x80	; 128
    13a8:	80 93 7a 00 	sts	0x007A, r24

    //do a dummy readout first
    ADCSRA |= (1<<ADSC);        // do single conversion
    13ac:	80 91 7a 00 	lds	r24, 0x007A
    13b0:	80 64       	ori	r24, 0x40	; 64
    13b2:	80 93 7a 00 	sts	0x007A, r24
    while(!(ADCSRA & 0x10));    // wait for conversion done, ADIF flag active
    13b6:	80 91 7a 00 	lds	r24, 0x007A
    13ba:	84 ff       	sbrs	r24, 4
    13bc:	fc cf       	rjmp	.-8      	; 0x13b6 <ADC_read+0x18>
    13be:	30 e0       	ldi	r19, 0x00	; 0
    13c0:	40 e0       	ldi	r20, 0x00	; 0
    13c2:	50 e0       	ldi	r21, 0x00	; 0
        
    for(i=0;i<8;i++)            // do the ADC conversion 8 times for better accuracy 
    {
        ADCSRA |= (1<<ADSC);        // do single conversion
    13c4:	80 91 7a 00 	lds	r24, 0x007A
    13c8:	80 64       	ori	r24, 0x40	; 64
    13ca:	80 93 7a 00 	sts	0x007A, r24
        while(!(ADCSRA & 0x10));    // wait for conversion done, ADIF flag active
    13ce:	80 91 7a 00 	lds	r24, 0x007A
    13d2:	84 ff       	sbrs	r24, 4
    13d4:	fc cf       	rjmp	.-8      	; 0x13ce <ADC_read+0x30>
        
        ADC_temp = ADCL;            // read out ADCL register
    13d6:	20 91 78 00 	lds	r18, 0x0078
        ADC_temp += (ADCH << 8);    // read out ADCH register        
    13da:	80 91 79 00 	lds	r24, 0x0079

        ADCr += ADC_temp;      // accumulate result (8 samples) for later averaging
    13de:	90 e0       	ldi	r25, 0x00	; 0
    13e0:	98 2f       	mov	r25, r24
    13e2:	88 27       	eor	r24, r24
    13e4:	82 0f       	add	r24, r18
    13e6:	91 1d       	adc	r25, r1
    13e8:	48 0f       	add	r20, r24
    13ea:	59 1f       	adc	r21, r25

    //do a dummy readout first
    ADCSRA |= (1<<ADSC);        // do single conversion
    while(!(ADCSRA & 0x10));    // wait for conversion done, ADIF flag active
        
    for(i=0;i<8;i++)            // do the ADC conversion 8 times for better accuracy 
    13ec:	3f 5f       	subi	r19, 0xFF	; 255
    13ee:	38 30       	cpi	r19, 0x08	; 8
    13f0:	49 f7       	brne	.-46     	; 0x13c4 <ADC_read+0x26>
        ADCr += ADC_temp;      // accumulate result (8 samples) for later averaging
    }

    ADCr = ADCr >> 3;     // average the 8 samples
        
    cbiBF(PORTF,PF3); // mt cbi(PORTF, PORTF3);     // disable the VCP
    13f2:	8b 98       	cbi	0x11, 3	; 17
    cbiBF(DDRF,DDF3); // mt cbi(DDRF, PORTF3);  
    13f4:	83 98       	cbi	0x10, 3	; 16
    
    cbiBF(ADCSRA, ADEN);      // disable the ADC
    13f6:	80 91 7a 00 	lds	r24, 0x007A
    13fa:	8f 77       	andi	r24, 0x7F	; 127
    13fc:	80 93 7a 00 	sts	0x007A, r24

    return ADCr;
}
    1400:	ca 01       	movw	r24, r20
    1402:	23 e0       	ldi	r18, 0x03	; 3
    1404:	95 95       	asr	r25
    1406:	87 95       	ror	r24
    1408:	2a 95       	dec	r18
    140a:	e1 f7       	brne	.-8      	; 0x1404 <ADC_read+0x66>
    140c:	08 95       	ret

0000140e <ADC_init>:
*
*****************************************************************************/
void ADC_init(char input)
{
  
    ADMUX = input;    // external AREF and ADCx
    140e:	80 93 7c 00 	sts	0x007C, r24
    
    ADCSRA = (1<<ADEN) | (1<<ADPS1) | (1<<ADPS0);    // set ADC prescaler to , 1MHz / 8 = 125kHz    
    1412:	83 e8       	ldi	r24, 0x83	; 131
    1414:	80 93 7a 00 	sts	0x007A, r24

    input = ADC_read();        // dummy 
}
    1418:	c2 cf       	rjmp	.-124    	; 0x139e <ADC_read>

0000141a <LightFunc>:
*
*   Purpose :       Enable or disable light measurements
*
*****************************************************************************/
char LightFunc(char input)
{
    141a:	1f 93       	push	r17
    141c:	18 2f       	mov	r17, r24
    static char enter = 1;
    
    if (enter)
    141e:	80 91 23 01 	lds	r24, 0x0123
    1422:	88 23       	and	r24, r24
    1424:	41 f0       	breq	.+16     	; 0x1436 <LightFunc+0x1c>
    {
    
        enter = 0;
    1426:	10 92 23 01 	sts	0x0123, r1
        
        ADC_init(LIGHT_SENSOR);     // Init the ADC
    142a:	82 e0       	ldi	r24, 0x02	; 2
    142c:	f0 df       	rcall	.-32     	; 0x140e <ADC_init>
        
        // Enable auto-run of the ADC_perphery every 10ms 
        // (it will actually be more than 10ms cause of the SLEEP)  
        Timer0_RegisterCallbackFunction(ADC_periphery);        
    142e:	8e e7       	ldi	r24, 0x7E	; 126
    1430:	9a e0       	ldi	r25, 0x0A	; 10
    1432:	2d df       	rcall	.-422    	; 0x128e <Timer0_RegisterCallbackFunction>
    1434:	04 c0       	rjmp	.+8      	; 0x143e <LightFunc+0x24>
    }
    else
        LCD_UpdateRequired(TRUE, 0); 
    1436:	81 e0       	ldi	r24, 0x01	; 1
    1438:	60 e0       	ldi	r22, 0x00	; 0
    143a:	0e 94 d6 12 	call	0x25ac	; 0x25ac <LCD_UpdateRequired>

    if (input == KEY_PREV)
    143e:	13 30       	cpi	r17, 0x03	; 3
    1440:	11 f0       	breq	.+4      	; 0x1446 <LightFunc+0x2c>
    1442:	81 e5       	ldi	r24, 0x51	; 81
    1444:	07 c0       	rjmp	.+14     	; 0x1454 <LightFunc+0x3a>
    {
        // Disable the auto-run of the ADC_periphery      
        Timer0_RemoveCallbackFunction(ADC_periphery);
    1446:	8e e7       	ldi	r24, 0x7E	; 126
    1448:	9a e0       	ldi	r25, 0x0A	; 10
    144a:	45 df       	rcall	.-374    	; 0x12d6 <Timer0_RemoveCallbackFunction>
        
        enter = 1;  // Set enter to 1 before leaving the TemperatureFunc
    144c:	81 e0       	ldi	r24, 0x01	; 1
    144e:	80 93 23 01 	sts	0x0123, r24
    1452:	80 e5       	ldi	r24, 0x50	; 80
    
        return ST_LIGHT;
    }
    else
        return ST_LIGHT_FUNC;    
}
    1454:	1f 91       	pop	r17
    1456:	08 95       	ret

00001458 <VoltageFunc>:
*
*   Purpose :       Enable or disable voltage measurements
*
*****************************************************************************/
char VoltageFunc(char input)
{
    1458:	1f 93       	push	r17
    145a:	18 2f       	mov	r17, r24
    static char enter = 1;
    
    if (enter)
    145c:	80 91 24 01 	lds	r24, 0x0124
    1460:	88 23       	and	r24, r24
    1462:	41 f0       	breq	.+16     	; 0x1474 <VoltageFunc+0x1c>
    {
        enter = 0;
    1464:	10 92 24 01 	sts	0x0124, r1

        ADC_init(VOLTAGE_SENSOR);       // Init the ADC
    1468:	81 e0       	ldi	r24, 0x01	; 1
    146a:	d1 df       	rcall	.-94     	; 0x140e <ADC_init>
        
        // Enable auto-run of the ADC_perphery every 10ms 
        // (it will actually be more than 10ms cause of the SLEEP)        
        Timer0_RegisterCallbackFunction(ADC_periphery);        
    146c:	8e e7       	ldi	r24, 0x7E	; 126
    146e:	9a e0       	ldi	r25, 0x0A	; 10
    1470:	0e df       	rcall	.-484    	; 0x128e <Timer0_RegisterCallbackFunction>
    1472:	04 c0       	rjmp	.+8      	; 0x147c <VoltageFunc+0x24>
    }
    else
        LCD_UpdateRequired(TRUE, 0); 
    1474:	81 e0       	ldi	r24, 0x01	; 1
    1476:	60 e0       	ldi	r22, 0x00	; 0
    1478:	0e 94 d6 12 	call	0x25ac	; 0x25ac <LCD_UpdateRequired>

    if (input == KEY_PREV)
    147c:	13 30       	cpi	r17, 0x03	; 3
    147e:	11 f0       	breq	.+4      	; 0x1484 <VoltageFunc+0x2c>
    1480:	87 e4       	ldi	r24, 0x47	; 71
    1482:	07 c0       	rjmp	.+14     	; 0x1492 <VoltageFunc+0x3a>
    {
        // Disable the auto-run of the ADC_periphery        
        Timer0_RemoveCallbackFunction(ADC_periphery);
    1484:	8e e7       	ldi	r24, 0x7E	; 126
    1486:	9a e0       	ldi	r25, 0x0A	; 10
    1488:	26 df       	rcall	.-436    	; 0x12d6 <Timer0_RemoveCallbackFunction>
        
        enter = 1;  // Set enter to 1 before leaving the TemperatureFunc
    148a:	81 e0       	ldi	r24, 0x01	; 1
    148c:	80 93 24 01 	sts	0x0124, r24
    1490:	86 e4       	ldi	r24, 0x46	; 70
        
        return ST_VOLTAGE;
    }
    else
        return ST_VOLTAGE_FUNC;    
}
    1492:	1f 91       	pop	r17
    1494:	08 95       	ret

00001496 <TemperatureFunc>:
*
*   Purpose :       Enable or disable temperature measurements
*
*****************************************************************************/
char TemperatureFunc(char input)
{
    1496:	1f 93       	push	r17
    1498:	18 2f       	mov	r17, r24
    static char enter = 1;
    
    if (enter)
    149a:	80 91 25 01 	lds	r24, 0x0125
    149e:	88 23       	and	r24, r24
    14a0:	41 f0       	breq	.+16     	; 0x14b2 <TemperatureFunc+0x1c>
    {
        enter = 0;
    14a2:	10 92 25 01 	sts	0x0125, r1
        
        ADC_init(TEMPERATURE_SENSOR);       // Init the ADC
    14a6:	80 e0       	ldi	r24, 0x00	; 0
    14a8:	b2 df       	rcall	.-156    	; 0x140e <ADC_init>

        // Enable auto-run of the ADC_perphery every 10ms 
        // (it will actually be more than 10ms cause of the SLEEP)
        Timer0_RegisterCallbackFunction(ADC_periphery); 
    14aa:	8e e7       	ldi	r24, 0x7E	; 126
    14ac:	9a e0       	ldi	r25, 0x0A	; 10
    14ae:	ef de       	rcall	.-546    	; 0x128e <Timer0_RegisterCallbackFunction>
    14b0:	04 c0       	rjmp	.+8      	; 0x14ba <TemperatureFunc+0x24>
    }
    else
        LCD_UpdateRequired(TRUE, 0);        // New data to be presented
    14b2:	81 e0       	ldi	r24, 0x01	; 1
    14b4:	60 e0       	ldi	r22, 0x00	; 0
    14b6:	0e 94 d6 12 	call	0x25ac	; 0x25ac <LCD_UpdateRequired>
    
    if (input == KEY_PREV)
    14ba:	13 30       	cpi	r17, 0x03	; 3
    14bc:	41 f4       	brne	.+16     	; 0x14ce <TemperatureFunc+0x38>
    {
        // Disable the auto-run of the ADC_periphery
        Timer0_RemoveCallbackFunction(ADC_periphery);
    14be:	8e e7       	ldi	r24, 0x7E	; 126
    14c0:	9a e0       	ldi	r25, 0x0A	; 10
    14c2:	09 df       	rcall	.-494    	; 0x12d6 <Timer0_RemoveCallbackFunction>
        
        enter = 1;  // Set enter to 1 before leaving the TemperatureFunc
    14c4:	81 e0       	ldi	r24, 0x01	; 1
    14c6:	80 93 25 01 	sts	0x0125, r24
    14ca:	8c e3       	ldi	r24, 0x3C	; 60
    14cc:	15 c0       	rjmp	.+42     	; 0x14f8 <TemperatureFunc+0x62>
        
        return ST_TEMPERATURE;
    }
    else if (input == KEY_PLUS)
    14ce:	14 30       	cpi	r17, 0x04	; 4
    14d0:	39 f4       	brne	.+14     	; 0x14e0 <TemperatureFunc+0x4a>
    {   
        if (degree == FAHRENHEIT)
    14d2:	80 91 22 01 	lds	r24, 0x0122
    14d6:	84 30       	cpi	r24, 0x04	; 4
    14d8:	49 f0       	breq	.+18     	; 0x14ec <TemperatureFunc+0x56>
            degree = CELSIUS;
        else
            degree = FAHRENHEIT;
    14da:	10 93 22 01 	sts	0x0122, r17
    14de:	0b c0       	rjmp	.+22     	; 0x14f6 <TemperatureFunc+0x60>
    }
    else if (input == KEY_MINUS)
    14e0:	15 30       	cpi	r17, 0x05	; 5
    14e2:	49 f4       	brne	.+18     	; 0x14f6 <TemperatureFunc+0x60>
    {
        if (degree == FAHRENHEIT)
    14e4:	80 91 22 01 	lds	r24, 0x0122
    14e8:	84 30       	cpi	r24, 0x04	; 4
    14ea:	11 f4       	brne	.+4      	; 0x14f0 <TemperatureFunc+0x5a>
            degree = CELSIUS;
    14ec:	83 e0       	ldi	r24, 0x03	; 3
    14ee:	01 c0       	rjmp	.+2      	; 0x14f2 <TemperatureFunc+0x5c>
        else
            degree = FAHRENHEIT;
    14f0:	84 e0       	ldi	r24, 0x04	; 4
    14f2:	80 93 22 01 	sts	0x0122, r24
    14f6:	8d e3       	ldi	r24, 0x3D	; 61
    }
    
    return ST_TEMPERATURE_FUNC;
}
    14f8:	1f 91       	pop	r17
    14fa:	08 95       	ret

000014fc <ADC_periphery>:
*   Purpose :       Calculates the Temperature/Voltage/Ligth from the ADC_read
*                   and puts it out on the LCD.
*
*****************************************************************************/
void ADC_periphery(void)
{
    14fc:	9f 92       	push	r9
    14fe:	af 92       	push	r10
    1500:	bf 92       	push	r11
    1502:	cf 92       	push	r12
    1504:	df 92       	push	r13
    1506:	ef 92       	push	r14
    1508:	ff 92       	push	r15
    150a:	0f 93       	push	r16
    150c:	1f 93       	push	r17
    150e:	cf 93       	push	r28
    1510:	df 93       	push	r29

    float V_ADC;
    char VoltageHB;
    char VoltageLB;
    
    ADCresult = ADC_read();         // Find the ADC value
    1512:	45 df       	rcall	.-374    	; 0x139e <ADC_read>
    1514:	ec 01       	movw	r28, r24
     
    if( ADMUX == TEMPERATURE_SENSOR )
    1516:	80 91 7c 00 	lds	r24, 0x007C
    151a:	88 23       	and	r24, r24
    151c:	09 f0       	breq	.+2      	; 0x1520 <ADC_periphery+0x24>
    151e:	87 c0       	rjmp	.+270    	; 0x162e <ADC_periphery+0x132>
    {
        if(degree == CELSIUS)
    1520:	80 91 22 01 	lds	r24, 0x0122
    1524:	83 30       	cpi	r24, 0x03	; 3
    1526:	09 f0       	breq	.+2      	; 0x152a <ADC_periphery+0x2e>
    1528:	46 c0       	rjmp	.+140    	; 0x15b6 <ADC_periphery+0xba>
        {
            if(ADCresult > 810)         // If it's a negtive temperature
    152a:	83 e0       	ldi	r24, 0x03	; 3
    152c:	cb 32       	cpi	r28, 0x2B	; 43
    152e:	d8 07       	cpc	r29, r24
    1530:	8c f0       	brlt	.+34     	; 0x1554 <ADC_periphery+0x58>
    1532:	21 e6       	ldi	r18, 0x61	; 97
    1534:	33 e0       	ldi	r19, 0x03	; 3
    1536:	10 e0       	ldi	r17, 0x00	; 0
            {    
                for (i=0; i<=25; i++)   // Find the temperature
                {
                    // mt if (ADCresult <= TEMP_Celcius_neg[i])
                    if (ADCresult <= (int)pgm_read_word(&TEMP_Celsius_neg[i]))
    1538:	f9 01       	movw	r30, r18
    153a:	85 91       	lpm	r24, Z+
    153c:	94 91       	lpm	r25, Z+
    153e:	8c 17       	cp	r24, r28
    1540:	9d 07       	cpc	r25, r29
    1542:	2c f4       	brge	.+10     	; 0x154e <ADC_periphery+0x52>
    {
        if(degree == CELSIUS)
        {
            if(ADCresult > 810)         // If it's a negtive temperature
            {    
                for (i=0; i<=25; i++)   // Find the temperature
    1544:	1f 5f       	subi	r17, 0xFF	; 255
    1546:	2e 5f       	subi	r18, 0xFE	; 254
    1548:	3f 4f       	sbci	r19, 0xFF	; 255
    154a:	1a 31       	cpi	r17, 0x1A	; 26
    154c:	a9 f7       	brne	.-22     	; 0x1538 <ADC_periphery+0x3c>
                    {
                        break;
                    }
                }
                
                LCD_putc(1, '-');       // Put a minus sign in front of the temperature
    154e:	81 e0       	ldi	r24, 0x01	; 1
    1550:	6d e2       	ldi	r22, 0x2D	; 45
    1552:	14 c0       	rjmp	.+40     	; 0x157c <ADC_periphery+0x80>
            }
            else if (ADCresult < 800)   // If it's a positive temperature
    1554:	93 e0       	ldi	r25, 0x03	; 3
    1556:	c0 32       	cpi	r28, 0x20	; 32
    1558:	d9 07       	cpc	r29, r25
    155a:	94 f4       	brge	.+36     	; 0x1580 <ADC_periphery+0x84>
    155c:	27 ee       	ldi	r18, 0xE7	; 231
    155e:	32 e0       	ldi	r19, 0x02	; 2
    1560:	10 e0       	ldi	r17, 0x00	; 0
            {
                for (i=0; i<100; i++)  
                {
                    // mt if (ADCresult >= TEMP_Celcius_pos[i])
                    if (ADCresult >= (int)pgm_read_word(&TEMP_Celsius_pos[i]))
    1562:	f9 01       	movw	r30, r18
    1564:	85 91       	lpm	r24, Z+
    1566:	94 91       	lpm	r25, Z+
    1568:	c8 17       	cp	r28, r24
    156a:	d9 07       	cpc	r29, r25
    156c:	2c f4       	brge	.+10     	; 0x1578 <ADC_periphery+0x7c>
                
                LCD_putc(1, '-');       // Put a minus sign in front of the temperature
            }
            else if (ADCresult < 800)   // If it's a positive temperature
            {
                for (i=0; i<100; i++)  
    156e:	1f 5f       	subi	r17, 0xFF	; 255
    1570:	2e 5f       	subi	r18, 0xFE	; 254
    1572:	3f 4f       	sbci	r19, 0xFF	; 255
    1574:	14 36       	cpi	r17, 0x64	; 100
    1576:	a9 f7       	brne	.-22     	; 0x1562 <ADC_periphery+0x66>
                    {
                        break;
                    }
                }        
            
                LCD_putc(1, '+');       // Put a plus sign in front of the temperature
    1578:	81 e0       	ldi	r24, 0x01	; 1
    157a:	6b e2       	ldi	r22, 0x2B	; 43
    157c:	fe d7       	rcall	.+4092   	; 0x257a <LCD_putc>
    157e:	04 c0       	rjmp	.+8      	; 0x1588 <ADC_periphery+0x8c>
            }
            else                        //If the temperature is zero degrees
            {
                i = 0;
                LCD_putc(1, ' ');
    1580:	81 e0       	ldi	r24, 0x01	; 1
    1582:	60 e2       	ldi	r22, 0x20	; 32
    1584:	fa d7       	rcall	.+4084   	; 0x257a <LCD_putc>
    1586:	10 e0       	ldi	r17, 0x00	; 0
            }
            
            Temp = CHAR2BCD2(i);        // Convert from char to bin
    1588:	81 2f       	mov	r24, r17
    158a:	d2 de       	rcall	.-604    	; 0x1330 <CHAR2BCD2>
    158c:	18 2f       	mov	r17, r24
    
            TL = (Temp & 0x0F) + '0';   // Find the low-byte
            TH = (Temp >> 4) + '0';     // Find the high-byte
            
            LCD_putc(0, ' ');
    158e:	80 e0       	ldi	r24, 0x00	; 0
    1590:	60 e2       	ldi	r22, 0x20	; 32
    1592:	f3 d7       	rcall	.+4070   	; 0x257a <LCD_putc>
            //LCD character 1 is allready written to
            LCD_putc(2, TH);
    1594:	61 2f       	mov	r22, r17
    1596:	62 95       	swap	r22
    1598:	6f 70       	andi	r22, 0x0F	; 15
    159a:	60 5d       	subi	r22, 0xD0	; 208
    159c:	82 e0       	ldi	r24, 0x02	; 2
    159e:	ed d7       	rcall	.+4058   	; 0x257a <LCD_putc>
            LCD_putc(3, TL);
    15a0:	1f 70       	andi	r17, 0x0F	; 15
    15a2:	10 5d       	subi	r17, 0xD0	; 208
    15a4:	83 e0       	ldi	r24, 0x03	; 3
    15a6:	61 2f       	mov	r22, r17
    15a8:	e8 d7       	rcall	.+4048   	; 0x257a <LCD_putc>
            LCD_putc(4, '*');
    15aa:	84 e0       	ldi	r24, 0x04	; 4
    15ac:	6a e2       	ldi	r22, 0x2A	; 42
    15ae:	e5 d7       	rcall	.+4042   	; 0x257a <LCD_putc>
            LCD_putc(5, 'C');
    15b0:	85 e0       	ldi	r24, 0x05	; 5
    15b2:	63 e4       	ldi	r22, 0x43	; 67
    15b4:	0a c1       	rjmp	.+532    	; 0x17ca <ADC_periphery+0x2ce>
            LCD_putc(6, '\0');
        }
        else if (degree == FAHRENHEIT)
    15b6:	84 30       	cpi	r24, 0x04	; 4
    15b8:	09 f0       	breq	.+2      	; 0x15bc <ADC_periphery+0xc0>
    15ba:	0b c1       	rjmp	.+534    	; 0x17d2 <ADC_periphery+0x2d6>
    15bc:	2f e7       	ldi	r18, 0x7F	; 127
    15be:	33 e0       	ldi	r19, 0x03	; 3
    15c0:	10 e0       	ldi	r17, 0x00	; 0
        {
            for (i=0; i<=141; i++)   // Find the temperature
            {
                // mt if (ADCresult > TEMP_Farenheit_pos[i])
                if (ADCresult > (int)pgm_read_word(&TEMP_Fahrenheit_pos[i]))
    15c2:	f9 01       	movw	r30, r18
    15c4:	85 91       	lpm	r24, Z+
    15c6:	94 91       	lpm	r25, Z+
    15c8:	8c 17       	cp	r24, r28
    15ca:	9d 07       	cpc	r25, r29
    15cc:	2c f0       	brlt	.+10     	; 0x15d8 <ADC_periphery+0xdc>
            LCD_putc(5, 'C');
            LCD_putc(6, '\0');
        }
        else if (degree == FAHRENHEIT)
        {
            for (i=0; i<=141; i++)   // Find the temperature
    15ce:	1f 5f       	subi	r17, 0xFF	; 255
    15d0:	2e 5f       	subi	r18, 0xFE	; 254
    15d2:	3f 4f       	sbci	r19, 0xFF	; 255
    15d4:	1e 38       	cpi	r17, 0x8E	; 142
    15d6:	a9 f7       	brne	.-22     	; 0x15c2 <ADC_periphery+0xc6>
                {
                    break;
                }
            }        
        
            Temp_int = CHAR2BCD3(i);
    15d8:	81 2f       	mov	r24, r17
    15da:	b5 de       	rcall	.-662    	; 0x1346 <CHAR2BCD3>
    15dc:	ec 01       	movw	r28, r24
        
            if (i > 99) // if there are three digits
    15de:	14 36       	cpi	r17, 0x64	; 100
    15e0:	50 f0       	brcs	.+20     	; 0x15f6 <ADC_periphery+0xfa>
            {
                LCD_putc(0, '+');
    15e2:	80 e0       	ldi	r24, 0x00	; 0
    15e4:	6b e2       	ldi	r22, 0x2B	; 43
    15e6:	c9 d7       	rcall	.+3986   	; 0x257a <LCD_putc>
                TH = (Temp_int >> 8) + '0';   // Find the high-byte
                LCD_putc(1, TH);
    15e8:	6d 2f       	mov	r22, r29
    15ea:	77 27       	eor	r23, r23
    15ec:	67 fd       	sbrc	r22, 7
    15ee:	7a 95       	dec	r23
    15f0:	60 5d       	subi	r22, 0xD0	; 208
    15f2:	81 e0       	ldi	r24, 0x01	; 1
    15f4:	05 c0       	rjmp	.+10     	; 0x1600 <ADC_periphery+0x104>
            }
            else    // if only two digits
            {
                LCD_putc(0, ' ');
    15f6:	80 e0       	ldi	r24, 0x00	; 0
    15f8:	60 e2       	ldi	r22, 0x20	; 32
    15fa:	bf d7       	rcall	.+3966   	; 0x257a <LCD_putc>
                LCD_putc(1, '+');
    15fc:	81 e0       	ldi	r24, 0x01	; 1
    15fe:	6b e2       	ldi	r22, 0x2B	; 43
    1600:	bc d7       	rcall	.+3960   	; 0x257a <LCD_putc>
            }
            
            TL = (Temp_int & 0x0F) + '0';   // Find the low-byte
            TH = ( (Temp_int >> 4) & 0x0F ) + '0';     // Find the high-byte                

            LCD_putc(2, TH);
    1602:	be 01       	movw	r22, r28
    1604:	e4 e0       	ldi	r30, 0x04	; 4
    1606:	75 95       	asr	r23
    1608:	67 95       	ror	r22
    160a:	ea 95       	dec	r30
    160c:	e1 f7       	brne	.-8      	; 0x1606 <ADC_periphery+0x10a>
    160e:	6f 70       	andi	r22, 0x0F	; 15
    1610:	60 5d       	subi	r22, 0xD0	; 208
    1612:	82 e0       	ldi	r24, 0x02	; 2
    1614:	b2 d7       	rcall	.+3940   	; 0x257a <LCD_putc>
            LCD_putc(3, TL);
    1616:	ce 01       	movw	r24, r28
    1618:	8f 70       	andi	r24, 0x0F	; 15
    161a:	68 2f       	mov	r22, r24
    161c:	60 5d       	subi	r22, 0xD0	; 208
    161e:	83 e0       	ldi	r24, 0x03	; 3
    1620:	ac d7       	rcall	.+3928   	; 0x257a <LCD_putc>
            LCD_putc(4, '*');
    1622:	84 e0       	ldi	r24, 0x04	; 4
    1624:	6a e2       	ldi	r22, 0x2A	; 42
    1626:	a9 d7       	rcall	.+3922   	; 0x257a <LCD_putc>
            LCD_putc(5, 'F');
    1628:	85 e0       	ldi	r24, 0x05	; 5
    162a:	66 e4       	ldi	r22, 0x46	; 70
    162c:	ce c0       	rjmp	.+412    	; 0x17ca <ADC_periphery+0x2ce>

//        Can't set LCD_UpdateRequired = TRUE here cause we are inside the Timer0 interrupt
//        LCD_UpdateRequired(TRUE, 0);        

    }
    else if( ADMUX == VOLTAGE_SENSOR )
    162e:	80 91 7c 00 	lds	r24, 0x007C
    1632:	81 30       	cpi	r24, 0x01	; 1
    1634:	09 f0       	breq	.+2      	; 0x1638 <ADC_periphery+0x13c>
    1636:	9e c0       	rjmp	.+316    	; 0x1774 <ADC_periphery+0x278>
        //  Do a Light-measurement first to determine the Vref, 
        //  because the LDR affects the Vref 

        ADCresult_temp = ADCresult;     // Store the ADCresult from the voltage reading
          
        ADC_init(LIGHT_SENSOR);         // Init the ADC to measure light
    1638:	82 e0       	ldi	r24, 0x02	; 2
    163a:	e9 de       	rcall	.-558    	; 0x140e <ADC_init>
            
        ADCresult = ADC_read();         // Read the light value
    163c:	b0 de       	rcall	.-672    	; 0x139e <ADC_read>
    163e:	bc 01       	movw	r22, r24
    1640:	29 e9       	ldi	r18, 0x99	; 153
    1642:	34 e0       	ldi	r19, 0x04	; 4
    1644:	40 e0       	ldi	r20, 0x00	; 0

        // Find Vref
        for (i=0; i<=22; i++)
        {
            // mt if (ADCresult <= LIGHT_ADC[i])
            if (ADCresult <= (int)pgm_read_word(&LIGHT_ADC[i]))
    1646:	f9 01       	movw	r30, r18
    1648:	85 91       	lpm	r24, Z+
    164a:	94 91       	lpm	r25, Z+
    164c:	86 17       	cp	r24, r22
    164e:	97 07       	cpc	r25, r23
    1650:	34 f4       	brge	.+12     	; 0x165e <ADC_periphery+0x162>
        ADC_init(LIGHT_SENSOR);         // Init the ADC to measure light
            
        ADCresult = ADC_read();         // Read the light value

        // Find Vref
        for (i=0; i<=22; i++)
    1652:	4f 5f       	subi	r20, 0xFF	; 255
    1654:	2e 5f       	subi	r18, 0xFE	; 254
    1656:	3f 4f       	sbci	r19, 0xFF	; 255
    1658:	47 31       	cpi	r20, 0x17	; 23
    165a:	a9 f7       	brne	.-22     	; 0x1646 <ADC_periphery+0x14a>
    165c:	09 c0       	rjmp	.+18     	; 0x1670 <ADC_periphery+0x174>
            if (ADCresult <= (int)pgm_read_word(&LIGHT_ADC[i]))
            {
                break;
            }
        }
        if(!i)              // if it's very bright
    165e:	44 23       	and	r20, r20
    1660:	29 f4       	brne	.+10     	; 0x166c <ADC_periphery+0x170>
            Vref = 2.815;
    1662:	86 ef       	ldi	r24, 0xF6	; 246
    1664:	98 e2       	ldi	r25, 0x28	; 40
    1666:	a4 e3       	ldi	r26, 0x34	; 52
    1668:	b0 e4       	ldi	r27, 0x40	; 64
    166a:	06 c0       	rjmp	.+12     	; 0x1678 <ADC_periphery+0x17c>
        else if(i >= 21)
    166c:	45 31       	cpi	r20, 0x15	; 21
    166e:	68 f0       	brcs	.+26     	; 0x168a <ADC_periphery+0x18e>
            Vref = 2.942;   // if it's totally dark
    1670:	8a eb       	ldi	r24, 0xBA	; 186
    1672:	99 e4       	ldi	r25, 0x49	; 73
    1674:	ac e3       	ldi	r26, 0x3C	; 60
    1676:	b0 e4       	ldi	r27, 0x40	; 64
    1678:	80 93 1e 01 	sts	0x011E, r24
    167c:	90 93 1f 01 	sts	0x011F, r25
    1680:	a0 93 20 01 	sts	0x0120, r26
    1684:	b0 93 21 01 	sts	0x0121, r27
    1688:	18 c0       	rjmp	.+48     	; 0x16ba <ADC_periphery+0x1be>
        else {
            // mt: Vref = LIGHT_VOLTAGE[i];   
            // mt using helper from pgmspacehlp.h - new code
            Vref = pgm_read_float_hlp(&LIGHT_VOLTAGE[i]);
    168a:	84 2f       	mov	r24, r20
    168c:	90 e0       	ldi	r25, 0x00	; 0
    168e:	88 0f       	add	r24, r24
    1690:	99 1f       	adc	r25, r25
    1692:	88 0f       	add	r24, r24
    1694:	99 1f       	adc	r25, r25
    1696:	8d 53       	subi	r24, 0x3D	; 61
    1698:	9b 4f       	sbci	r25, 0xFB	; 251
	{
		uint16_t i[2];
		float f;
	} u;
	
	u.i[0]=pgm_read_word((PGM_P)addr);
    169a:	fc 01       	movw	r30, r24
    169c:	65 91       	lpm	r22, Z+
    169e:	74 91       	lpm	r23, Z+
    16a0:	9b 01       	movw	r18, r22
	u.i[1]=pgm_read_word((PGM_P)addr+2);
    16a2:	fc 01       	movw	r30, r24
    16a4:	32 96       	adiw	r30, 0x02	; 2
    16a6:	45 91       	lpm	r20, Z+
    16a8:	54 91       	lpm	r21, Z+
    16aa:	20 93 1e 01 	sts	0x011E, r18
    16ae:	30 93 1f 01 	sts	0x011F, r19
    16b2:	40 93 20 01 	sts	0x0120, r20
    16b6:	50 93 21 01 	sts	0x0121, r21
        }
          
        ADMUX = VOLTAGE_SENSOR;     
    16ba:	81 e0       	ldi	r24, 0x01	; 1
    16bc:	80 93 7c 00 	sts	0x007C, r24
        ADCresult = ADCresult_temp; // Get the ADCresult from the voltage reading

        // Light-measurement finished

        V_ADC = ( ADCresult * Vref ) / 1024; // Calculate the voltage
    16c0:	be 01       	movw	r22, r28
    16c2:	88 27       	eor	r24, r24
    16c4:	77 fd       	sbrc	r23, 7
    16c6:	80 95       	com	r24
    16c8:	98 2f       	mov	r25, r24
    16ca:	0e 94 44 18 	call	0x3088	; 0x3088 <__floatsisf>
    16ce:	20 91 1e 01 	lds	r18, 0x011E
    16d2:	30 91 1f 01 	lds	r19, 0x011F
    16d6:	40 91 20 01 	lds	r20, 0x0120
    16da:	50 91 21 01 	lds	r21, 0x0121
    16de:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <__mulsf3>
    16e2:	20 e0       	ldi	r18, 0x00	; 0
    16e4:	30 e0       	ldi	r19, 0x00	; 0
    16e6:	40 e8       	ldi	r20, 0x80	; 128
    16e8:	5a e3       	ldi	r21, 0x3A	; 58
    16ea:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <__mulsf3>
           
        V_ADC = ( V_ADC * 6 );      // Multiply by 6 cause of the voltage division
    16ee:	20 e0       	ldi	r18, 0x00	; 0
    16f0:	30 e0       	ldi	r19, 0x00	; 0
    16f2:	40 ec       	ldi	r20, 0xC0	; 192
    16f4:	50 e4       	ldi	r21, 0x40	; 64
    16f6:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <__mulsf3>
    16fa:	5b 01       	movw	r10, r22
    16fc:	6c 01       	movw	r12, r24
            
        VoltageHB = V_ADC;              // Store the high-byte
    16fe:	0e 94 16 18 	call	0x302c	; 0x302c <__fixunssfsi>
    1702:	dc 01       	movw	r26, r24
    1704:	cb 01       	movw	r24, r22
    1706:	e8 2e       	mov	r14, r24
        V_ADC = ( V_ADC - VoltageHB );
        VoltageLB = ( V_ADC * 100 );    // Store the low-byte
     
        Temp = CHAR2BCD2(VoltageHB);    // Convert from char to bin
    1708:	13 de       	rcall	.-986    	; 0x1330 <CHAR2BCD2>
    170a:	98 2e       	mov	r9, r24
    
        TL = (Temp & 0x0F) + '0';
        TH = (Temp >> 4) + '0';
            
        Temp = CHAR2BCD2(VoltageLB);    // Convert from char to bin
    170c:	ff 24       	eor	r15, r15
    170e:	00 27       	eor	r16, r16
    1710:	f7 fc       	sbrc	r15, 7
    1712:	00 95       	com	r16
    1714:	10 2f       	mov	r17, r16
    1716:	c8 01       	movw	r24, r16
    1718:	b7 01       	movw	r22, r14
    171a:	0e 94 44 18 	call	0x3088	; 0x3088 <__floatsisf>
    171e:	9b 01       	movw	r18, r22
    1720:	ac 01       	movw	r20, r24
    1722:	c6 01       	movw	r24, r12
    1724:	b5 01       	movw	r22, r10
    1726:	0e 94 44 17 	call	0x2e88	; 0x2e88 <__subsf3>
    172a:	20 e0       	ldi	r18, 0x00	; 0
    172c:	30 e0       	ldi	r19, 0x00	; 0
    172e:	48 ec       	ldi	r20, 0xC8	; 200
    1730:	52 e4       	ldi	r21, 0x42	; 66
    1732:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <__mulsf3>
    1736:	0e 94 16 18 	call	0x302c	; 0x302c <__fixunssfsi>
    173a:	dc 01       	movw	r26, r24
    173c:	cb 01       	movw	r24, r22
    173e:	f8 dd       	rcall	.-1040   	; 0x1330 <CHAR2BCD2>
    1740:	18 2f       	mov	r17, r24
   
        VL = (Temp >> 4) + '0';

        LCD_putc(0, ' ');
    1742:	80 e0       	ldi	r24, 0x00	; 0
    1744:	60 e2       	ldi	r22, 0x20	; 32
    1746:	19 d7       	rcall	.+3634   	; 0x257a <LCD_putc>
        LCD_putc(1, ' ');
    1748:	81 e0       	ldi	r24, 0x01	; 1
    174a:	60 e2       	ldi	r22, 0x20	; 32
    174c:	16 d7       	rcall	.+3628   	; 0x257a <LCD_putc>
        LCD_putc(2, ' ');
    174e:	82 e0       	ldi	r24, 0x02	; 2
    1750:	60 e2       	ldi	r22, 0x20	; 32
    1752:	13 d7       	rcall	.+3622   	; 0x257a <LCD_putc>
        LCD_putc(3, TL);
    1754:	9f e0       	ldi	r25, 0x0F	; 15
    1756:	99 22       	and	r9, r25
    1758:	80 e3       	ldi	r24, 0x30	; 48
    175a:	98 0e       	add	r9, r24
    175c:	83 e0       	ldi	r24, 0x03	; 3
    175e:	69 2d       	mov	r22, r9
    1760:	0c d7       	rcall	.+3608   	; 0x257a <LCD_putc>
        LCD_putc(4, 'V');
    1762:	84 e0       	ldi	r24, 0x04	; 4
    1764:	66 e5       	ldi	r22, 0x56	; 86
    1766:	09 d7       	rcall	.+3602   	; 0x257a <LCD_putc>
        LCD_putc(5, VL);
    1768:	12 95       	swap	r17
    176a:	1f 70       	andi	r17, 0x0F	; 15
    176c:	10 5d       	subi	r17, 0xD0	; 208
    176e:	85 e0       	ldi	r24, 0x05	; 5
    1770:	61 2f       	mov	r22, r17
    1772:	2b c0       	rjmp	.+86     	; 0x17ca <ADC_periphery+0x2ce>
        
//        Can't set LCD_UpdateRequired = TRUE here cause we are inside the Timer0 interrupt
//        LCD_UpdateRequired(TRUE, 0);
                             
    }
    else if( ADMUX == LIGHT_SENSOR )
    1774:	80 91 7c 00 	lds	r24, 0x007C
    1778:	82 30       	cpi	r24, 0x02	; 2
    177a:	59 f5       	brne	.+86     	; 0x17d2 <ADC_periphery+0x2d6>
    {
        // The relation between ADC-value and lux is yet to be found, 
        // for now the ADC-value is presented on the LCD
        
        VoltageHB = CHAR2BCD2(ADCH);    // Convert from char to bin
    177c:	80 91 79 00 	lds	r24, 0x0079
    1780:	d7 dd       	rcall	.-1106   	; 0x1330 <CHAR2BCD2>

        Temp = ADCL;                
    1782:	90 91 78 00 	lds	r25, 0x0078
    
        TL = (Temp & 0x0F) + '0';       
    1786:	89 2f       	mov	r24, r25
    1788:	8f 70       	andi	r24, 0x0F	; 15
    178a:	08 2f       	mov	r16, r24
    178c:	00 5d       	subi	r16, 0xD0	; 208
        if(TL > '9')        // if the hex-value is over 9, add 7 in order to go 
    178e:	0a 33       	cpi	r16, 0x3A	; 58
    1790:	08 f0       	brcs	.+2      	; 0x1794 <ADC_periphery+0x298>
            TL += 7;        // jump to the character in the ASCII-table
    1792:	09 5f       	subi	r16, 0xF9	; 249
                
        TH = (Temp >> 4) + '0';
    1794:	89 2f       	mov	r24, r25
    1796:	82 95       	swap	r24
    1798:	8f 70       	andi	r24, 0x0F	; 15
    179a:	18 2f       	mov	r17, r24
    179c:	10 5d       	subi	r17, 0xD0	; 208
        if(TH > '9')        // if the hex-value is over 9, add 7 in order to go 
    179e:	1a 33       	cpi	r17, 0x3A	; 58
    17a0:	08 f0       	brcs	.+2      	; 0x17a4 <ADC_periphery+0x2a8>
            TH += 7;        // jump to the character in the ASCII-table
    17a2:	19 5f       	subi	r17, 0xF9	; 249
            
        LCD_putc(0, 'A');
    17a4:	80 e0       	ldi	r24, 0x00	; 0
    17a6:	61 e4       	ldi	r22, 0x41	; 65
    17a8:	e8 d6       	rcall	.+3536   	; 0x257a <LCD_putc>
        LCD_putc(1, 'D');
    17aa:	81 e0       	ldi	r24, 0x01	; 1
    17ac:	64 e4       	ldi	r22, 0x44	; 68
    17ae:	e5 d6       	rcall	.+3530   	; 0x257a <LCD_putc>
        LCD_putc(2, 'C');
    17b0:	82 e0       	ldi	r24, 0x02	; 2
    17b2:	63 e4       	ldi	r22, 0x43	; 67
    17b4:	e2 d6       	rcall	.+3524   	; 0x257a <LCD_putc>
        LCD_putc(3, (ADCH + 0x30));
    17b6:	60 91 79 00 	lds	r22, 0x0079
    17ba:	60 5d       	subi	r22, 0xD0	; 208
    17bc:	83 e0       	ldi	r24, 0x03	; 3
    17be:	dd d6       	rcall	.+3514   	; 0x257a <LCD_putc>
        LCD_putc(4, TH);
    17c0:	84 e0       	ldi	r24, 0x04	; 4
    17c2:	61 2f       	mov	r22, r17
    17c4:	da d6       	rcall	.+3508   	; 0x257a <LCD_putc>
        LCD_putc(5, TL);
    17c6:	85 e0       	ldi	r24, 0x05	; 5
    17c8:	60 2f       	mov	r22, r16
    17ca:	d7 d6       	rcall	.+3502   	; 0x257a <LCD_putc>
        LCD_putc(6, '\0');
    17cc:	86 e0       	ldi	r24, 0x06	; 6
    17ce:	60 e0       	ldi	r22, 0x00	; 0
    17d0:	d4 d6       	rcall	.+3496   	; 0x257a <LCD_putc>

//        Can't set LCD_UpdateRequired = TRUE here cause we are inside the Timer0 interrupt
//        LCD_UpdateRequired(TRUE, 0);        

    }
}
    17d2:	df 91       	pop	r29
    17d4:	cf 91       	pop	r28
    17d6:	1f 91       	pop	r17
    17d8:	0f 91       	pop	r16
    17da:	ff 90       	pop	r15
    17dc:	ef 90       	pop	r14
    17de:	df 90       	pop	r13
    17e0:	cf 90       	pop	r12
    17e2:	bf 90       	pop	r11
    17e4:	af 90       	pop	r10
    17e6:	9f 90       	pop	r9
    17e8:	08 95       	ret

000017ea <__vector_5>:
// #pragma vector = TIMER2_OVF_vect
// __interrupt void TIMER2_OVF_interrupt(void)
// SIGNAL(SIG_OVERFLOW2)
ISR(TIMER2_OVF_vect)
// mtE
{
    17ea:	1f 92       	push	r1
    17ec:	0f 92       	push	r0
    17ee:	0f b6       	in	r0, 0x3f	; 63
    17f0:	0f 92       	push	r0
    17f2:	11 24       	eor	r1, r1
    17f4:	2f 93       	push	r18
    17f6:	3f 93       	push	r19
    17f8:	4f 93       	push	r20
    17fa:	5f 93       	push	r21
    17fc:	6f 93       	push	r22
    17fe:	7f 93       	push	r23
    1800:	8f 93       	push	r24
    1802:	9f 93       	push	r25
    1804:	af 93       	push	r26
    1806:	bf 93       	push	r27
    1808:	ef 93       	push	r30
    180a:	ff 93       	push	r31
    static char LeapMonth;

    gSECOND++;               // increment second
    180c:	80 91 92 01 	lds	r24, 0x0192
    1810:	8f 5f       	subi	r24, 0xFF	; 255
    1812:	80 93 92 01 	sts	0x0192, r24

    if (gSECOND == 60)
    1816:	80 91 92 01 	lds	r24, 0x0192
    181a:	8c 33       	cpi	r24, 0x3C	; 60
    181c:	09 f0       	breq	.+2      	; 0x1820 <__vector_5+0x36>
    181e:	72 c0       	rjmp	.+228    	; 0x1904 <__vector_5+0x11a>
    {
        gSECOND = 0;
    1820:	10 92 92 01 	sts	0x0192, r1
        gMINUTE++;
    1824:	80 91 97 01 	lds	r24, 0x0197
    1828:	8f 5f       	subi	r24, 0xFF	; 255
    182a:	80 93 97 01 	sts	0x0197, r24
        
        gPowerSaveTimer++;
    182e:	80 91 64 01 	lds	r24, 0x0164
    1832:	8f 5f       	subi	r24, 0xFF	; 255
    1834:	80 93 64 01 	sts	0x0164, r24
        
        if (gMINUTE > 59)
    1838:	80 91 97 01 	lds	r24, 0x0197
    183c:	8c 33       	cpi	r24, 0x3C	; 60
    183e:	08 f4       	brcc	.+2      	; 0x1842 <__vector_5+0x58>
    1840:	61 c0       	rjmp	.+194    	; 0x1904 <__vector_5+0x11a>
        {
            gMINUTE = 0;
    1842:	10 92 97 01 	sts	0x0197, r1
            gHOUR++;
    1846:	80 91 91 01 	lds	r24, 0x0191
    184a:	8f 5f       	subi	r24, 0xFF	; 255
    184c:	80 93 91 01 	sts	0x0191, r24
            
            if (gHOUR > 23)
    1850:	80 91 91 01 	lds	r24, 0x0191
    1854:	88 31       	cpi	r24, 0x18	; 24
    1856:	08 f4       	brcc	.+2      	; 0x185a <__vector_5+0x70>
    1858:	55 c0       	rjmp	.+170    	; 0x1904 <__vector_5+0x11a>
            {
                
                gHOUR = 0;
    185a:	10 92 91 01 	sts	0x0191, r1
                gDAY++;
    185e:	80 91 93 01 	lds	r24, 0x0193
    1862:	8f 5f       	subi	r24, 0xFF	; 255
    1864:	80 93 93 01 	sts	0x0193, r24

                // Check for leap year if month == February
                if (gMONTH == 2)
    1868:	80 91 96 01 	lds	r24, 0x0196
    186c:	82 30       	cpi	r24, 0x02	; 2
    186e:	01 f5       	brne	.+64     	; 0x18b0 <__vector_5+0xc6>
                    if (!(gYEAR & 0x0003))              // if (gYEAR%4 == 0)
    1870:	80 91 94 01 	lds	r24, 0x0194
    1874:	90 91 95 01 	lds	r25, 0x0195
    1878:	83 70       	andi	r24, 0x03	; 3
    187a:	90 70       	andi	r25, 0x00	; 0
    187c:	89 2b       	or	r24, r25
    187e:	c1 f4       	brne	.+48     	; 0x18b0 <__vector_5+0xc6>
                        if (gYEAR%100 == 0)
    1880:	80 91 94 01 	lds	r24, 0x0194
    1884:	90 91 95 01 	lds	r25, 0x0195
    1888:	64 e6       	ldi	r22, 0x64	; 100
    188a:	70 e0       	ldi	r23, 0x00	; 0
    188c:	0e 94 33 19 	call	0x3266	; 0x3266 <__udivmodhi4>
    1890:	89 2b       	or	r24, r25
    1892:	51 f4       	brne	.+20     	; 0x18a8 <__vector_5+0xbe>
                            if (gYEAR%400 == 0)
    1894:	80 91 94 01 	lds	r24, 0x0194
    1898:	90 91 95 01 	lds	r25, 0x0195
    189c:	60 e9       	ldi	r22, 0x90	; 144
    189e:	71 e0       	ldi	r23, 0x01	; 1
    18a0:	0e 94 33 19 	call	0x3266	; 0x3266 <__udivmodhi4>
    18a4:	89 2b       	or	r24, r25
    18a6:	21 f4       	brne	.+8      	; 0x18b0 <__vector_5+0xc6>
                                LeapMonth = 1;
                            else
                                LeapMonth = 0;
                        else
                            LeapMonth = 1;
    18a8:	81 e0       	ldi	r24, 0x01	; 1
    18aa:	80 93 66 01 	sts	0x0166, r24
    18ae:	02 c0       	rjmp	.+4      	; 0x18b4 <__vector_5+0xca>
                    else
                        LeapMonth = 0;
                else
                    LeapMonth = 0;
    18b0:	10 92 66 01 	sts	0x0166, r1

                // Now, we can check for month length
                if (gDAY > (MonthLength[gMONTH] + LeapMonth))
    18b4:	20 91 93 01 	lds	r18, 0x0193
    18b8:	e0 91 96 01 	lds	r30, 0x0196
    18bc:	30 e0       	ldi	r19, 0x00	; 0
    18be:	f0 e0       	ldi	r31, 0x00	; 0
    18c0:	ea 5d       	subi	r30, 0xDA	; 218
    18c2:	fe 4f       	sbci	r31, 0xFE	; 254
    18c4:	40 81       	ld	r20, Z
    18c6:	80 91 66 01 	lds	r24, 0x0166
    18ca:	90 e0       	ldi	r25, 0x00	; 0
    18cc:	84 0f       	add	r24, r20
    18ce:	91 1d       	adc	r25, r1
    18d0:	82 17       	cp	r24, r18
    18d2:	93 07       	cpc	r25, r19
    18d4:	bc f4       	brge	.+46     	; 0x1904 <__vector_5+0x11a>
                {
                    gDAY = 1;
    18d6:	91 e0       	ldi	r25, 0x01	; 1
    18d8:	90 93 93 01 	sts	0x0193, r25
                    gMONTH++;
    18dc:	80 91 96 01 	lds	r24, 0x0196
    18e0:	8f 5f       	subi	r24, 0xFF	; 255
    18e2:	80 93 96 01 	sts	0x0196, r24

                    if (gMONTH > 12)
    18e6:	80 91 96 01 	lds	r24, 0x0196
    18ea:	8d 30       	cpi	r24, 0x0D	; 13
    18ec:	58 f0       	brcs	.+22     	; 0x1904 <__vector_5+0x11a>
                    {
                        gMONTH = 1;
    18ee:	90 93 96 01 	sts	0x0196, r25
                        gYEAR++;
    18f2:	80 91 94 01 	lds	r24, 0x0194
    18f6:	90 91 95 01 	lds	r25, 0x0195
    18fa:	01 96       	adiw	r24, 0x01	; 1
    18fc:	90 93 95 01 	sts	0x0195, r25
    1900:	80 93 94 01 	sts	0x0194, r24
                    }
                }
            }
        }
    }
}
    1904:	ff 91       	pop	r31
    1906:	ef 91       	pop	r30
    1908:	bf 91       	pop	r27
    190a:	af 91       	pop	r26
    190c:	9f 91       	pop	r25
    190e:	8f 91       	pop	r24
    1910:	7f 91       	pop	r23
    1912:	6f 91       	pop	r22
    1914:	5f 91       	pop	r21
    1916:	4f 91       	pop	r20
    1918:	3f 91       	pop	r19
    191a:	2f 91       	pop	r18
    191c:	0f 90       	pop	r0
    191e:	0f be       	out	0x3f, r0	; 63
    1920:	0f 90       	pop	r0
    1922:	1f 90       	pop	r1
    1924:	18 95       	reti

00001926 <SetDateFormat>:
*
*   Purpose :       Adjusts the Dateformat
*
*****************************************************************************/
char SetDateFormat(char input)
{
    1926:	1f 93       	push	r17
    1928:	18 2f       	mov	r17, r24
    static char enter = 1;

    if(enter)
    192a:	80 91 52 01 	lds	r24, 0x0152
    192e:	88 23       	and	r24, r24
    1930:	69 f0       	breq	.+26     	; 0x194c <SetDateFormat+0x26>
    {
        enter = 0;
    1932:	10 92 52 01 	sts	0x0152, r1

        LCD_puts_f(DATEFORMAT_TEXT[dateformat], 1);
    1936:	e0 91 65 01 	lds	r30, 0x0165
    193a:	f0 e0       	ldi	r31, 0x00	; 0
    193c:	ee 0f       	add	r30, r30
    193e:	ff 1f       	adc	r31, r31
    1940:	e4 5b       	subi	r30, 0xB4	; 180
    1942:	fe 4f       	sbci	r31, 0xFE	; 254
    1944:	80 81       	ld	r24, Z
    1946:	91 81       	ldd	r25, Z+1	; 0x01
    1948:	61 e0       	ldi	r22, 0x01	; 1
    194a:	b7 d5       	rcall	.+2926   	; 0x24ba <LCD_puts_f>
    }
    if (input == KEY_PLUS)
    194c:	14 30       	cpi	r17, 0x04	; 4
    194e:	49 f4       	brne	.+18     	; 0x1962 <SetDateFormat+0x3c>
    {
        if(dateformat >= 2)
    1950:	80 91 65 01 	lds	r24, 0x0165
    1954:	82 30       	cpi	r24, 0x02	; 2
    1956:	18 f0       	brcs	.+6      	; 0x195e <SetDateFormat+0x38>
            dateformat = 0;
    1958:	10 92 65 01 	sts	0x0165, r1
    195c:	0d c0       	rjmp	.+26     	; 0x1978 <SetDateFormat+0x52>
        else
            dateformat++;
    195e:	8f 5f       	subi	r24, 0xFF	; 255
    1960:	09 c0       	rjmp	.+18     	; 0x1974 <SetDateFormat+0x4e>

        LCD_puts_f(DATEFORMAT_TEXT[dateformat], 1);        
    }
    else if (input == KEY_MINUS)
    1962:	15 30       	cpi	r17, 0x05	; 5
    1964:	a9 f4       	brne	.+42     	; 0x1990 <SetDateFormat+0x6a>
    {
        if(dateformat == 0)
    1966:	80 91 65 01 	lds	r24, 0x0165
    196a:	88 23       	and	r24, r24
    196c:	11 f4       	brne	.+4      	; 0x1972 <SetDateFormat+0x4c>
            dateformat = 2;
    196e:	82 e0       	ldi	r24, 0x02	; 2
    1970:	01 c0       	rjmp	.+2      	; 0x1974 <SetDateFormat+0x4e>
        else
            dateformat--;
    1972:	81 50       	subi	r24, 0x01	; 1
    1974:	80 93 65 01 	sts	0x0165, r24
            
        LCD_puts_f(DATEFORMAT_TEXT[dateformat], 1);            
    1978:	e0 91 65 01 	lds	r30, 0x0165
    197c:	f0 e0       	ldi	r31, 0x00	; 0
    197e:	ee 0f       	add	r30, r30
    1980:	ff 1f       	adc	r31, r31
    1982:	e4 5b       	subi	r30, 0xB4	; 180
    1984:	fe 4f       	sbci	r31, 0xFE	; 254
    1986:	80 81       	ld	r24, Z
    1988:	91 81       	ldd	r25, Z+1	; 0x01
    198a:	61 e0       	ldi	r22, 0x01	; 1
    198c:	96 d5       	rcall	.+2860   	; 0x24ba <LCD_puts_f>
    198e:	02 c0       	rjmp	.+4      	; 0x1994 <SetDateFormat+0x6e>
    }
    else if (input == KEY_ENTER)    
    1990:	11 30       	cpi	r17, 0x01	; 1
    1992:	11 f0       	breq	.+4      	; 0x1998 <SetDateFormat+0x72>
    1994:	80 e2       	ldi	r24, 0x20	; 32
    1996:	03 c0       	rjmp	.+6      	; 0x199e <SetDateFormat+0x78>
    {
        enter = 1;
    1998:	10 93 52 01 	sts	0x0152, r17
    199c:	8c e1       	ldi	r24, 0x1C	; 28
        return ST_TIME_DATE_FUNC;
    }        
    return ST_TIME_DATEFORMAT_ADJUST_FUNC;
}
    199e:	1f 91       	pop	r17
    19a0:	08 95       	ret

000019a2 <SetClockFormat>:
*
*   Purpose :       Adjusts the Clockformat
*
*****************************************************************************/
char SetClockFormat(char input)
{
    19a2:	1f 93       	push	r17
    19a4:	18 2f       	mov	r17, r24
    static char enter = 1;
    
    if(enter)
    19a6:	80 91 55 01 	lds	r24, 0x0155
    19aa:	88 23       	and	r24, r24
    19ac:	69 f0       	breq	.+26     	; 0x19c8 <SetClockFormat+0x26>
    {
        enter = 0;
    19ae:	10 92 55 01 	sts	0x0155, r1
        
        if(clockformat == CLOCK_24)
    19b2:	80 91 4b 01 	lds	r24, 0x014B
    19b6:	81 30       	cpi	r24, 0x01	; 1
    19b8:	19 f4       	brne	.+6      	; 0x19c0 <SetClockFormat+0x1e>
            LCD_puts_f(PSTR("24H"), 1);	 // mt LCD_puts("24H", 1);            
    19ba:	88 e5       	ldi	r24, 0x58	; 88
    19bc:	95 e0       	ldi	r25, 0x05	; 5
    19be:	02 c0       	rjmp	.+4      	; 0x19c4 <SetClockFormat+0x22>
        else
            LCD_puts_f(PSTR("12H"), 1);	// mt LCD_puts("12H", 1);		
    19c0:	84 e5       	ldi	r24, 0x54	; 84
    19c2:	95 e0       	ldi	r25, 0x05	; 5
    19c4:	61 e0       	ldi	r22, 0x01	; 1
    19c6:	79 d5       	rcall	.+2802   	; 0x24ba <LCD_puts_f>

    }
    if (input == KEY_PLUS)
    19c8:	14 30       	cpi	r17, 0x04	; 4
    19ca:	79 f4       	brne	.+30     	; 0x19ea <SetClockFormat+0x48>
    {
        if(clockformat == CLOCK_24)
    19cc:	80 91 4b 01 	lds	r24, 0x014B
    19d0:	81 30       	cpi	r24, 0x01	; 1
    19d2:	29 f4       	brne	.+10     	; 0x19de <SetClockFormat+0x3c>
        {
            clockformat = CLOCK_12;
    19d4:	10 92 4b 01 	sts	0x014B, r1
            LCD_puts_f(PSTR("12H"), 1); // mt LCD_puts("12H", 1);
    19d8:	80 e5       	ldi	r24, 0x50	; 80
    19da:	95 e0       	ldi	r25, 0x05	; 5
    19dc:	16 c0       	rjmp	.+44     	; 0x1a0a <SetClockFormat+0x68>
        }
        else
        {
            clockformat = CLOCK_24;
    19de:	81 e0       	ldi	r24, 0x01	; 1
    19e0:	80 93 4b 01 	sts	0x014B, r24
            LCD_puts_f(PSTR("24H"), 1); // mt LCD_puts("24H", 1);            
    19e4:	8c e4       	ldi	r24, 0x4C	; 76
    19e6:	95 e0       	ldi	r25, 0x05	; 5
    19e8:	10 c0       	rjmp	.+32     	; 0x1a0a <SetClockFormat+0x68>
        }
    }
    else if (input == KEY_MINUS)
    19ea:	15 30       	cpi	r17, 0x05	; 5
    19ec:	91 f4       	brne	.+36     	; 0x1a12 <SetClockFormat+0x70>
    {
        if(clockformat == CLOCK_12)
    19ee:	80 91 4b 01 	lds	r24, 0x014B
    19f2:	88 23       	and	r24, r24
    19f4:	31 f4       	brne	.+12     	; 0x1a02 <SetClockFormat+0x60>
        {
            clockformat = CLOCK_24;
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	80 93 4b 01 	sts	0x014B, r24
            LCD_puts_f(PSTR("24H"), 1);	// mt LCD_puts("24H", 1);
    19fc:	88 e4       	ldi	r24, 0x48	; 72
    19fe:	95 e0       	ldi	r25, 0x05	; 5
    1a00:	04 c0       	rjmp	.+8      	; 0x1a0a <SetClockFormat+0x68>
        }
        else
        {
            clockformat = CLOCK_12;
    1a02:	10 92 4b 01 	sts	0x014B, r1
            LCD_puts_f(PSTR("12H"), 1);   // mt LCD_puts("12H", 1);            
    1a06:	84 e4       	ldi	r24, 0x44	; 68
    1a08:	95 e0       	ldi	r25, 0x05	; 5
    1a0a:	61 e0       	ldi	r22, 0x01	; 1
    1a0c:	56 d5       	rcall	.+2732   	; 0x24ba <LCD_puts_f>
    1a0e:	84 e2       	ldi	r24, 0x24	; 36
    1a10:	05 c0       	rjmp	.+10     	; 0x1a1c <SetClockFormat+0x7a>
        }
    }
    else if (input == KEY_ENTER)    
    1a12:	11 30       	cpi	r17, 0x01	; 1
    1a14:	e1 f7       	brne	.-8      	; 0x1a0e <SetClockFormat+0x6c>
    {
        enter = 1;
    1a16:	10 93 55 01 	sts	0x0155, r17
    1a1a:	86 e1       	ldi	r24, 0x16	; 22
        return ST_TIME_CLOCK_FUNC;
    }        
    return ST_TIME_CLOCKFORMAT_ADJUST_FUNC;
}
    1a1c:	1f 91       	pop	r17
    1a1e:	08 95       	ret

00001a20 <SetDate>:
*
*   Purpose :       Adjusts the date
*
*****************************************************************************/
char SetDate(char input)
{
    1a20:	ff 92       	push	r15
    1a22:	0f 93       	push	r16
    1a24:	1f 93       	push	r17
    1a26:	f8 2e       	mov	r15, r24
	uint8_t YH, YL, MH, ML, DH, DL;
	uint8_t MonthLength_temp;
	uint8_t LeapMonth;
	// mtE

    if (enter_function)
    1a28:	80 91 54 01 	lds	r24, 0x0154
    1a2c:	88 23       	and	r24, r24
    1a2e:	71 f0       	breq	.+28     	; 0x1a4c <SetDate+0x2c>
    {
        date[YEAR] = gYEAR;
    1a30:	80 91 94 01 	lds	r24, 0x0194
    1a34:	90 91 95 01 	lds	r25, 0x0195
    1a38:	80 93 67 01 	sts	0x0167, r24
        date[MONTH] = gMONTH;
    1a3c:	80 91 96 01 	lds	r24, 0x0196
    1a40:	80 93 68 01 	sts	0x0168, r24
        date[DAY] = gDAY;
    1a44:	80 91 93 01 	lds	r24, 0x0193
    1a48:	80 93 69 01 	sts	0x0169, r24
    }

    if (mode == YEAR)
    1a4c:	80 91 53 01 	lds	r24, 0x0153
    1a50:	88 23       	and	r24, r24
    1a52:	99 f4       	brne	.+38     	; 0x1a7a <SetDate+0x5a>
    {
        YH = CHAR2BCD2(date[YEAR]);
    1a54:	80 91 67 01 	lds	r24, 0x0167
    1a58:	6b dc       	rcall	.-1834   	; 0x1330 <CHAR2BCD2>
    1a5a:	18 2f       	mov	r17, r24
        YL = (YH & 0x0F) + '0';
        YH = (YH >> 4) + '0';
    1a5c:	08 2f       	mov	r16, r24
    1a5e:	02 95       	swap	r16
    1a60:	0f 70       	andi	r16, 0x0F	; 15
        
        LCD_putc( 0, ' ');
    1a62:	80 e0       	ldi	r24, 0x00	; 0
    1a64:	60 e2       	ldi	r22, 0x20	; 32
    1a66:	89 d5       	rcall	.+2834   	; 0x257a <LCD_putc>
        LCD_putc( 1, ' ');   
    1a68:	81 e0       	ldi	r24, 0x01	; 1
    1a6a:	60 e2       	ldi	r22, 0x20	; 32
    1a6c:	86 d5       	rcall	.+2828   	; 0x257a <LCD_putc>
        LCD_putc( 2, 'Y');
    1a6e:	82 e0       	ldi	r24, 0x02	; 2
    1a70:	69 e5       	ldi	r22, 0x59	; 89
    1a72:	83 d5       	rcall	.+2822   	; 0x257a <LCD_putc>
        LCD_putc( 3, 'Y');        
    1a74:	83 e0       	ldi	r24, 0x03	; 3
    1a76:	69 e5       	ldi	r22, 0x59	; 89
    1a78:	29 c0       	rjmp	.+82     	; 0x1acc <SetDate+0xac>
        LCD_putc( 4, YH);
        LCD_putc( 5, YL);
    }
    else if (mode == MONTH)
    1a7a:	81 30       	cpi	r24, 0x01	; 1
    1a7c:	99 f4       	brne	.+38     	; 0x1aa4 <SetDate+0x84>
    {
        MH = CHAR2BCD2(date[MONTH]);
    1a7e:	80 91 68 01 	lds	r24, 0x0168
    1a82:	56 dc       	rcall	.-1876   	; 0x1330 <CHAR2BCD2>
    1a84:	18 2f       	mov	r17, r24
        ML = (MH & 0x0F) + '0';
        MH = (MH >> 4) + '0';
    1a86:	08 2f       	mov	r16, r24
    1a88:	02 95       	swap	r16
    1a8a:	0f 70       	andi	r16, 0x0F	; 15

        LCD_putc( 0, ' ');
    1a8c:	80 e0       	ldi	r24, 0x00	; 0
    1a8e:	60 e2       	ldi	r22, 0x20	; 32
    1a90:	74 d5       	rcall	.+2792   	; 0x257a <LCD_putc>
        LCD_putc( 1, ' ');   
    1a92:	81 e0       	ldi	r24, 0x01	; 1
    1a94:	60 e2       	ldi	r22, 0x20	; 32
    1a96:	71 d5       	rcall	.+2786   	; 0x257a <LCD_putc>
        LCD_putc( 2, 'M');
    1a98:	82 e0       	ldi	r24, 0x02	; 2
    1a9a:	6d e4       	ldi	r22, 0x4D	; 77
    1a9c:	6e d5       	rcall	.+2780   	; 0x257a <LCD_putc>
        LCD_putc( 3, 'M');        
    1a9e:	83 e0       	ldi	r24, 0x03	; 3
    1aa0:	6d e4       	ldi	r22, 0x4D	; 77
    1aa2:	14 c0       	rjmp	.+40     	; 0x1acc <SetDate+0xac>
        LCD_putc( 4, MH);
        LCD_putc( 5, ML);
    }
    else if (mode == DAY)
    1aa4:	82 30       	cpi	r24, 0x02	; 2
    1aa6:	e1 f4       	brne	.+56     	; 0x1ae0 <SetDate+0xc0>
    {
        DH = CHAR2BCD2(date[DAY]);
    1aa8:	80 91 69 01 	lds	r24, 0x0169
    1aac:	41 dc       	rcall	.-1918   	; 0x1330 <CHAR2BCD2>
    1aae:	18 2f       	mov	r17, r24
        DL = (DH & 0x0F) + '0';
        DH = (DH >> 4) + '0';
    1ab0:	08 2f       	mov	r16, r24
    1ab2:	02 95       	swap	r16
    1ab4:	0f 70       	andi	r16, 0x0F	; 15

        LCD_putc( 0, ' ');
    1ab6:	80 e0       	ldi	r24, 0x00	; 0
    1ab8:	60 e2       	ldi	r22, 0x20	; 32
    1aba:	5f d5       	rcall	.+2750   	; 0x257a <LCD_putc>
        LCD_putc( 1, ' ');   
    1abc:	81 e0       	ldi	r24, 0x01	; 1
    1abe:	60 e2       	ldi	r22, 0x20	; 32
    1ac0:	5c d5       	rcall	.+2744   	; 0x257a <LCD_putc>
        LCD_putc( 2, 'D');
    1ac2:	82 e0       	ldi	r24, 0x02	; 2
    1ac4:	64 e4       	ldi	r22, 0x44	; 68
    1ac6:	59 d5       	rcall	.+2738   	; 0x257a <LCD_putc>
        LCD_putc( 3, 'D');        
    1ac8:	83 e0       	ldi	r24, 0x03	; 3
    1aca:	64 e4       	ldi	r22, 0x44	; 68
    1acc:	56 d5       	rcall	.+2732   	; 0x257a <LCD_putc>
        LCD_putc( 4, DH);
    1ace:	00 5d       	subi	r16, 0xD0	; 208
    1ad0:	84 e0       	ldi	r24, 0x04	; 4
    1ad2:	60 2f       	mov	r22, r16
    1ad4:	52 d5       	rcall	.+2724   	; 0x257a <LCD_putc>
        LCD_putc( 5, DL);
    1ad6:	1f 70       	andi	r17, 0x0F	; 15
    1ad8:	10 5d       	subi	r17, 0xD0	; 208
    1ada:	85 e0       	ldi	r24, 0x05	; 5
    1adc:	61 2f       	mov	r22, r17
    1ade:	4d d5       	rcall	.+2714   	; 0x257a <LCD_putc>
    }

    LCD_putc(6, '\0');
    1ae0:	86 e0       	ldi	r24, 0x06	; 6
    1ae2:	60 e0       	ldi	r22, 0x00	; 0
    1ae4:	4a d5       	rcall	.+2708   	; 0x257a <LCD_putc>

    LCD_Colon(0);
    1ae6:	80 e0       	ldi	r24, 0x00	; 0
    1ae8:	5e d5       	rcall	.+2748   	; 0x25a6 <LCD_Colon>

    if (input != KEY_NULL)
    1aea:	ff 20       	and	r15, r15
    1aec:	09 f0       	breq	.+2      	; 0x1af0 <SetDate+0xd0>
        LCD_FlashReset();
    1aee:	6a d5       	rcall	.+2772   	; 0x25c4 <LCD_FlashReset>

    LCD_UpdateRequired(TRUE, 0);
    1af0:	81 e0       	ldi	r24, 0x01	; 1
    1af2:	60 e0       	ldi	r22, 0x00	; 0
    1af4:	5b d5       	rcall	.+2742   	; 0x25ac <LCD_UpdateRequired>


    enter_function = 1;
    1af6:	81 e0       	ldi	r24, 0x01	; 1
    1af8:	80 93 54 01 	sts	0x0154, r24

    // Increment/decrement years, months or days
    if (input == KEY_PLUS)
    1afc:	84 e0       	ldi	r24, 0x04	; 4
    1afe:	f8 16       	cp	r15, r24
    1b00:	41 f4       	brne	.+16     	; 0x1b12 <SetDate+0xf2>
        date[mode]++;
    1b02:	e0 91 53 01 	lds	r30, 0x0153
    1b06:	f0 e0       	ldi	r31, 0x00	; 0
    1b08:	e9 59       	subi	r30, 0x99	; 153
    1b0a:	fe 4f       	sbci	r31, 0xFE	; 254
    1b0c:	80 81       	ld	r24, Z
    1b0e:	8f 5f       	subi	r24, 0xFF	; 255
    1b10:	0a c0       	rjmp	.+20     	; 0x1b26 <SetDate+0x106>
    else if (input == KEY_MINUS)
    1b12:	85 e0       	ldi	r24, 0x05	; 5
    1b14:	f8 16       	cp	r15, r24
    1b16:	49 f4       	brne	.+18     	; 0x1b2a <SetDate+0x10a>
        date[mode]--;
    1b18:	e0 91 53 01 	lds	r30, 0x0153
    1b1c:	f0 e0       	ldi	r31, 0x00	; 0
    1b1e:	e9 59       	subi	r30, 0x99	; 153
    1b20:	fe 4f       	sbci	r31, 0xFE	; 254
    1b22:	80 81       	ld	r24, Z
    1b24:	81 50       	subi	r24, 0x01	; 1
    1b26:	80 83       	st	Z, r24
    1b28:	31 c0       	rjmp	.+98     	; 0x1b8c <SetDate+0x16c>
    else if (input == KEY_PREV)
    1b2a:	83 e0       	ldi	r24, 0x03	; 3
    1b2c:	f8 16       	cp	r15, r24
    1b2e:	41 f4       	brne	.+16     	; 0x1b40 <SetDate+0x120>
    {
        if (mode == YEAR)
    1b30:	80 91 53 01 	lds	r24, 0x0153
    1b34:	88 23       	and	r24, r24
    1b36:	11 f4       	brne	.+4      	; 0x1b3c <SetDate+0x11c>
            mode = DAY;
    1b38:	82 e0       	ldi	r24, 0x02	; 2
    1b3a:	0d c0       	rjmp	.+26     	; 0x1b56 <SetDate+0x136>
        else
            mode--;
    1b3c:	81 50       	subi	r24, 0x01	; 1
    1b3e:	0b c0       	rjmp	.+22     	; 0x1b56 <SetDate+0x136>
    }
    else if (input == KEY_NEXT)
    1b40:	82 e0       	ldi	r24, 0x02	; 2
    1b42:	f8 16       	cp	r15, r24
    1b44:	59 f4       	brne	.+22     	; 0x1b5c <SetDate+0x13c>
    {
        if (mode == DAY)
    1b46:	80 91 53 01 	lds	r24, 0x0153
    1b4a:	82 30       	cpi	r24, 0x02	; 2
    1b4c:	19 f4       	brne	.+6      	; 0x1b54 <SetDate+0x134>
            mode = YEAR;
    1b4e:	10 92 53 01 	sts	0x0153, r1
    1b52:	1c c0       	rjmp	.+56     	; 0x1b8c <SetDate+0x16c>
        else
            mode++;
    1b54:	8f 5f       	subi	r24, 0xFF	; 255
    1b56:	80 93 53 01 	sts	0x0153, r24
    1b5a:	18 c0       	rjmp	.+48     	; 0x1b8c <SetDate+0x16c>
    }
    else if (input == KEY_ENTER)
    1b5c:	81 e0       	ldi	r24, 0x01	; 1
    1b5e:	f8 16       	cp	r15, r24
    1b60:	a9 f4       	brne	.+42     	; 0x1b8c <SetDate+0x16c>
    {
        // store the temporary adjusted values to the global variables
        cli(); // mt __disable_interrupt();
    1b62:	f8 94       	cli
        gYEAR = date[YEAR];
    1b64:	80 91 67 01 	lds	r24, 0x0167
    1b68:	90 e0       	ldi	r25, 0x00	; 0
    1b6a:	90 93 95 01 	sts	0x0195, r25
    1b6e:	80 93 94 01 	sts	0x0194, r24
        gMONTH = date[MONTH];
    1b72:	80 91 68 01 	lds	r24, 0x0168
    1b76:	80 93 96 01 	sts	0x0196, r24
        gDAY = date[DAY];
    1b7a:	80 91 69 01 	lds	r24, 0x0169
    1b7e:	80 93 93 01 	sts	0x0193, r24
        sei(); // mt __enable_interrupt();
    1b82:	78 94       	sei
        mode = YEAR;
    1b84:	10 92 53 01 	sts	0x0153, r1
    1b88:	8c e1       	ldi	r24, 0x1C	; 28
    1b8a:	53 c0       	rjmp	.+166    	; 0x1c32 <SetDate+0x212>
        return ST_TIME_DATE_FUNC;
    }

    /* OPTIMIZE: Can be solved by using a modulo operation */
    if (date[YEAR] == 255)
    1b8c:	80 91 67 01 	lds	r24, 0x0167
    1b90:	8f 3f       	cpi	r24, 0xFF	; 255
    1b92:	19 f4       	brne	.+6      	; 0x1b9a <SetDate+0x17a>
        date[YEAR] = 99;
    1b94:	83 e6       	ldi	r24, 0x63	; 99
    1b96:	80 93 67 01 	sts	0x0167, r24
    if (date[YEAR] > 99)
    1b9a:	80 91 67 01 	lds	r24, 0x0167
    1b9e:	84 36       	cpi	r24, 0x64	; 100
    1ba0:	10 f0       	brcs	.+4      	; 0x1ba6 <SetDate+0x186>
        date[YEAR] = 0;
    1ba2:	10 92 67 01 	sts	0x0167, r1

    if (date[MONTH] == 0)
    1ba6:	80 91 68 01 	lds	r24, 0x0168
    1baa:	88 23       	and	r24, r24
    1bac:	19 f4       	brne	.+6      	; 0x1bb4 <SetDate+0x194>
        date[MONTH] = 12;
    1bae:	8c e0       	ldi	r24, 0x0C	; 12
    1bb0:	80 93 68 01 	sts	0x0168, r24
    if (date[MONTH] > 12)
    1bb4:	80 91 68 01 	lds	r24, 0x0168
    1bb8:	8d 30       	cpi	r24, 0x0D	; 13
    1bba:	18 f0       	brcs	.+6      	; 0x1bc2 <SetDate+0x1a2>
        date[MONTH] = 1;
    1bbc:	81 e0       	ldi	r24, 0x01	; 1
    1bbe:	80 93 68 01 	sts	0x0168, r24

    // Check for leap year, if month == February
    if (gMONTH == 2)
    1bc2:	80 91 96 01 	lds	r24, 0x0196
    1bc6:	82 30       	cpi	r24, 0x02	; 2
    1bc8:	e1 f4       	brne	.+56     	; 0x1c02 <SetDate+0x1e2>
        if (!(gYEAR & 0x0003))              // if (gYEAR%4 == 0)
    1bca:	80 91 94 01 	lds	r24, 0x0194
    1bce:	90 91 95 01 	lds	r25, 0x0195
    1bd2:	83 70       	andi	r24, 0x03	; 3
    1bd4:	90 70       	andi	r25, 0x00	; 0
    1bd6:	89 2b       	or	r24, r25
    1bd8:	a1 f4       	brne	.+40     	; 0x1c02 <SetDate+0x1e2>
            if (gYEAR%100 == 0)
    1bda:	80 91 94 01 	lds	r24, 0x0194
    1bde:	90 91 95 01 	lds	r25, 0x0195
    1be2:	64 e6       	ldi	r22, 0x64	; 100
    1be4:	70 e0       	ldi	r23, 0x00	; 0
    1be6:	0e 94 33 19 	call	0x3266	; 0x3266 <__udivmodhi4>
    1bea:	89 2b       	or	r24, r25
    1bec:	89 f4       	brne	.+34     	; 0x1c10 <SetDate+0x1f0>
                if (gYEAR%400 == 0)
    1bee:	80 91 94 01 	lds	r24, 0x0194
    1bf2:	90 91 95 01 	lds	r25, 0x0195
    1bf6:	60 e9       	ldi	r22, 0x90	; 144
    1bf8:	71 e0       	ldi	r23, 0x01	; 1
    1bfa:	0e 94 33 19 	call	0x3266	; 0x3266 <__udivmodhi4>
    1bfe:	89 2b       	or	r24, r25
    1c00:	39 f0       	breq	.+14     	; 0x1c10 <SetDate+0x1f0>
        LeapMonth = 0;

    if (LeapMonth)
        MonthLength_temp = 29;
    else
        MonthLength_temp = MonthLength[date[MONTH]];
    1c02:	e0 91 68 01 	lds	r30, 0x0168
    1c06:	f0 e0       	ldi	r31, 0x00	; 0
    1c08:	ea 5d       	subi	r30, 0xDA	; 218
    1c0a:	fe 4f       	sbci	r31, 0xFE	; 254
    1c0c:	e0 81       	ld	r30, Z
    1c0e:	01 c0       	rjmp	.+2      	; 0x1c12 <SetDate+0x1f2>
    1c10:	ed e1       	ldi	r30, 0x1D	; 29
    
    if (date[DAY] == 0)
    1c12:	80 91 69 01 	lds	r24, 0x0169
    1c16:	88 23       	and	r24, r24
    1c18:	11 f4       	brne	.+4      	; 0x1c1e <SetDate+0x1fe>
        date[DAY] = MonthLength_temp;
    1c1a:	e0 93 69 01 	sts	0x0169, r30
    if (date[DAY] > MonthLength_temp)
    1c1e:	80 91 69 01 	lds	r24, 0x0169
    1c22:	e8 17       	cp	r30, r24
    1c24:	18 f4       	brcc	.+6      	; 0x1c2c <SetDate+0x20c>
        date[DAY] = 1;
    1c26:	81 e0       	ldi	r24, 0x01	; 1
    1c28:	80 93 69 01 	sts	0x0169, r24

    enter_function = 0;
    1c2c:	10 92 54 01 	sts	0x0154, r1
    1c30:	8e e1       	ldi	r24, 0x1E	; 30
    
    return ST_TIME_DATE_ADJUST_FUNC;
}
    1c32:	1f 91       	pop	r17
    1c34:	0f 91       	pop	r16
    1c36:	ff 90       	pop	r15
    1c38:	08 95       	ret

00001c3a <ShowDate>:
*
*   Purpose :       Shows the date on the LCD
*
*****************************************************************************/
char ShowDate(char input)
{
    1c3a:	9f 92       	push	r9
    1c3c:	af 92       	push	r10
    1c3e:	bf 92       	push	r11
    1c40:	cf 92       	push	r12
    1c42:	df 92       	push	r13
    1c44:	ef 92       	push	r14
    1c46:	ff 92       	push	r15
    1c48:	0f 93       	push	r16
    1c4a:	1f 93       	push	r17
    1c4c:	cf 93       	push	r28
    1c4e:	df 93       	push	r29
    1c50:	98 2e       	mov	r9, r24
    char YH, YL, MH, ML, DH, DL;

    YH = CHAR2BCD2(gYEAR);
    1c52:	80 91 94 01 	lds	r24, 0x0194
    1c56:	90 91 95 01 	lds	r25, 0x0195
    1c5a:	6a db       	rcall	.-2348   	; 0x1330 <CHAR2BCD2>
    1c5c:	18 2f       	mov	r17, r24
    YL = (YH & 0x0F) + '0';
    YH = (YH >> 4) + '0';
    1c5e:	08 2f       	mov	r16, r24
    1c60:	02 95       	swap	r16
    1c62:	0f 70       	andi	r16, 0x0F	; 15

    MH = CHAR2BCD2(gMONTH);
    1c64:	80 91 96 01 	lds	r24, 0x0196
    1c68:	63 db       	rcall	.-2362   	; 0x1330 <CHAR2BCD2>
    1c6a:	f8 2e       	mov	r15, r24
    ML = (MH & 0x0F) + '0';
    MH = (MH >> 4) + '0';
    1c6c:	d8 2e       	mov	r13, r24
    1c6e:	d2 94       	swap	r13
    1c70:	4f e0       	ldi	r20, 0x0F	; 15
    1c72:	d4 22       	and	r13, r20

    DH = CHAR2BCD2(gDAY);
    1c74:	80 91 93 01 	lds	r24, 0x0193
    1c78:	5b db       	rcall	.-2378   	; 0x1330 <CHAR2BCD2>
    1c7a:	e8 2e       	mov	r14, r24
    DL = (DH & 0x0F) + '0';
    DH = (DH >> 4) + '0';
    1c7c:	c8 2e       	mov	r12, r24
    1c7e:	c2 94       	swap	r12
    1c80:	3f e0       	ldi	r19, 0x0F	; 15
    1c82:	c3 22       	and	r12, r19
    LCD_putc( *(DATE_FORMAT_NR[dateformat] + 2), MH);
    LCD_putc( *(DATE_FORMAT_NR[dateformat] + 3), ML);
    LCD_putc( *(DATE_FORMAT_NR[dateformat] + 4), DH);
    LCD_putc( *(DATE_FORMAT_NR[dateformat] + 5), DL);
	*/
   	uint8_t *pDateFormatNr = (uint8_t*)pgm_read_word(&DATE_FORMAT_NR[dateformat]);
    1c84:	80 91 65 01 	lds	r24, 0x0165
    1c88:	90 e0       	ldi	r25, 0x00	; 0
    1c8a:	88 0f       	add	r24, r24
    1c8c:	99 1f       	adc	r25, r25
    1c8e:	82 5c       	subi	r24, 0xC2	; 194
    1c90:	9a 4f       	sbci	r25, 0xFA	; 250
    1c92:	fc 01       	movw	r30, r24
    1c94:	25 91       	lpm	r18, Z+
    1c96:	34 91       	lpm	r19, Z+
    LCD_putc( pgm_read_byte(pDateFormatNr++), YH);
    1c98:	e9 01       	movw	r28, r18
    1c9a:	21 96       	adiw	r28, 0x01	; 1
    1c9c:	f9 01       	movw	r30, r18
    1c9e:	84 91       	lpm	r24, Z+
    1ca0:	00 5d       	subi	r16, 0xD0	; 208
    1ca2:	60 2f       	mov	r22, r16
    1ca4:	6a d4       	rcall	.+2260   	; 0x257a <LCD_putc>
    LCD_putc( pgm_read_byte(pDateFormatNr++), YL);
    1ca6:	5e 01       	movw	r10, r28
    1ca8:	08 94       	sec
    1caa:	a1 1c       	adc	r10, r1
    1cac:	b1 1c       	adc	r11, r1
    1cae:	fe 01       	movw	r30, r28
    1cb0:	84 91       	lpm	r24, Z+
    1cb2:	1f 70       	andi	r17, 0x0F	; 15
    1cb4:	10 5d       	subi	r17, 0xD0	; 208
    1cb6:	61 2f       	mov	r22, r17
    1cb8:	60 d4       	rcall	.+2240   	; 0x257a <LCD_putc>
    LCD_putc( pgm_read_byte(pDateFormatNr++), MH);
    1cba:	e5 01       	movw	r28, r10
    1cbc:	21 96       	adiw	r28, 0x01	; 1
    1cbe:	f5 01       	movw	r30, r10
    1cc0:	84 91       	lpm	r24, Z+
    1cc2:	f0 e3       	ldi	r31, 0x30	; 48
    1cc4:	df 0e       	add	r13, r31
    1cc6:	6d 2d       	mov	r22, r13
    1cc8:	58 d4       	rcall	.+2224   	; 0x257a <LCD_putc>
    LCD_putc( pgm_read_byte(pDateFormatNr++), ML);
    1cca:	8e 01       	movw	r16, r28
    1ccc:	0f 5f       	subi	r16, 0xFF	; 255
    1cce:	1f 4f       	sbci	r17, 0xFF	; 255
    1cd0:	fe 01       	movw	r30, r28
    1cd2:	84 91       	lpm	r24, Z+
    1cd4:	ff e0       	ldi	r31, 0x0F	; 15
    1cd6:	ff 22       	and	r15, r31
    1cd8:	90 e3       	ldi	r25, 0x30	; 48
    1cda:	f9 0e       	add	r15, r25
    1cdc:	6f 2d       	mov	r22, r15
    1cde:	4d d4       	rcall	.+2202   	; 0x257a <LCD_putc>
	LCD_putc( pgm_read_byte(pDateFormatNr++), DH);
    1ce0:	f8 01       	movw	r30, r16
    1ce2:	84 91       	lpm	r24, Z+
    1ce4:	f0 e3       	ldi	r31, 0x30	; 48
    1ce6:	cf 0e       	add	r12, r31
    1ce8:	6c 2d       	mov	r22, r12
    1cea:	47 d4       	rcall	.+2190   	; 0x257a <LCD_putc>
    LCD_putc( pgm_read_byte(pDateFormatNr), DL);
    1cec:	0f 5f       	subi	r16, 0xFF	; 255
    1cee:	1f 4f       	sbci	r17, 0xFF	; 255
    1cf0:	f8 01       	movw	r30, r16
    1cf2:	84 91       	lpm	r24, Z+
    1cf4:	ff e0       	ldi	r31, 0x0F	; 15
    1cf6:	ef 22       	and	r14, r31
    1cf8:	90 e3       	ldi	r25, 0x30	; 48
    1cfa:	e9 0e       	add	r14, r25
    1cfc:	6e 2d       	mov	r22, r14
    1cfe:	3d d4       	rcall	.+2170   	; 0x257a <LCD_putc>
    // mtE

    LCD_putc(6, '\0');
    1d00:	86 e0       	ldi	r24, 0x06	; 6
    1d02:	60 e0       	ldi	r22, 0x00	; 0
    1d04:	3a d4       	rcall	.+2164   	; 0x257a <LCD_putc>

    LCD_Colon(1);
    1d06:	81 e0       	ldi	r24, 0x01	; 1
    1d08:	4e d4       	rcall	.+2204   	; 0x25a6 <LCD_Colon>

    LCD_UpdateRequired(TRUE, 0);
    1d0a:	81 e0       	ldi	r24, 0x01	; 1
    1d0c:	60 e0       	ldi	r22, 0x00	; 0
    1d0e:	4e d4       	rcall	.+2204   	; 0x25ac <LCD_UpdateRequired>


    if (input == KEY_PREV)
    1d10:	e3 e0       	ldi	r30, 0x03	; 3
    1d12:	9e 16       	cp	r9, r30
    1d14:	11 f4       	brne	.+4      	; 0x1d1a <ShowDate+0xe0>
    1d16:	8b e1       	ldi	r24, 0x1B	; 27
    1d18:	06 c0       	rjmp	.+12     	; 0x1d26 <ShowDate+0xec>
        return ST_TIME_DATE;
    else if (input == KEY_NEXT)
    1d1a:	f2 e0       	ldi	r31, 0x02	; 2
    1d1c:	9f 16       	cp	r9, r31
    1d1e:	11 f0       	breq	.+4      	; 0x1d24 <ShowDate+0xea>
    1d20:	8c e1       	ldi	r24, 0x1C	; 28
    1d22:	01 c0       	rjmp	.+2      	; 0x1d26 <ShowDate+0xec>
    1d24:	8d e1       	ldi	r24, 0x1D	; 29
        return ST_TIME_DATE_ADJUST;
    else   
        return ST_TIME_DATE_FUNC;
}
    1d26:	df 91       	pop	r29
    1d28:	cf 91       	pop	r28
    1d2a:	1f 91       	pop	r17
    1d2c:	0f 91       	pop	r16
    1d2e:	ff 90       	pop	r15
    1d30:	ef 90       	pop	r14
    1d32:	df 90       	pop	r13
    1d34:	cf 90       	pop	r12
    1d36:	bf 90       	pop	r11
    1d38:	af 90       	pop	r10
    1d3a:	9f 90       	pop	r9
    1d3c:	08 95       	ret

00001d3e <SetClock>:
*
*   Purpose :       Adjusts the clock
*
*****************************************************************************/
char SetClock(char input)
{
    1d3e:	ef 92       	push	r14
    1d40:	ff 92       	push	r15
    1d42:	0f 93       	push	r16
    1d44:	1f 93       	push	r17
    1d46:	e8 2e       	mov	r14, r24
    static uint8_t time[3];
    static uint8_t mode = HOUR;
    uint8_t HH, HL, MH, ML, SH, SL;
    // mtE

    if (enter_function)
    1d48:	80 91 56 01 	lds	r24, 0x0156
    1d4c:	88 23       	and	r24, r24
    1d4e:	61 f0       	breq	.+24     	; 0x1d68 <SetClock+0x2a>
    {
        time[HOUR] = gHOUR;
    1d50:	80 91 91 01 	lds	r24, 0x0191
    1d54:	80 93 6b 01 	sts	0x016B, r24
        time[MINUTE] = gMINUTE;
    1d58:	80 91 97 01 	lds	r24, 0x0197
    1d5c:	80 93 6c 01 	sts	0x016C, r24
        time[SECOND] = gSECOND;
    1d60:	80 91 92 01 	lds	r24, 0x0192
    1d64:	80 93 6d 01 	sts	0x016D, r24
    }

    if (clockformat == CLOCK_12)    // if 12H clock
    1d68:	80 91 4b 01 	lds	r24, 0x014B
    1d6c:	88 23       	and	r24, r24
    1d6e:	39 f4       	brne	.+14     	; 0x1d7e <SetClock+0x40>
        HH = CHAR2BCD2(TBL_CLOCK_12[time[HOUR]]);
    1d70:	e0 91 6b 01 	lds	r30, 0x016B
    1d74:	f0 e0       	ldi	r31, 0x00	; 0
    1d76:	ed 5c       	subi	r30, 0xCD	; 205
    1d78:	fe 4f       	sbci	r31, 0xFE	; 254
    1d7a:	80 81       	ld	r24, Z
    1d7c:	02 c0       	rjmp	.+4      	; 0x1d82 <SetClock+0x44>
    else
        HH = CHAR2BCD2(time[HOUR]);
    1d7e:	80 91 6b 01 	lds	r24, 0x016B
    1d82:	d6 da       	rcall	.-2644   	; 0x1330 <CHAR2BCD2>
    1d84:	18 2f       	mov	r17, r24
        
    HL = (HH & 0x0F) + '0';
    HH = (HH >> 4) + '0';

    MH = CHAR2BCD2(time[MINUTE]);
    1d86:	80 91 6c 01 	lds	r24, 0x016C
    1d8a:	d2 da       	rcall	.-2652   	; 0x1330 <CHAR2BCD2>
    1d8c:	08 2f       	mov	r16, r24
    ML = (MH & 0x0F) + '0';
    MH = (MH >> 4) + '0';

    SH = CHAR2BCD2(time[SECOND]);
    1d8e:	80 91 6d 01 	lds	r24, 0x016D
    1d92:	ce da       	rcall	.-2660   	; 0x1330 <CHAR2BCD2>
    1d94:	f8 2e       	mov	r15, r24
    SL = (SH & 0x0F) + '0';
    SH = (SH >> 4) + '0';

    LCD_putc(0, HH | ((mode == HOUR) ? 0x80 : 0x00));
    1d96:	80 91 6a 01 	lds	r24, 0x016A
    1d9a:	88 23       	and	r24, r24
    1d9c:	11 f0       	breq	.+4      	; 0x1da2 <SetClock+0x64>
    1d9e:	60 e0       	ldi	r22, 0x00	; 0
    1da0:	01 c0       	rjmp	.+2      	; 0x1da4 <SetClock+0x66>
    1da2:	60 e8       	ldi	r22, 0x80	; 128
        HH = CHAR2BCD2(TBL_CLOCK_12[time[HOUR]]);
    else
        HH = CHAR2BCD2(time[HOUR]);
        
    HL = (HH & 0x0F) + '0';
    HH = (HH >> 4) + '0';
    1da4:	81 2f       	mov	r24, r17
    1da6:	82 95       	swap	r24
    1da8:	8f 70       	andi	r24, 0x0F	; 15

    SH = CHAR2BCD2(time[SECOND]);
    SL = (SH & 0x0F) + '0';
    SH = (SH >> 4) + '0';

    LCD_putc(0, HH | ((mode == HOUR) ? 0x80 : 0x00));
    1daa:	80 5d       	subi	r24, 0xD0	; 208
    1dac:	68 2b       	or	r22, r24
    1dae:	80 e0       	ldi	r24, 0x00	; 0
    1db0:	e4 d3       	rcall	.+1992   	; 0x257a <LCD_putc>
    LCD_putc(1, HL | ((mode == HOUR) ? 0x80 : 0x00));
    1db2:	80 91 6a 01 	lds	r24, 0x016A
    1db6:	88 23       	and	r24, r24
    1db8:	11 f0       	breq	.+4      	; 0x1dbe <SetClock+0x80>
    1dba:	60 e0       	ldi	r22, 0x00	; 0
    1dbc:	01 c0       	rjmp	.+2      	; 0x1dc0 <SetClock+0x82>
    1dbe:	60 e8       	ldi	r22, 0x80	; 128
    1dc0:	1f 70       	andi	r17, 0x0F	; 15
    1dc2:	10 5d       	subi	r17, 0xD0	; 208
    1dc4:	61 2b       	or	r22, r17
    1dc6:	81 e0       	ldi	r24, 0x01	; 1
    1dc8:	d8 d3       	rcall	.+1968   	; 0x257a <LCD_putc>
    LCD_putc(2, MH | ((mode == MINUTE) ? 0x80 : 0x00));
    1dca:	80 91 6a 01 	lds	r24, 0x016A
    1dce:	81 30       	cpi	r24, 0x01	; 1
    1dd0:	11 f0       	breq	.+4      	; 0x1dd6 <SetClock+0x98>
    1dd2:	60 e0       	ldi	r22, 0x00	; 0
    1dd4:	01 c0       	rjmp	.+2      	; 0x1dd8 <SetClock+0x9a>
    1dd6:	60 e8       	ldi	r22, 0x80	; 128
    HL = (HH & 0x0F) + '0';
    HH = (HH >> 4) + '0';

    MH = CHAR2BCD2(time[MINUTE]);
    ML = (MH & 0x0F) + '0';
    MH = (MH >> 4) + '0';
    1dd8:	80 2f       	mov	r24, r16
    1dda:	82 95       	swap	r24
    1ddc:	8f 70       	andi	r24, 0x0F	; 15
    SL = (SH & 0x0F) + '0';
    SH = (SH >> 4) + '0';

    LCD_putc(0, HH | ((mode == HOUR) ? 0x80 : 0x00));
    LCD_putc(1, HL | ((mode == HOUR) ? 0x80 : 0x00));
    LCD_putc(2, MH | ((mode == MINUTE) ? 0x80 : 0x00));
    1dde:	80 5d       	subi	r24, 0xD0	; 208
    1de0:	68 2b       	or	r22, r24
    1de2:	82 e0       	ldi	r24, 0x02	; 2
    1de4:	ca d3       	rcall	.+1940   	; 0x257a <LCD_putc>
    LCD_putc(3, ML | ((mode == MINUTE) ? 0x80 : 0x00));
    1de6:	80 91 6a 01 	lds	r24, 0x016A
    1dea:	81 30       	cpi	r24, 0x01	; 1
    1dec:	11 f0       	breq	.+4      	; 0x1df2 <SetClock+0xb4>
    1dee:	60 e0       	ldi	r22, 0x00	; 0
    1df0:	01 c0       	rjmp	.+2      	; 0x1df4 <SetClock+0xb6>
    1df2:	60 e8       	ldi	r22, 0x80	; 128
    1df4:	0f 70       	andi	r16, 0x0F	; 15
    1df6:	00 5d       	subi	r16, 0xD0	; 208
    1df8:	60 2b       	or	r22, r16
    1dfa:	83 e0       	ldi	r24, 0x03	; 3
    1dfc:	be d3       	rcall	.+1916   	; 0x257a <LCD_putc>
    LCD_putc(4, SH | ((mode == SECOND) ? 0x80 : 0x00));
    1dfe:	80 91 6a 01 	lds	r24, 0x016A
    1e02:	82 30       	cpi	r24, 0x02	; 2
    1e04:	11 f0       	breq	.+4      	; 0x1e0a <SetClock+0xcc>
    1e06:	60 e0       	ldi	r22, 0x00	; 0
    1e08:	01 c0       	rjmp	.+2      	; 0x1e0c <SetClock+0xce>
    1e0a:	60 e8       	ldi	r22, 0x80	; 128
    ML = (MH & 0x0F) + '0';
    MH = (MH >> 4) + '0';

    SH = CHAR2BCD2(time[SECOND]);
    SL = (SH & 0x0F) + '0';
    SH = (SH >> 4) + '0';
    1e0c:	8f 2d       	mov	r24, r15
    1e0e:	82 95       	swap	r24
    1e10:	8f 70       	andi	r24, 0x0F	; 15

    LCD_putc(0, HH | ((mode == HOUR) ? 0x80 : 0x00));
    LCD_putc(1, HL | ((mode == HOUR) ? 0x80 : 0x00));
    LCD_putc(2, MH | ((mode == MINUTE) ? 0x80 : 0x00));
    LCD_putc(3, ML | ((mode == MINUTE) ? 0x80 : 0x00));
    LCD_putc(4, SH | ((mode == SECOND) ? 0x80 : 0x00));
    1e12:	80 5d       	subi	r24, 0xD0	; 208
    1e14:	68 2b       	or	r22, r24
    1e16:	84 e0       	ldi	r24, 0x04	; 4
    1e18:	b0 d3       	rcall	.+1888   	; 0x257a <LCD_putc>
    LCD_putc(5, SL | ((mode == SECOND) ? 0x80 : 0x00));
    1e1a:	80 91 6a 01 	lds	r24, 0x016A
    1e1e:	82 30       	cpi	r24, 0x02	; 2
    1e20:	11 f0       	breq	.+4      	; 0x1e26 <SetClock+0xe8>
    1e22:	60 e0       	ldi	r22, 0x00	; 0
    1e24:	01 c0       	rjmp	.+2      	; 0x1e28 <SetClock+0xea>
    1e26:	60 e8       	ldi	r22, 0x80	; 128
    1e28:	8f e0       	ldi	r24, 0x0F	; 15
    1e2a:	f8 22       	and	r15, r24
    1e2c:	80 e3       	ldi	r24, 0x30	; 48
    1e2e:	f8 0e       	add	r15, r24
    1e30:	6f 29       	or	r22, r15
    1e32:	85 e0       	ldi	r24, 0x05	; 5
    1e34:	a2 d3       	rcall	.+1860   	; 0x257a <LCD_putc>
    LCD_putc(6, '\0');
    1e36:	86 e0       	ldi	r24, 0x06	; 6
    1e38:	60 e0       	ldi	r22, 0x00	; 0
    1e3a:	9f d3       	rcall	.+1854   	; 0x257a <LCD_putc>

    LCD_Colon(1);
    1e3c:	81 e0       	ldi	r24, 0x01	; 1
    1e3e:	b3 d3       	rcall	.+1894   	; 0x25a6 <LCD_Colon>

    if (input != KEY_NULL)
    1e40:	ee 20       	and	r14, r14
    1e42:	09 f0       	breq	.+2      	; 0x1e46 <SetClock+0x108>
        LCD_FlashReset();
    1e44:	bf d3       	rcall	.+1918   	; 0x25c4 <LCD_FlashReset>

    LCD_UpdateRequired(TRUE, 0);
    1e46:	81 e0       	ldi	r24, 0x01	; 1
    1e48:	60 e0       	ldi	r22, 0x00	; 0
    1e4a:	b0 d3       	rcall	.+1888   	; 0x25ac <LCD_UpdateRequired>
    
    enter_function = 1;
    1e4c:	81 e0       	ldi	r24, 0x01	; 1
    1e4e:	80 93 56 01 	sts	0x0156, r24

    // Increment/decrement hours, minutes or seconds
    if (input == KEY_PLUS)
    1e52:	84 e0       	ldi	r24, 0x04	; 4
    1e54:	e8 16       	cp	r14, r24
    1e56:	41 f4       	brne	.+16     	; 0x1e68 <SetClock+0x12a>
        time[mode]++;
    1e58:	e0 91 6a 01 	lds	r30, 0x016A
    1e5c:	f0 e0       	ldi	r31, 0x00	; 0
    1e5e:	e5 59       	subi	r30, 0x95	; 149
    1e60:	fe 4f       	sbci	r31, 0xFE	; 254
    1e62:	80 81       	ld	r24, Z
    1e64:	8f 5f       	subi	r24, 0xFF	; 255
    1e66:	0a c0       	rjmp	.+20     	; 0x1e7c <SetClock+0x13e>
    else if (input == KEY_MINUS)
    1e68:	85 e0       	ldi	r24, 0x05	; 5
    1e6a:	e8 16       	cp	r14, r24
    1e6c:	49 f4       	brne	.+18     	; 0x1e80 <SetClock+0x142>
        time[mode]--;
    1e6e:	e0 91 6a 01 	lds	r30, 0x016A
    1e72:	f0 e0       	ldi	r31, 0x00	; 0
    1e74:	e5 59       	subi	r30, 0x95	; 149
    1e76:	fe 4f       	sbci	r31, 0xFE	; 254
    1e78:	80 81       	ld	r24, Z
    1e7a:	81 50       	subi	r24, 0x01	; 1
    1e7c:	80 83       	st	Z, r24
    1e7e:	2e c0       	rjmp	.+92     	; 0x1edc <SetClock+0x19e>
    else if (input == KEY_PREV)
    1e80:	83 e0       	ldi	r24, 0x03	; 3
    1e82:	e8 16       	cp	r14, r24
    1e84:	41 f4       	brne	.+16     	; 0x1e96 <SetClock+0x158>
    {
        if (mode == HOUR)
    1e86:	80 91 6a 01 	lds	r24, 0x016A
    1e8a:	88 23       	and	r24, r24
    1e8c:	11 f4       	brne	.+4      	; 0x1e92 <SetClock+0x154>
            mode = SECOND;
    1e8e:	82 e0       	ldi	r24, 0x02	; 2
    1e90:	0d c0       	rjmp	.+26     	; 0x1eac <SetClock+0x16e>
        else
            mode--;
    1e92:	81 50       	subi	r24, 0x01	; 1
    1e94:	0b c0       	rjmp	.+22     	; 0x1eac <SetClock+0x16e>
    }
    else if (input == KEY_NEXT)
    1e96:	82 e0       	ldi	r24, 0x02	; 2
    1e98:	e8 16       	cp	r14, r24
    1e9a:	59 f4       	brne	.+22     	; 0x1eb2 <SetClock+0x174>
    {
        if (mode == SECOND)
    1e9c:	80 91 6a 01 	lds	r24, 0x016A
    1ea0:	82 30       	cpi	r24, 0x02	; 2
    1ea2:	19 f4       	brne	.+6      	; 0x1eaa <SetClock+0x16c>
            mode = HOUR;
    1ea4:	10 92 6a 01 	sts	0x016A, r1
    1ea8:	19 c0       	rjmp	.+50     	; 0x1edc <SetClock+0x19e>
        else
            mode++;
    1eaa:	8f 5f       	subi	r24, 0xFF	; 255
    1eac:	80 93 6a 01 	sts	0x016A, r24
    1eb0:	15 c0       	rjmp	.+42     	; 0x1edc <SetClock+0x19e>
    }
    else if (input == KEY_ENTER)
    1eb2:	81 e0       	ldi	r24, 0x01	; 1
    1eb4:	e8 16       	cp	r14, r24
    1eb6:	91 f4       	brne	.+36     	; 0x1edc <SetClock+0x19e>
    {
        // store the temporary adjusted values to the global variables
        cli(); // mt __disable_interrupt();
    1eb8:	f8 94       	cli
        gHOUR = time[HOUR];
    1eba:	80 91 6b 01 	lds	r24, 0x016B
    1ebe:	80 93 91 01 	sts	0x0191, r24
        gMINUTE = time[MINUTE];
    1ec2:	80 91 6c 01 	lds	r24, 0x016C
    1ec6:	80 93 97 01 	sts	0x0197, r24
        gSECOND = time[SECOND];
    1eca:	80 91 6d 01 	lds	r24, 0x016D
    1ece:	80 93 92 01 	sts	0x0192, r24
        sei(); // mt __enable_interrupt();
    1ed2:	78 94       	sei
        mode = HOUR;
    1ed4:	10 92 6a 01 	sts	0x016A, r1
    1ed8:	86 e1       	ldi	r24, 0x16	; 22
    1eda:	2a c0       	rjmp	.+84     	; 0x1f30 <SetClock+0x1f2>
        return ST_TIME_CLOCK_FUNC;
    }

    /* OPTIMIZE: Can be solved by using a modulo operation */
    if (time[HOUR] == 255)
    1edc:	80 91 6b 01 	lds	r24, 0x016B
    1ee0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ee2:	19 f4       	brne	.+6      	; 0x1eea <SetClock+0x1ac>
        time[HOUR] = 23;
    1ee4:	87 e1       	ldi	r24, 0x17	; 23
    1ee6:	80 93 6b 01 	sts	0x016B, r24
    if (time[HOUR] > 23)
    1eea:	80 91 6b 01 	lds	r24, 0x016B
    1eee:	88 31       	cpi	r24, 0x18	; 24
    1ef0:	10 f0       	brcs	.+4      	; 0x1ef6 <SetClock+0x1b8>
        time[HOUR] = 0;
    1ef2:	10 92 6b 01 	sts	0x016B, r1

    if (time[MINUTE] == 255)
    1ef6:	80 91 6c 01 	lds	r24, 0x016C
    1efa:	8f 3f       	cpi	r24, 0xFF	; 255
    1efc:	19 f4       	brne	.+6      	; 0x1f04 <SetClock+0x1c6>
        time[MINUTE] = 59;
    1efe:	8b e3       	ldi	r24, 0x3B	; 59
    1f00:	80 93 6c 01 	sts	0x016C, r24
    if (time[MINUTE] > 59)
    1f04:	80 91 6c 01 	lds	r24, 0x016C
    1f08:	8c 33       	cpi	r24, 0x3C	; 60
    1f0a:	10 f0       	brcs	.+4      	; 0x1f10 <SetClock+0x1d2>
        time[MINUTE] = 0;
    1f0c:	10 92 6c 01 	sts	0x016C, r1

    if (time[SECOND] == 255)
    1f10:	80 91 6d 01 	lds	r24, 0x016D
    1f14:	8f 3f       	cpi	r24, 0xFF	; 255
    1f16:	19 f4       	brne	.+6      	; 0x1f1e <SetClock+0x1e0>
        time[SECOND] = 59;
    1f18:	8b e3       	ldi	r24, 0x3B	; 59
    1f1a:	80 93 6d 01 	sts	0x016D, r24
    if (time[SECOND] > 59)
    1f1e:	80 91 6d 01 	lds	r24, 0x016D
    1f22:	8c 33       	cpi	r24, 0x3C	; 60
    1f24:	10 f0       	brcs	.+4      	; 0x1f2a <SetClock+0x1ec>
        time[SECOND] = 0;
    1f26:	10 92 6d 01 	sts	0x016D, r1

    enter_function = 0;
    1f2a:	10 92 56 01 	sts	0x0156, r1
    1f2e:	88 e1       	ldi	r24, 0x18	; 24
    return ST_TIME_CLOCK_ADJUST_FUNC;
}
    1f30:	1f 91       	pop	r17
    1f32:	0f 91       	pop	r16
    1f34:	ff 90       	pop	r15
    1f36:	ef 90       	pop	r14
    1f38:	08 95       	ret

00001f3a <ShowClock>:
*
*   Purpose :       Shows the clock on the LCD
*
*****************************************************************************/
char ShowClock(char input)
{
    1f3a:	bf 92       	push	r11
    1f3c:	cf 92       	push	r12
    1f3e:	df 92       	push	r13
    1f40:	ef 92       	push	r14
    1f42:	ff 92       	push	r15
    1f44:	0f 93       	push	r16
    1f46:	1f 93       	push	r17
    1f48:	b8 2e       	mov	r11, r24
    //char HH, HL, MH, ML, SH, SL;
    uint8_t HH, HL, MH, ML, SH, SL;

    if (clockformat == CLOCK_12)    // if 12H clock
    1f4a:	80 91 4b 01 	lds	r24, 0x014B
    1f4e:	88 23       	and	r24, r24
    1f50:	39 f4       	brne	.+14     	; 0x1f60 <ShowClock+0x26>
        HH = CHAR2BCD2(TBL_CLOCK_12[gHOUR]);   
    1f52:	e0 91 91 01 	lds	r30, 0x0191
    1f56:	f0 e0       	ldi	r31, 0x00	; 0
    1f58:	ed 5c       	subi	r30, 0xCD	; 205
    1f5a:	fe 4f       	sbci	r31, 0xFE	; 254
    1f5c:	80 81       	ld	r24, Z
    1f5e:	02 c0       	rjmp	.+4      	; 0x1f64 <ShowClock+0x2a>
    else
        HH = CHAR2BCD2(gHOUR);
    1f60:	80 91 91 01 	lds	r24, 0x0191
    1f64:	e5 d9       	rcall	.-3126   	; 0x1330 <CHAR2BCD2>
    1f66:	08 2f       	mov	r16, r24
        
    HL = (HH & 0x0F) + '0';
    HH = (HH >> 4) + '0';
    1f68:	18 2f       	mov	r17, r24
    1f6a:	12 95       	swap	r17
    1f6c:	1f 70       	andi	r17, 0x0F	; 15

    MH = CHAR2BCD2(gMINUTE);
    1f6e:	80 91 97 01 	lds	r24, 0x0197
    1f72:	de d9       	rcall	.-3140   	; 0x1330 <CHAR2BCD2>
    1f74:	c8 2e       	mov	r12, r24
    ML = (MH & 0x0F) + '0';
    MH = (MH >> 4) + '0';
    1f76:	e8 2e       	mov	r14, r24
    1f78:	e2 94       	swap	r14
    1f7a:	6f e0       	ldi	r22, 0x0F	; 15
    1f7c:	e6 22       	and	r14, r22

    SH = CHAR2BCD2(gSECOND);
    1f7e:	80 91 92 01 	lds	r24, 0x0192
    1f82:	d6 d9       	rcall	.-3156   	; 0x1330 <CHAR2BCD2>
    1f84:	f8 2e       	mov	r15, r24
    SL = (SH & 0x0F) + '0';
    SH = (SH >> 4) + '0';
    1f86:	d8 2e       	mov	r13, r24
    1f88:	d2 94       	swap	r13
    1f8a:	5f e0       	ldi	r21, 0x0F	; 15
    1f8c:	d5 22       	and	r13, r21

    LCD_putc(0, HH);
    1f8e:	10 5d       	subi	r17, 0xD0	; 208
    1f90:	80 e0       	ldi	r24, 0x00	; 0
    1f92:	61 2f       	mov	r22, r17
    1f94:	f2 d2       	rcall	.+1508   	; 0x257a <LCD_putc>
    LCD_putc(1, HL);
    1f96:	0f 70       	andi	r16, 0x0F	; 15
    1f98:	00 5d       	subi	r16, 0xD0	; 208
    1f9a:	81 e0       	ldi	r24, 0x01	; 1
    1f9c:	60 2f       	mov	r22, r16
    1f9e:	ed d2       	rcall	.+1498   	; 0x257a <LCD_putc>
    LCD_putc(2, MH);
    1fa0:	80 e3       	ldi	r24, 0x30	; 48
    1fa2:	e8 0e       	add	r14, r24
    1fa4:	82 e0       	ldi	r24, 0x02	; 2
    1fa6:	6e 2d       	mov	r22, r14
    1fa8:	e8 d2       	rcall	.+1488   	; 0x257a <LCD_putc>
    LCD_putc(3, ML);
    1faa:	8f e0       	ldi	r24, 0x0F	; 15
    1fac:	c8 22       	and	r12, r24
    1fae:	80 e3       	ldi	r24, 0x30	; 48
    1fb0:	c8 0e       	add	r12, r24
    1fb2:	83 e0       	ldi	r24, 0x03	; 3
    1fb4:	6c 2d       	mov	r22, r12
    1fb6:	e1 d2       	rcall	.+1474   	; 0x257a <LCD_putc>
    LCD_putc(4, SH);
    1fb8:	80 e3       	ldi	r24, 0x30	; 48
    1fba:	d8 0e       	add	r13, r24
    1fbc:	84 e0       	ldi	r24, 0x04	; 4
    1fbe:	6d 2d       	mov	r22, r13
    1fc0:	dc d2       	rcall	.+1464   	; 0x257a <LCD_putc>
    LCD_putc(5, SL);
    1fc2:	8f e0       	ldi	r24, 0x0F	; 15
    1fc4:	f8 22       	and	r15, r24
    1fc6:	80 e3       	ldi	r24, 0x30	; 48
    1fc8:	f8 0e       	add	r15, r24
    1fca:	85 e0       	ldi	r24, 0x05	; 5
    1fcc:	6f 2d       	mov	r22, r15
    1fce:	d5 d2       	rcall	.+1450   	; 0x257a <LCD_putc>
    LCD_putc(6, '\0');
    1fd0:	86 e0       	ldi	r24, 0x06	; 6
    1fd2:	60 e0       	ldi	r22, 0x00	; 0
    1fd4:	d2 d2       	rcall	.+1444   	; 0x257a <LCD_putc>

    LCD_Colon(1);
    1fd6:	81 e0       	ldi	r24, 0x01	; 1
    1fd8:	e6 d2       	rcall	.+1484   	; 0x25a6 <LCD_Colon>

    LCD_UpdateRequired(TRUE, 0);
    1fda:	81 e0       	ldi	r24, 0x01	; 1
    1fdc:	60 e0       	ldi	r22, 0x00	; 0
    1fde:	e6 d2       	rcall	.+1484   	; 0x25ac <LCD_UpdateRequired>

    if (input == KEY_PREV)
    1fe0:	83 e0       	ldi	r24, 0x03	; 3
    1fe2:	b8 16       	cp	r11, r24
    1fe4:	11 f4       	brne	.+4      	; 0x1fea <ShowClock+0xb0>
    1fe6:	85 e1       	ldi	r24, 0x15	; 21
    1fe8:	06 c0       	rjmp	.+12     	; 0x1ff6 <ShowClock+0xbc>
        return ST_TIME_CLOCK;
    else if (input == KEY_NEXT)
    1fea:	82 e0       	ldi	r24, 0x02	; 2
    1fec:	b8 16       	cp	r11, r24
    1fee:	11 f0       	breq	.+4      	; 0x1ff4 <ShowClock+0xba>
    1ff0:	86 e1       	ldi	r24, 0x16	; 22
    1ff2:	01 c0       	rjmp	.+2      	; 0x1ff6 <ShowClock+0xbc>
    1ff4:	87 e1       	ldi	r24, 0x17	; 23
        return ST_TIME_CLOCK_ADJUST;
      
    return ST_TIME_CLOCK_FUNC;
}
    1ff6:	1f 91       	pop	r17
    1ff8:	0f 91       	pop	r16
    1ffa:	ff 90       	pop	r15
    1ffc:	ef 90       	pop	r14
    1ffe:	df 90       	pop	r13
    2000:	cf 90       	pop	r12
    2002:	bf 90       	pop	r11
    2004:	08 95       	ret

00002006 <RTC_init>:
*                   32.768kHz crystal.
*
*******************************************************************************/
void RTC_init(void)
{
    Delay(1000);            // wait for 1 sec to let the Xtal stabilize after a power-on,
    2006:	88 ee       	ldi	r24, 0xE8	; 232
    2008:	93 e0       	ldi	r25, 0x03	; 3
    200a:	0e 94 23 06 	call	0xc46	; 0xc46 <Delay>

    cli(); // mt __disable_interrupt();  // disabel global interrupt
    200e:	f8 94       	cli

    cbiBF(TIMSK2, TOIE2);             // disable OCIE2A and TOIE2
    2010:	80 91 70 00 	lds	r24, 0x0070
    2014:	8e 7f       	andi	r24, 0xFE	; 254
    2016:	80 93 70 00 	sts	0x0070, r24

    ASSR = (1<<AS2);        // select asynchronous operation of Timer2
    201a:	88 e0       	ldi	r24, 0x08	; 8
    201c:	80 93 b6 00 	sts	0x00B6, r24

    TCNT2 = 0;              // clear TCNT2A
    2020:	10 92 b2 00 	sts	0x00B2, r1
    TCCR2A |= (1<<CS22) | (1<<CS20);             // select precaler: 32.768 kHz / 128 = 1 sec between each overflow
    2024:	80 91 b0 00 	lds	r24, 0x00B0
    2028:	85 60       	ori	r24, 0x05	; 5
    202a:	80 93 b0 00 	sts	0x00B0, r24

    while((ASSR & 0x01) | (ASSR & 0x04));       // wait for TCN2UB and TCR2UB to be cleared
    202e:	20 91 b6 00 	lds	r18, 0x00B6
    2032:	80 91 b6 00 	lds	r24, 0x00B6
    2036:	90 e0       	ldi	r25, 0x00	; 0
    2038:	84 70       	andi	r24, 0x04	; 4
    203a:	90 70       	andi	r25, 0x00	; 0
    203c:	30 e0       	ldi	r19, 0x00	; 0
    203e:	21 70       	andi	r18, 0x01	; 1
    2040:	30 70       	andi	r19, 0x00	; 0
    2042:	82 2b       	or	r24, r18
    2044:	93 2b       	or	r25, r19
    2046:	89 2b       	or	r24, r25
    2048:	91 f7       	brne	.-28     	; 0x202e <RTC_init+0x28>

    TIFR2 = 0xFF;           // clear interrupt-flags
    204a:	8f ef       	ldi	r24, 0xFF	; 255
    204c:	87 bb       	out	0x17, r24	; 23
    sbiBF(TIMSK2, TOIE2);     // enable Timer2 overflow interrupt
    204e:	80 91 70 00 	lds	r24, 0x0070
    2052:	81 60       	ori	r24, 0x01	; 1
    2054:	80 93 70 00 	sts	0x0070, r24

    sei(); // mt __enable_interrupt();                 // enable global interrupt
    2058:	78 94       	sei

    // initial time and date setting
    gSECOND  = 0;
    205a:	10 92 92 01 	sts	0x0192, r1
    gMINUTE  = 0;
    205e:	10 92 97 01 	sts	0x0197, r1
    gHOUR    = 12;
    2062:	8c e0       	ldi	r24, 0x0C	; 12
    2064:	80 93 91 01 	sts	0x0191, r24
    // mt release timestamp
    gDAY     = 12;
    2068:	80 93 93 01 	sts	0x0193, r24
    gMONTH   = 3;
    206c:	83 e0       	ldi	r24, 0x03	; 3
    206e:	80 93 96 01 	sts	0x0196, r24
    gYEAR    = 9;
    2072:	89 e0       	ldi	r24, 0x09	; 9
    2074:	90 e0       	ldi	r25, 0x00	; 0
    2076:	90 93 95 01 	sts	0x0195, r25
    207a:	80 93 94 01 	sts	0x0194, r24
}
    207e:	08 95       	ret

00002080 <DF_SPI_init>:
void DF_SPI_init (void)
{
	// mtA
	// PORTB |= (1<<PORTB3) | (1<<PORTB2) | (1<<PORTB1) | (1<<PORTB0);
	// DDRB |= (1<<PORTB2) | (1<<PORTB1) | (1<<PORTB0);		//Set MOSI, SCK AND SS as outputs
	PORTB |= (1<<PB3) | (1<<PB2) | (1<<PB1) | (1<<PB0);
    2080:	85 b1       	in	r24, 0x05	; 5
    2082:	8f 60       	ori	r24, 0x0F	; 15
    2084:	85 b9       	out	0x05, r24	; 5
	DDRB |= (1<<DDB2) | (1<<DDB1) | (1<<DDB0);		//Set MOSI, SCK AND SS as outputs
    2086:	84 b1       	in	r24, 0x04	; 4
    2088:	87 60       	ori	r24, 0x07	; 7
    208a:	84 b9       	out	0x04, r24	; 4
	// mtE
	SPSR = (1<<SPI2X);                                      //SPI double speed settings
    208c:	81 e0       	ldi	r24, 0x01	; 1
    208e:	8d bd       	out	0x2d, r24	; 45
	SPCR = (1<<SPE) | (1<<MSTR) | (1<<CPHA) | (1<<CPOL);	//Enable SPI in Master mode, mode 3, Fosc/4
    2090:	8c e5       	ldi	r24, 0x5C	; 92
    2092:	8c bd       	out	0x2c, r24	; 44
// mt: the following line was already commented out in the original code
//	SPCR = (1<<SPE) | (1<<MSTR) | (1<<CPHA) | (1<<CPOL) | (1<<SPR1) | (1<<SPR0);	//Enable SPI in Master mode, mode 3, Fosc/2
}
    2094:	08 95       	ret

00002096 <DF_SPI_RW>:
******************************************************************************/
unsigned char DF_SPI_RW (unsigned char output)
{
	unsigned char input;
	
	SPDR = output;							//put byte 'output' in SPI data register
    2096:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & 0x80));					//wait for transfer complete, poll SPIF-flag
    2098:	0d b4       	in	r0, 0x2d	; 45
    209a:	07 fe       	sbrs	r0, 7
    209c:	fd cf       	rjmp	.-6      	; 0x2098 <DF_SPI_RW+0x2>
	input = SPDR;							//read value in SPI data reg.
    209e:	8e b5       	in	r24, 0x2e	; 46
	
	return input;							//return the byte clocked in from SPI slave
}
    20a0:	08 95       	ret

000020a2 <Read_DF_status>:
******************************************************************************/
unsigned char Read_DF_status (void)
{
	unsigned char result,index_copy;
	
	DF_CS_inactive;							//make sure to toggle CS signal in order
    20a2:	28 9a       	sbi	0x05, 0	; 5
	DF_CS_active;							//to reset dataflash command decoder
    20a4:	28 98       	cbi	0x05, 0	; 5
	result = DF_SPI_RW(StatusReg);			//send status register read op-code
    20a6:	87 e5       	ldi	r24, 0x57	; 87
    20a8:	f6 df       	rcall	.-20     	; 0x2096 <DF_SPI_RW>
	result = DF_SPI_RW(0x00);				//dummy write to get result
    20aa:	80 e0       	ldi	r24, 0x00	; 0
    20ac:	f4 df       	rcall	.-24     	; 0x2096 <DF_SPI_RW>
	index_copy = ((result & 0x38) >> 3);	//get the size info from status register
	// mtA
	/// if (!PageBits) { // mt 200401
		// PageBits   = DF_pagebits[index_copy];	//get number of internal page address bits from look-up table
		// PageSize   = DF_pagesize[index_copy];   //get the size of the page (in bytes)
		PageBits   = pgm_read_byte(&DF_pagebits[index_copy]);	//get number of internal page address bits from look-up table
    20ae:	28 2f       	mov	r18, r24
    20b0:	30 e0       	ldi	r19, 0x00	; 0
    20b2:	28 73       	andi	r18, 0x38	; 56
    20b4:	30 70       	andi	r19, 0x00	; 0
    20b6:	43 e0       	ldi	r20, 0x03	; 3
    20b8:	36 95       	lsr	r19
    20ba:	27 95       	ror	r18
    20bc:	4a 95       	dec	r20
    20be:	e1 f7       	brne	.-8      	; 0x20b8 <Read_DF_status+0x16>
    20c0:	f9 01       	movw	r30, r18
    20c2:	e4 5a       	subi	r30, 0xA4	; 164
    20c4:	fa 4f       	sbci	r31, 0xFA	; 250
    20c6:	e4 91       	lpm	r30, Z+
    20c8:	e0 93 6e 01 	sts	0x016E, r30
		PageSize   = pgm_read_word(&DF_pagesize[index_copy]);   //get the size of the page (in bytes)
    20cc:	f9 01       	movw	r30, r18
    20ce:	ee 0f       	add	r30, r30
    20d0:	ff 1f       	adc	r31, r31
    20d2:	ec 59       	subi	r30, 0x9C	; 156
    20d4:	fa 4f       	sbci	r31, 0xFA	; 250
    20d6:	25 91       	lpm	r18, Z+
    20d8:	34 91       	lpm	r19, Z+
    20da:	30 93 70 01 	sts	0x0170, r19
    20de:	20 93 6f 01 	sts	0x016F, r18
	/// }
	// mtE
	return result;							//return the read status register value
}
    20e2:	08 95       	ret

000020e4 <Buffer_Write_Byte>:
*	Purpose :		Writes one byte to one of the dataflash
*					internal SRAM buffers
*
******************************************************************************/
void Buffer_Write_Byte (unsigned char BufferNo, unsigned int IntPageAdr, unsigned char Data)
{
    20e4:	1f 93       	push	r17
    20e6:	cf 93       	push	r28
    20e8:	df 93       	push	r29
    20ea:	eb 01       	movw	r28, r22
    20ec:	14 2f       	mov	r17, r20
	
	DF_CS_inactive;								//make sure to toggle CS signal in order
    20ee:	28 9a       	sbi	0x05, 0	; 5
	DF_CS_active;								//to reset dataflash command decoder
    20f0:	28 98       	cbi	0x05, 0	; 5
	
	if (1 == BufferNo)							//write byte to buffer 1
    20f2:	81 30       	cpi	r24, 0x01	; 1
    20f4:	59 f4       	brne	.+22     	; 0x210c <Buffer_Write_Byte+0x28>
	{
		DF_SPI_RW(Buf1Write);					//buffer 1 write op-code
    20f6:	84 e8       	ldi	r24, 0x84	; 132
    20f8:	ce df       	rcall	.-100    	; 0x2096 <DF_SPI_RW>
		DF_SPI_RW(0x00);						//don't cares
    20fa:	80 e0       	ldi	r24, 0x00	; 0
    20fc:	cc df       	rcall	.-104    	; 0x2096 <DF_SPI_RW>
		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
    20fe:	8d 2f       	mov	r24, r29
    2100:	99 27       	eor	r25, r25
    2102:	c9 df       	rcall	.-110    	; 0x2096 <DF_SPI_RW>
		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
    2104:	8c 2f       	mov	r24, r28
    2106:	c7 df       	rcall	.-114    	; 0x2096 <DF_SPI_RW>
		DF_SPI_RW(Data);						//write data byte
    2108:	81 2f       	mov	r24, r17
    210a:	c5 df       	rcall	.-118    	; 0x2096 <DF_SPI_RW>
		DF_SPI_RW((unsigned char)(IntPageAdr>>8));//upper part of internal buffer address
		DF_SPI_RW((unsigned char)(IntPageAdr));	//lower part of internal buffer address
		DF_SPI_RW(Data);						//write data byte
	}		
#endif
}
    210c:	df 91       	pop	r29
    210e:	cf 91       	pop	r28
    2110:	1f 91       	pop	r17
    2112:	08 95       	ret

00002114 <Buffer_To_Page>:
*
*	Purpose :		Transfers a page from dataflash SRAM buffer to flash
*					
******************************************************************************/
void Buffer_To_Page (unsigned char BufferNo, unsigned int PageAdr)
{
    2114:	cf 93       	push	r28
    2116:	df 93       	push	r29
    2118:	eb 01       	movw	r28, r22
	DF_CS_inactive;												//make sure to toggle CS signal in order
    211a:	28 9a       	sbi	0x05, 0	; 5
	DF_CS_active;												//to reset dataflash command decoder
    211c:	28 98       	cbi	0x05, 0	; 5
		
	if (1 == BufferNo)											//program flash page from buffer 1
    211e:	81 30       	cpi	r24, 0x01	; 1
    2120:	e9 f4       	brne	.+58     	; 0x215c <Buffer_To_Page+0x48>
	{
		DF_SPI_RW(Buf1ToFlashWE);								//buffer 1 to flash with erase op-code
    2122:	83 e8       	ldi	r24, 0x83	; 131
    2124:	b8 df       	rcall	.-144    	; 0x2096 <DF_SPI_RW>
		DF_SPI_RW((unsigned char)(PageAdr >> (16 - PageBits)));	//upper part of page address
    2126:	20 91 6e 01 	lds	r18, 0x016E
    212a:	80 e1       	ldi	r24, 0x10	; 16
    212c:	90 e0       	ldi	r25, 0x00	; 0
    212e:	82 1b       	sub	r24, r18
    2130:	91 09       	sbc	r25, r1
    2132:	9e 01       	movw	r18, r28
    2134:	02 c0       	rjmp	.+4      	; 0x213a <Buffer_To_Page+0x26>
    2136:	36 95       	lsr	r19
    2138:	27 95       	ror	r18
    213a:	8a 95       	dec	r24
    213c:	e2 f7       	brpl	.-8      	; 0x2136 <Buffer_To_Page+0x22>
    213e:	c9 01       	movw	r24, r18
    2140:	aa df       	rcall	.-172    	; 0x2096 <DF_SPI_RW>
		DF_SPI_RW((unsigned char)(PageAdr << (PageBits - 8)));	//lower part of page address
    2142:	80 91 6e 01 	lds	r24, 0x016E
    2146:	90 e0       	ldi	r25, 0x00	; 0
    2148:	08 97       	sbiw	r24, 0x08	; 8
    214a:	02 c0       	rjmp	.+4      	; 0x2150 <Buffer_To_Page+0x3c>
    214c:	cc 0f       	add	r28, r28
    214e:	dd 1f       	adc	r29, r29
    2150:	8a 95       	dec	r24
    2152:	e2 f7       	brpl	.-8      	; 0x214c <Buffer_To_Page+0x38>
    2154:	8c 2f       	mov	r24, r28
    2156:	9f df       	rcall	.-194    	; 0x2096 <DF_SPI_RW>
		DF_SPI_RW(0x00);										//don't cares
    2158:	80 e0       	ldi	r24, 0x00	; 0
    215a:	9d df       	rcall	.-198    	; 0x2096 <DF_SPI_RW>
		DF_SPI_RW((unsigned char)(PageAdr << (PageBits - 8)));	//lower part of page address
		DF_SPI_RW(0x00);										//don't cares
	}
#endif
	
	DF_CS_inactive;												//initiate flash page programming
    215c:	28 9a       	sbi	0x05, 0	; 5
	DF_CS_active;												
    215e:	28 98       	cbi	0x05, 0	; 5
	
	while(!(Read_DF_status() & 0x80));							//monitor the status register, wait until busy-flag is high
    2160:	a0 df       	rcall	.-192    	; 0x20a2 <Read_DF_status>
    2162:	87 ff       	sbrs	r24, 7
    2164:	fd cf       	rjmp	.-6      	; 0x2160 <Buffer_To_Page+0x4c>
}
    2166:	df 91       	pop	r29
    2168:	cf 91       	pop	r28
    216a:	08 95       	ret

0000216c <Cont_Flash_Read_Enable>:
*
*	Purpose :		Initiates a continuous read from a location in the DataFlash
*
******************************************************************************/
void Cont_Flash_Read_Enable (unsigned int PageAdr, unsigned int IntPageAdr)
{
    216c:	ef 92       	push	r14
    216e:	ff 92       	push	r15
    2170:	0f 93       	push	r16
    2172:	1f 93       	push	r17
    2174:	8c 01       	movw	r16, r24
    2176:	7b 01       	movw	r14, r22
	DF_CS_inactive;																//make sure to toggle CS signal in order
    2178:	28 9a       	sbi	0x05, 0	; 5
	DF_CS_active;																//to reset dataflash command decoder
    217a:	28 98       	cbi	0x05, 0	; 5
	
	DF_SPI_RW(ContArrayRead);													//Continuous Array Read op-code
    217c:	88 e6       	ldi	r24, 0x68	; 104
    217e:	8b df       	rcall	.-234    	; 0x2096 <DF_SPI_RW>
	DF_SPI_RW((unsigned char)(PageAdr >> (16 - PageBits)));						//upper part of page address
    2180:	20 91 6e 01 	lds	r18, 0x016E
    2184:	80 e1       	ldi	r24, 0x10	; 16
    2186:	90 e0       	ldi	r25, 0x00	; 0
    2188:	82 1b       	sub	r24, r18
    218a:	91 09       	sbc	r25, r1
    218c:	98 01       	movw	r18, r16
    218e:	02 c0       	rjmp	.+4      	; 0x2194 <Cont_Flash_Read_Enable+0x28>
    2190:	36 95       	lsr	r19
    2192:	27 95       	ror	r18
    2194:	8a 95       	dec	r24
    2196:	e2 f7       	brpl	.-8      	; 0x2190 <Cont_Flash_Read_Enable+0x24>
    2198:	c9 01       	movw	r24, r18
    219a:	7d df       	rcall	.-262    	; 0x2096 <DF_SPI_RW>
	DF_SPI_RW((unsigned char)((PageAdr << (PageBits - 8))+ (IntPageAdr>>8)));	//lower part of page address and MSB of int.page adr.
    219c:	8f 2d       	mov	r24, r15
    219e:	99 27       	eor	r25, r25
    21a0:	20 91 6e 01 	lds	r18, 0x016E
    21a4:	30 e0       	ldi	r19, 0x00	; 0
    21a6:	28 50       	subi	r18, 0x08	; 8
    21a8:	30 40       	sbci	r19, 0x00	; 0
    21aa:	02 c0       	rjmp	.+4      	; 0x21b0 <Cont_Flash_Read_Enable+0x44>
    21ac:	00 0f       	add	r16, r16
    21ae:	11 1f       	adc	r17, r17
    21b0:	2a 95       	dec	r18
    21b2:	e2 f7       	brpl	.-8      	; 0x21ac <Cont_Flash_Read_Enable+0x40>
    21b4:	80 0f       	add	r24, r16
    21b6:	6f df       	rcall	.-290    	; 0x2096 <DF_SPI_RW>
	DF_SPI_RW((unsigned char)(IntPageAdr));										//LSB byte of internal page address
    21b8:	8e 2d       	mov	r24, r14
    21ba:	6d df       	rcall	.-294    	; 0x2096 <DF_SPI_RW>
	DF_SPI_RW(0x00);															//perform 4 dummy writes
    21bc:	80 e0       	ldi	r24, 0x00	; 0
    21be:	6b df       	rcall	.-298    	; 0x2096 <DF_SPI_RW>
	DF_SPI_RW(0x00);															//in order to intiate DataFlash
    21c0:	80 e0       	ldi	r24, 0x00	; 0
    21c2:	69 df       	rcall	.-302    	; 0x2096 <DF_SPI_RW>
	DF_SPI_RW(0x00);															//address pointers
    21c4:	80 e0       	ldi	r24, 0x00	; 0
    21c6:	67 df       	rcall	.-306    	; 0x2096 <DF_SPI_RW>
	DF_SPI_RW(0x00);
    21c8:	80 e0       	ldi	r24, 0x00	; 0
    21ca:	65 df       	rcall	.-310    	; 0x2096 <DF_SPI_RW>
}
    21cc:	1f 91       	pop	r17
    21ce:	0f 91       	pop	r16
    21d0:	ff 90       	pop	r15
    21d2:	ef 90       	pop	r14
    21d4:	08 95       	ret

000021d6 <getkey>:
*****************************************************************************/
char getkey(void)
{
    char k;

    cli(); // mt: __disable_interrupt();
    21d6:	f8 94       	cli

    if (KEY_VALID)              // Check for unread key in buffer
    21d8:	80 91 73 01 	lds	r24, 0x0173
    21dc:	88 23       	and	r24, r24
    21de:	21 f0       	breq	.+8      	; 0x21e8 <getkey+0x12>
    {
        k = KEY;
    21e0:	80 91 72 01 	lds	r24, 0x0172
        KEY_VALID = FALSE;
    21e4:	10 92 73 01 	sts	0x0173, r1
    }
    else
        k = KEY_NULL;           // No key stroke available

    sei(); // mt: __enable_interrupt();
    21e8:	78 94       	sei

    return k;
}
    21ea:	08 95       	ret

000021ec <PinChangeInterrupt>:
    PORTB | PORTE   B   A       O   D   C
    =============================================
*/


    buttons = (~PINB) & PINB_MASK;
    21ec:	83 b1       	in	r24, 0x03	; 3
    buttons |= (~PINE) & PINE_MASK;
    21ee:	2c b1       	in	r18, 0x0c	; 12
    21f0:	20 95       	com	r18
    21f2:	2c 70       	andi	r18, 0x0C	; 12
    21f4:	80 95       	com	r24
    21f6:	80 7d       	andi	r24, 0xD0	; 208
    21f8:	28 2b       	or	r18, r24

    // Output virtual keys
    if (buttons & (1<<BUTTON_A))
    21fa:	26 ff       	sbrs	r18, 6
    21fc:	02 c0       	rjmp	.+4      	; 0x2202 <PinChangeInterrupt+0x16>
    21fe:	94 e0       	ldi	r25, 0x04	; 4
    2200:	0f c0       	rjmp	.+30     	; 0x2220 <PinChangeInterrupt+0x34>
        key = KEY_PLUS;
    else if (buttons & (1<<BUTTON_B))
    2202:	27 ff       	sbrs	r18, 7
    2204:	02 c0       	rjmp	.+4      	; 0x220a <PinChangeInterrupt+0x1e>
    2206:	95 e0       	ldi	r25, 0x05	; 5
    2208:	0b c0       	rjmp	.+22     	; 0x2220 <PinChangeInterrupt+0x34>
        key = KEY_MINUS;
    else if (buttons & (1<<BUTTON_C))
    220a:	22 ff       	sbrs	r18, 2
    220c:	02 c0       	rjmp	.+4      	; 0x2212 <PinChangeInterrupt+0x26>
    220e:	93 e0       	ldi	r25, 0x03	; 3
    2210:	07 c0       	rjmp	.+14     	; 0x2220 <PinChangeInterrupt+0x34>
        key = KEY_PREV;
    else if (buttons & (1<<BUTTON_D))
    2212:	23 ff       	sbrs	r18, 3
    2214:	02 c0       	rjmp	.+4      	; 0x221a <PinChangeInterrupt+0x2e>
    2216:	92 e0       	ldi	r25, 0x02	; 2
    2218:	03 c0       	rjmp	.+6      	; 0x2220 <PinChangeInterrupt+0x34>
        key = KEY_NEXT;
    else if (buttons & (1<<BUTTON_O))
    221a:	24 ff       	sbrs	r18, 4
    221c:	15 c0       	rjmp	.+42     	; 0x2248 <PinChangeInterrupt+0x5c>
    221e:	91 e0       	ldi	r25, 0x01	; 1
        key = KEY_NULL;

    
    if(key != KEY_NULL)
    {
        if(gButtonTimeout)  // gButtonTimeout is set in the LCD_SOF_interrupt in LCD_driver.c
    2220:	80 91 71 01 	lds	r24, 0x0171
    2224:	88 23       	and	r24, r24
    2226:	81 f0       	breq	.+32     	; 0x2248 <PinChangeInterrupt+0x5c>
        {
            if (!KEY_VALID)
    2228:	80 91 73 01 	lds	r24, 0x0173
    222c:	88 23       	and	r24, r24
    222e:	51 f4       	brne	.+20     	; 0x2244 <PinChangeInterrupt+0x58>
            {
                KEY = key;          // Store key in global key buffer
    2230:	90 93 72 01 	sts	0x0172, r25
                KEY_VALID = TRUE;
    2234:	81 e0       	ldi	r24, 0x01	; 1
    2236:	80 93 73 01 	sts	0x0173, r24
                if (gKeyClickStatus)
    223a:	80 91 62 01 	lds	r24, 0x0162
    223e:	88 23       	and	r24, r24
    2240:	09 f0       	breq	.+2      	; 0x2244 <PinChangeInterrupt+0x58>
                  PlayClick();
    2242:	5c d3       	rcall	.+1720   	; 0x28fc <PlayClick>
            }

         gButtonTimeout = FALSE;
    2244:	10 92 71 01 	sts	0x0171, r1
    
        }
    }
    
    EIFR = (1<<PCIF1) | (1<<PCIF0);     // Delete pin change interrupt flags
    2248:	80 ec       	ldi	r24, 0xC0	; 192
    224a:	8c bb       	out	0x1c, r24	; 28

    gPowerSaveTimer = 0;                // Reset the Auto Power Down timer
    224c:	10 92 64 01 	sts	0x0164, r1
    
}
    2250:	08 95       	ret

00002252 <__vector_3>:
// mtA
// #pragma vector = PCINT1_vect
// __interrupt void PCINT1_interrupt(void)
// mtE
ISR(PCINT1_vect)
{
    2252:	1f 92       	push	r1
    2254:	0f 92       	push	r0
    2256:	0f b6       	in	r0, 0x3f	; 63
    2258:	0f 92       	push	r0
    225a:	11 24       	eor	r1, r1
    225c:	2f 93       	push	r18
    225e:	3f 93       	push	r19
    2260:	4f 93       	push	r20
    2262:	5f 93       	push	r21
    2264:	6f 93       	push	r22
    2266:	7f 93       	push	r23
    2268:	8f 93       	push	r24
    226a:	9f 93       	push	r25
    226c:	af 93       	push	r26
    226e:	bf 93       	push	r27
    2270:	ef 93       	push	r30
    2272:	ff 93       	push	r31
    PinChangeInterrupt();
    2274:	bb df       	rcall	.-138    	; 0x21ec <PinChangeInterrupt>
}
    2276:	ff 91       	pop	r31
    2278:	ef 91       	pop	r30
    227a:	bf 91       	pop	r27
    227c:	af 91       	pop	r26
    227e:	9f 91       	pop	r25
    2280:	8f 91       	pop	r24
    2282:	7f 91       	pop	r23
    2284:	6f 91       	pop	r22
    2286:	5f 91       	pop	r21
    2288:	4f 91       	pop	r20
    228a:	3f 91       	pop	r19
    228c:	2f 91       	pop	r18
    228e:	0f 90       	pop	r0
    2290:	0f be       	out	0x3f, r0	; 63
    2292:	0f 90       	pop	r0
    2294:	1f 90       	pop	r1
    2296:	18 95       	reti

00002298 <__vector_2>:

// #pragma vector = PCINT0_vect
// __interrupt void PCINT0_interrupt(void)
ISR(PCINT0_vect)
// mtE
{
    2298:	1f 92       	push	r1
    229a:	0f 92       	push	r0
    229c:	0f b6       	in	r0, 0x3f	; 63
    229e:	0f 92       	push	r0
    22a0:	11 24       	eor	r1, r1
    22a2:	2f 93       	push	r18
    22a4:	3f 93       	push	r19
    22a6:	4f 93       	push	r20
    22a8:	5f 93       	push	r21
    22aa:	6f 93       	push	r22
    22ac:	7f 93       	push	r23
    22ae:	8f 93       	push	r24
    22b0:	9f 93       	push	r25
    22b2:	af 93       	push	r26
    22b4:	bf 93       	push	r27
    22b6:	ef 93       	push	r30
    22b8:	ff 93       	push	r31
    PinChangeInterrupt();
    22ba:	98 df       	rcall	.-208    	; 0x21ec <PinChangeInterrupt>
}
    22bc:	ff 91       	pop	r31
    22be:	ef 91       	pop	r30
    22c0:	bf 91       	pop	r27
    22c2:	af 91       	pop	r26
    22c4:	9f 91       	pop	r25
    22c6:	8f 91       	pop	r24
    22c8:	7f 91       	pop	r23
    22ca:	6f 91       	pop	r22
    22cc:	5f 91       	pop	r21
    22ce:	4f 91       	pop	r20
    22d0:	3f 91       	pop	r19
    22d2:	2f 91       	pop	r18
    22d4:	0f 90       	pop	r0
    22d6:	0f be       	out	0x3f, r0	; 63
    22d8:	0f 90       	pop	r0
    22da:	1f 90       	pop	r1
    22dc:	18 95       	reti

000022de <Button_Init>:
*
*****************************************************************************/
void Button_Init(void)
{
    // Init port pins
    cbiBF(DDRB,7);
    22de:	27 98       	cbi	0x04, 7	; 4
    cbiBF(DDRB,6);
    22e0:	26 98       	cbi	0x04, 6	; 4
    cbiBF(DDRB,4);
    22e2:	24 98       	cbi	0x04, 4	; 4
    PORTB |= PINB_MASK;
    22e4:	85 b1       	in	r24, 0x05	; 5
    22e6:	80 6d       	ori	r24, 0xD0	; 208
    22e8:	85 b9       	out	0x05, r24	; 5
    DDRE = 0x00;
    22ea:	1d b8       	out	0x0d, r1	; 13
    PORTE |= PINE_MASK;
    22ec:	8e b1       	in	r24, 0x0e	; 14
    22ee:	8c 60       	ori	r24, 0x0C	; 12
    22f0:	8e b9       	out	0x0e, r24	; 14

    // Enable pin change interrupt on PORTB and PORTE
    PCMSK0 = PINE_MASK;
    22f2:	8c e0       	ldi	r24, 0x0C	; 12
    22f4:	80 93 6b 00 	sts	0x006B, r24
    PCMSK1 = PINB_MASK;
    22f8:	80 ed       	ldi	r24, 0xD0	; 208
    22fa:	80 93 6c 00 	sts	0x006C, r24
    EIFR = (1<<PCIF0)|(1<<PCIF1);
    22fe:	80 ec       	ldi	r24, 0xC0	; 192
    2300:	8c bb       	out	0x1c, r24	; 28
    EIMSK = (1<<PCIE0)|(1<<PCIE1);
    2302:	8d bb       	out	0x1d, r24	; 29

    CountdownTimerHandle = Timer0_AllocateCountdownTimer();
    2304:	02 d8       	rcall	.-4092   	; 0x130a <Timer0_AllocateCountdownTimer>
    2306:	80 93 98 01 	sts	0x0198, r24
}
    230a:	08 95       	ret

0000230c <shiftIn>:

//based on Arduino impl in wiring_shift.c
char shiftIn() {
	char value = 0;
	char i;
	__asm__ __volatile__ ("nop");
    230c:	00 00       	nop
	__asm__ __volatile__ ("nop");
    230e:	00 00       	nop
    2310:	40 e0       	ldi	r20, 0x00	; 0
    2312:	27 e0       	ldi	r18, 0x07	; 7
    2314:	30 e0       	ldi	r19, 0x00	; 0
	for (i = 0; i < 8; ++i) {
		HX711_POUT |= 1<<HX711_CK;
		__asm__ __volatile__ ("nop");
		__asm__ __volatile__ ("nop");
		if(HX711_PIN & 1<<HX711_IN)
			value |= 1 << (7 - i);
    2316:	61 e0       	ldi	r22, 0x01	; 1
    2318:	70 e0       	ldi	r23, 0x00	; 0
	char i;
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");

	for (i = 0; i < 8; ++i) {
		HX711_POUT |= 1<<HX711_CK;
    231a:	76 9a       	sbi	0x0e, 6	; 14
		__asm__ __volatile__ ("nop");
    231c:	00 00       	nop
		__asm__ __volatile__ ("nop");
    231e:	00 00       	nop
		if(HX711_PIN & 1<<HX711_IN)
    2320:	65 9b       	sbis	0x0c, 5	; 12
    2322:	08 c0       	rjmp	.+16     	; 0x2334 <shiftIn+0x28>
			value |= 1 << (7 - i);
    2324:	cb 01       	movw	r24, r22
    2326:	02 2e       	mov	r0, r18
    2328:	02 c0       	rjmp	.+4      	; 0x232e <shiftIn+0x22>
    232a:	88 0f       	add	r24, r24
    232c:	99 1f       	adc	r25, r25
    232e:	0a 94       	dec	r0
    2330:	e2 f7       	brpl	.-8      	; 0x232a <shiftIn+0x1e>
    2332:	48 2b       	or	r20, r24
		HX711_POUT &= ~(1<<HX711_CK);
    2334:	76 98       	cbi	0x0e, 6	; 14
		__asm__ __volatile__ ("nop");
    2336:	00 00       	nop
		__asm__ __volatile__ ("nop");
    2338:	00 00       	nop
    233a:	21 50       	subi	r18, 0x01	; 1
    233c:	30 40       	sbci	r19, 0x00	; 0
	char value = 0;
	char i;
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");

	for (i = 0; i < 8; ++i) {
    233e:	8f ef       	ldi	r24, 0xFF	; 255
    2340:	2f 3f       	cpi	r18, 0xFF	; 255
    2342:	38 07       	cpc	r19, r24
    2344:	51 f7       	brne	.-44     	; 0x231a <shiftIn+0xe>
		HX711_POUT &= ~(1<<HX711_CK);
		__asm__ __volatile__ ("nop");
		__asm__ __volatile__ ("nop");
	}
	return value;
}
    2346:	84 2f       	mov	r24, r20
    2348:	08 95       	ret

0000234a <HX711_is_ready>:

	HX711_set_gain(gain);
}

char HX711_is_ready() {
	return !(HX711_PIN & 1<<HX711_IN);
    234a:	8c b1       	in	r24, 0x0c	; 12
    234c:	82 95       	swap	r24
    234e:	86 95       	lsr	r24
    2350:	87 70       	andi	r24, 0x07	; 7
    2352:	80 95       	com	r24
}
    2354:	81 70       	andi	r24, 0x01	; 1
    2356:	08 95       	ret

00002358 <HX711_read>:

	HX711_POUT &= ~(1<<HX711_CK);
	HX711_read();
}

long HX711_read() {
    2358:	0f 93       	push	r16
    235a:	1f 93       	push	r17
	// wait for the chip to become ready
	while (!HX711_is_ready()) {
    235c:	f6 df       	rcall	.-20     	; 0x234a <HX711_is_ready>
    235e:	88 23       	and	r24, r24
    2360:	e9 f3       	breq	.-6      	; 0x235c <HX711_read+0x4>
	long value = 0;
	char data[3] = { 0 };
	char filler = 0x00;

	// pulse the clock pin 24 times to read the data
	data[2] = shiftIn();
    2362:	d4 df       	rcall	.-88     	; 0x230c <shiftIn>
    2364:	18 2f       	mov	r17, r24
	data[1] = shiftIn();
    2366:	d2 df       	rcall	.-92     	; 0x230c <shiftIn>
    2368:	08 2f       	mov	r16, r24
	data[0] = shiftIn();
    236a:	d0 df       	rcall	.-96     	; 0x230c <shiftIn>
    236c:	e8 2f       	mov	r30, r24

	// set the channel and the gain factor for the next reading using the clock pin
	for (unsigned int i = 0; i < GAIN; i++) {
    236e:	80 91 57 01 	lds	r24, 0x0157
    2372:	90 e0       	ldi	r25, 0x00	; 0
    2374:	20 e0       	ldi	r18, 0x00	; 0
    2376:	30 e0       	ldi	r19, 0x00	; 0
    2378:	08 c0       	rjmp	.+16     	; 0x238a <HX711_read+0x32>
		HX711_POUT |= 1<<HX711_CK;
    237a:	76 9a       	sbi	0x0e, 6	; 14
		__asm__ __volatile__ ("nop");
    237c:	00 00       	nop
		__asm__ __volatile__ ("nop");
    237e:	00 00       	nop
		HX711_POUT &= ~(1<<HX711_CK);
    2380:	76 98       	cbi	0x0e, 6	; 14
		__asm__ __volatile__ ("nop");
    2382:	00 00       	nop
		__asm__ __volatile__ ("nop");
    2384:	00 00       	nop
	data[2] = shiftIn();
	data[1] = shiftIn();
	data[0] = shiftIn();

	// set the channel and the gain factor for the next reading using the clock pin
	for (unsigned int i = 0; i < GAIN; i++) {
    2386:	2f 5f       	subi	r18, 0xFF	; 255
    2388:	3f 4f       	sbci	r19, 0xFF	; 255
    238a:	28 17       	cp	r18, r24
    238c:	39 07       	cpc	r19, r25
    238e:	a8 f3       	brcs	.-22     	; 0x237a <HX711_read+0x22>
		__asm__ __volatile__ ("nop");
		__asm__ __volatile__ ("nop");
	}

	// Replicate the most significant bit to pad out a 32-bit signed integer
	if (data[2] & 0x80) {
    2390:	61 2f       	mov	r22, r17
    2392:	70 e0       	ldi	r23, 0x00	; 0
    2394:	80 e0       	ldi	r24, 0x00	; 0
    2396:	90 e0       	ldi	r25, 0x00	; 0
    2398:	cb 01       	movw	r24, r22
    239a:	77 27       	eor	r23, r23
    239c:	66 27       	eor	r22, r22
    239e:	20 2f       	mov	r18, r16
    23a0:	30 e0       	ldi	r19, 0x00	; 0
    23a2:	40 e0       	ldi	r20, 0x00	; 0
    23a4:	50 e0       	ldi	r21, 0x00	; 0
    23a6:	54 2f       	mov	r21, r20
    23a8:	43 2f       	mov	r20, r19
    23aa:	32 2f       	mov	r19, r18
    23ac:	22 27       	eor	r18, r18
    23ae:	62 2b       	or	r22, r18
    23b0:	73 2b       	or	r23, r19
    23b2:	84 2b       	or	r24, r20
    23b4:	95 2b       	or	r25, r21
    23b6:	2e 2f       	mov	r18, r30
    23b8:	30 e0       	ldi	r19, 0x00	; 0
    23ba:	40 e0       	ldi	r20, 0x00	; 0
    23bc:	50 e0       	ldi	r21, 0x00	; 0
    23be:	62 2b       	or	r22, r18
    23c0:	73 2b       	or	r23, r19
    23c2:	84 2b       	or	r24, r20
    23c4:	95 2b       	or	r25, r21
    23c6:	11 0f       	add	r17, r17
    23c8:	11 0b       	sbc	r17, r17
    23ca:	21 2f       	mov	r18, r17
    23cc:	30 e0       	ldi	r19, 0x00	; 0
    23ce:	40 e0       	ldi	r20, 0x00	; 0
    23d0:	50 e0       	ldi	r21, 0x00	; 0
    23d2:	52 2f       	mov	r21, r18
    23d4:	44 27       	eor	r20, r20
    23d6:	33 27       	eor	r19, r19
    23d8:	22 27       	eor	r18, r18
    23da:	62 2b       	or	r22, r18
    23dc:	73 2b       	or	r23, r19
    23de:	84 2b       	or	r24, r20
    23e0:	95 2b       	or	r25, r21
			| (unsigned long)(data[2]) << 16
			| (unsigned long)(data[1]) << 8
			| (unsigned long)(data[0]) );

	return value;
}
    23e2:	1f 91       	pop	r17
    23e4:	0f 91       	pop	r16
    23e6:	08 95       	ret

000023e8 <HX711_set_gain>:
char HX711_is_ready() {
	return !(HX711_PIN & 1<<HX711_IN);
}

void HX711_set_gain(char gain) {
	switch (gain) {
    23e8:	80 34       	cpi	r24, 0x40	; 64
    23ea:	39 f0       	breq	.+14     	; 0x23fa <HX711_set_gain+0x12>
    23ec:	80 38       	cpi	r24, 0x80	; 128
    23ee:	19 f0       	breq	.+6      	; 0x23f6 <HX711_set_gain+0xe>
    23f0:	80 32       	cpi	r24, 0x20	; 32
    23f2:	41 f4       	brne	.+16     	; 0x2404 <HX711_set_gain+0x1c>
    23f4:	04 c0       	rjmp	.+8      	; 0x23fe <HX711_set_gain+0x16>
		case 128:		// channel A, gain factor 128
			GAIN = 1;
    23f6:	81 e0       	ldi	r24, 0x01	; 1
    23f8:	03 c0       	rjmp	.+6      	; 0x2400 <HX711_set_gain+0x18>
			break;
		case 64:		// channel A, gain factor 64
			GAIN = 3;
    23fa:	83 e0       	ldi	r24, 0x03	; 3
    23fc:	01 c0       	rjmp	.+2      	; 0x2400 <HX711_set_gain+0x18>
			break;
		case 32:		// channel B, gain factor 32
			GAIN = 2;
    23fe:	82 e0       	ldi	r24, 0x02	; 2
    2400:	80 93 57 01 	sts	0x0157, r24
			break;
	}

	HX711_POUT &= ~(1<<HX711_CK);
    2404:	76 98       	cbi	0x0e, 6	; 14
	HX711_read();
}
    2406:	a8 cf       	rjmp	.-176    	; 0x2358 <HX711_read>

00002408 <HX711_begin>:
	return value;
}

void HX711_begin(/*char dout, char pd_sck,*/ char gain) {

	HX711_DDR |= 1<<HX711_CK;
    2408:	6e 9a       	sbi	0x0d, 6	; 13
	HX711_DDR &= ~(1<<HX711_IN);
    240a:	6d 98       	cbi	0x0d, 5	; 13

	HX711_set_gain(gain);
}
    240c:	ed cf       	rjmp	.-38     	; 0x23e8 <HX711_set_gain>

0000240e <HX711_read_average>:
			| (unsigned long)(data[0]) );

	return value;
}

long HX711_read_average(char times) {
    240e:	cf 92       	push	r12
    2410:	df 92       	push	r13
    2412:	ef 92       	push	r14
    2414:	ff 92       	push	r15
    2416:	0f 93       	push	r16
    2418:	1f 93       	push	r17
    241a:	c8 2e       	mov	r12, r24
    241c:	ee 24       	eor	r14, r14
    241e:	ff 24       	eor	r15, r15
    2420:	87 01       	movw	r16, r14
    2422:	dd 24       	eor	r13, r13
    2424:	06 c0       	rjmp	.+12     	; 0x2432 <HX711_read_average+0x24>
	long sum = 0;
	for (char i = 0; i < times; i++) {
		sum += HX711_read();
    2426:	98 df       	rcall	.-208    	; 0x2358 <HX711_read>
    2428:	e6 0e       	add	r14, r22
    242a:	f7 1e       	adc	r15, r23
    242c:	08 1f       	adc	r16, r24
    242e:	19 1f       	adc	r17, r25
	return value;
}

long HX711_read_average(char times) {
	long sum = 0;
	for (char i = 0; i < times; i++) {
    2430:	d3 94       	inc	r13
    2432:	dc 14       	cp	r13, r12
    2434:	c0 f3       	brcs	.-16     	; 0x2426 <HX711_read_average+0x18>
    2436:	2c 2d       	mov	r18, r12
    2438:	30 e0       	ldi	r19, 0x00	; 0
    243a:	40 e0       	ldi	r20, 0x00	; 0
    243c:	50 e0       	ldi	r21, 0x00	; 0
    243e:	c8 01       	movw	r24, r16
    2440:	b7 01       	movw	r22, r14
    2442:	25 d7       	rcall	.+3658   	; 0x328e <__divmodsi4>
		sum += HX711_read();
	}
	return sum / times;
}
    2444:	ca 01       	movw	r24, r20
    2446:	b9 01       	movw	r22, r18
    2448:	1f 91       	pop	r17
    244a:	0f 91       	pop	r16
    244c:	ff 90       	pop	r15
    244e:	ef 90       	pop	r14
    2450:	df 90       	pop	r13
    2452:	cf 90       	pop	r12
    2454:	08 95       	ret

00002456 <HX711_get_value>:

long HX711_get_value(char times) {
	return HX711_read_average(times) - OFFSET;
    2456:	db df       	rcall	.-74     	; 0x240e <HX711_read_average>
    2458:	20 91 74 01 	lds	r18, 0x0174
    245c:	30 91 75 01 	lds	r19, 0x0175
    2460:	40 91 76 01 	lds	r20, 0x0176
    2464:	50 91 77 01 	lds	r21, 0x0177
    2468:	62 1b       	sub	r22, r18
    246a:	73 0b       	sbc	r23, r19
    246c:	84 0b       	sbc	r24, r20
    246e:	95 0b       	sbc	r25, r21
}
    2470:	08 95       	ret

00002472 <HX711_get_units>:

float HX711_get_units(char times) {
	return HX711_get_value(times) / SCALE;
    2472:	f1 df       	rcall	.-30     	; 0x2456 <HX711_get_value>
    2474:	09 d6       	rcall	.+3090   	; 0x3088 <__floatsisf>
    2476:	20 91 58 01 	lds	r18, 0x0158
    247a:	30 91 59 01 	lds	r19, 0x0159
    247e:	40 91 5a 01 	lds	r20, 0x015A
    2482:	50 91 5b 01 	lds	r21, 0x015B
}
    2486:	65 c5       	rjmp	.+2762   	; 0x2f52 <__divsf3>

00002488 <HX711_set_scale>:
	double sum = HX711_read_average(times);
	HX711_set_offset(sum);
}

void HX711_set_scale(float scale) {
	SCALE = scale;
    2488:	60 93 58 01 	sts	0x0158, r22
    248c:	70 93 59 01 	sts	0x0159, r23
    2490:	80 93 5a 01 	sts	0x015A, r24
    2494:	90 93 5b 01 	sts	0x015B, r25
}
    2498:	08 95       	ret

0000249a <HX711_set_offset>:
float HX711_get_scale() {
	return SCALE;
}

void HX711_set_offset(long offset) {
	OFFSET = offset;
    249a:	60 93 74 01 	sts	0x0174, r22
    249e:	70 93 75 01 	sts	0x0175, r23
    24a2:	80 93 76 01 	sts	0x0176, r24
    24a6:	90 93 77 01 	sts	0x0177, r25
}
    24aa:	08 95       	ret

000024ac <HX711_tare>:
float HX711_get_units(char times) {
	return HX711_get_value(times) / SCALE;
}

void HX711_tare(char times) {
	double sum = HX711_read_average(times);
    24ac:	b0 df       	rcall	.-160    	; 0x240e <HX711_read_average>
	HX711_set_offset(sum);
    24ae:	ec d5       	rcall	.+3032   	; 0x3088 <__floatsisf>
    24b0:	b8 d5       	rcall	.+2928   	; 0x3022 <__fixsfsi>
}
    24b2:	f3 cf       	rjmp	.-26     	; 0x249a <HX711_set_offset>

000024b4 <HX711_power_up>:
	__asm__ __volatile__ ("nop");
	__asm__ __volatile__ ("nop");
}

void HX711_power_up() {
	HX711_POUT &= ~(1<<HX711_CK);
    24b4:	76 98       	cbi	0x0e, 6	; 14
	__asm__ __volatile__ ("nop");
    24b6:	00 00       	nop
    24b8:	08 95       	ret

000024ba <LCD_puts_f>:
*
*****************************************************************************/

// mt void LCD_puts_f(char __flash *pFlashStr, char scrollmode)
void LCD_puts_f(const char *pFlashStr, char scrollmode)
{
    24ba:	bc 01       	movw	r22, r24
    uint8_t i;

    scrollmode = scrollmode; // 200907, avoid warning

    while (gLCD_Update_Required);      // Wait for access to buffer
    24bc:	80 91 79 01 	lds	r24, 0x0179
    24c0:	88 23       	and	r24, r24
    24c2:	e1 f7       	brne	.-8      	; 0x24bc <LCD_puts_f+0x2>
    24c4:	20 e0       	ldi	r18, 0x00	; 0
    24c6:	30 e0       	ldi	r19, 0x00	; 0
    24c8:	06 c0       	rjmp	.+12     	; 0x24d6 <LCD_puts_f+0x1c>

    // mt: for (i = 0; pFlashStr[i] && i < TEXTBUFFER_SIZE; i++)
    for (i = 0; (const char)(pgm_read_byte(&pFlashStr[i])) && i < TEXTBUFFER_SIZE; i++)
    {
        // mt: gTextBuffer[i] = pFlashStr[i];
        gTextBuffer[i] = pgm_read_byte(&pFlashStr[i]);
    24ca:	f9 01       	movw	r30, r18
    24cc:	e2 55       	subi	r30, 0x52	; 82
    24ce:	fe 4f       	sbci	r31, 0xFE	; 254
    24d0:	80 83       	st	Z, r24
    24d2:	2f 5f       	subi	r18, 0xFF	; 255
    24d4:	3f 4f       	sbci	r19, 0xFF	; 255
    24d6:	42 2f       	mov	r20, r18
    24d8:	fb 01       	movw	r30, r22
    24da:	e2 0f       	add	r30, r18
    24dc:	f3 1f       	adc	r31, r19
    scrollmode = scrollmode; // 200907, avoid warning

    while (gLCD_Update_Required);      // Wait for access to buffer

    // mt: for (i = 0; pFlashStr[i] && i < TEXTBUFFER_SIZE; i++)
    for (i = 0; (const char)(pgm_read_byte(&pFlashStr[i])) && i < TEXTBUFFER_SIZE; i++)
    24de:	84 91       	lpm	r24, Z+
    24e0:	88 23       	and	r24, r24
    24e2:	19 f0       	breq	.+6      	; 0x24ea <LCD_puts_f+0x30>
    24e4:	29 31       	cpi	r18, 0x19	; 25
    24e6:	31 05       	cpc	r19, r1
    24e8:	81 f7       	brne	.-32     	; 0x24ca <LCD_puts_f+0x10>
    {
        // mt: gTextBuffer[i] = pFlashStr[i];
        gTextBuffer[i] = pgm_read_byte(&pFlashStr[i]);
    }

    gTextBuffer[i] = '\0';
    24ea:	e4 2f       	mov	r30, r20
    24ec:	f0 e0       	ldi	r31, 0x00	; 0
    24ee:	e2 55       	subi	r30, 0x52	; 82
    24f0:	fe 4f       	sbci	r31, 0xFE	; 254
    24f2:	10 82       	st	Z, r1

    if (i > 6)
    24f4:	47 30       	cpi	r20, 0x07	; 7
    24f6:	48 f0       	brcs	.+18     	; 0x250a <LCD_puts_f+0x50>
    {
        gScrollMode = 1;        // Scroll if text is longer than display size
    24f8:	81 e0       	ldi	r24, 0x01	; 1
    24fa:	80 93 99 01 	sts	0x0199, r24
        gScroll = 0;
    24fe:	10 92 c7 01 	sts	0x01C7, r1
        gLCD_Start_Scroll_Timer = 3;    //Start-up delay before scrolling the text
    2502:	83 e0       	ldi	r24, 0x03	; 3
    2504:	80 93 7a 01 	sts	0x017A, r24
    2508:	04 c0       	rjmp	.+8      	; 0x2512 <LCD_puts_f+0x58>
    }
    else
    {
        gScrollMode = 0;        
    250a:	10 92 99 01 	sts	0x0199, r1
        gScroll = 0;
    250e:	10 92 c7 01 	sts	0x01C7, r1
    }

    gLCD_Update_Required = 1;
    2512:	81 e0       	ldi	r24, 0x01	; 1
    2514:	80 93 79 01 	sts	0x0179, r24
}
    2518:	08 95       	ret

0000251a <LCD_puts>:
*
*	Purpose :		Writes a string to the LCD
*
*****************************************************************************/
void LCD_puts(char *pStr, char scrollmode)
{
    251a:	bc 01       	movw	r22, r24
    uint8_t i; // char i;

    scrollmode = scrollmode; // 200907, avoid warning

    while (gLCD_Update_Required);      // Wait for access to buffer
    251c:	80 91 79 01 	lds	r24, 0x0179
    2520:	88 23       	and	r24, r24
    2522:	e1 f7       	brne	.-8      	; 0x251c <LCD_puts+0x2>
    2524:	20 e0       	ldi	r18, 0x00	; 0
    2526:	30 e0       	ldi	r19, 0x00	; 0
    2528:	06 c0       	rjmp	.+12     	; 0x2536 <LCD_puts+0x1c>

    for (i = 0; pStr[i] && i < TEXTBUFFER_SIZE; i++)
    {
        gTextBuffer[i] = pStr[i];
    252a:	f9 01       	movw	r30, r18
    252c:	e2 55       	subi	r30, 0x52	; 82
    252e:	fe 4f       	sbci	r31, 0xFE	; 254
    2530:	80 83       	st	Z, r24
    2532:	2f 5f       	subi	r18, 0xFF	; 255
    2534:	3f 4f       	sbci	r19, 0xFF	; 255
    2536:	42 2f       	mov	r20, r18

    scrollmode = scrollmode; // 200907, avoid warning

    while (gLCD_Update_Required);      // Wait for access to buffer

    for (i = 0; pStr[i] && i < TEXTBUFFER_SIZE; i++)
    2538:	fb 01       	movw	r30, r22
    253a:	e2 0f       	add	r30, r18
    253c:	f3 1f       	adc	r31, r19
    253e:	80 81       	ld	r24, Z
    2540:	88 23       	and	r24, r24
    2542:	19 f0       	breq	.+6      	; 0x254a <LCD_puts+0x30>
    2544:	29 31       	cpi	r18, 0x19	; 25
    2546:	31 05       	cpc	r19, r1
    2548:	81 f7       	brne	.-32     	; 0x252a <LCD_puts+0x10>
    {
        gTextBuffer[i] = pStr[i];
    }

    gTextBuffer[i] = '\0';
    254a:	e4 2f       	mov	r30, r20
    254c:	f0 e0       	ldi	r31, 0x00	; 0
    254e:	e2 55       	subi	r30, 0x52	; 82
    2550:	fe 4f       	sbci	r31, 0xFE	; 254
    2552:	10 82       	st	Z, r1

    if (i > 6)
    2554:	47 30       	cpi	r20, 0x07	; 7
    2556:	48 f0       	brcs	.+18     	; 0x256a <LCD_puts+0x50>
    {
        gScrollMode = 1;        // Scroll if text is longer than display size
    2558:	81 e0       	ldi	r24, 0x01	; 1
    255a:	80 93 99 01 	sts	0x0199, r24
        gScroll = 0;
    255e:	10 92 c7 01 	sts	0x01C7, r1
        gLCD_Start_Scroll_Timer = 3;    //Start-up delay before scrolling the text
    2562:	83 e0       	ldi	r24, 0x03	; 3
    2564:	80 93 7a 01 	sts	0x017A, r24
    2568:	04 c0       	rjmp	.+8      	; 0x2572 <LCD_puts+0x58>
    }
    else
    {
        gScrollMode = 0;        
    256a:	10 92 99 01 	sts	0x0199, r1
        gScroll = 0;
    256e:	10 92 c7 01 	sts	0x01C7, r1
    }

    gLCD_Update_Required = 1;
    2572:	81 e0       	ldi	r24, 0x01	; 1
    2574:	80 93 79 01 	sts	0x0179, r24
}
    2578:	08 95       	ret

0000257a <LCD_putc>:
*
*****************************************************************************/
// mt void LCD_putc(char digit, char character)
void LCD_putc(uint8_t digit, char character)
{
    if (digit < TEXTBUFFER_SIZE) {
    257a:	89 31       	cpi	r24, 0x19	; 25
    257c:	28 f4       	brcc	.+10     	; 0x2588 <LCD_putc+0xe>
        gTextBuffer[digit] = character;
    257e:	e8 2f       	mov	r30, r24
    2580:	f0 e0       	ldi	r31, 0x00	; 0
    2582:	e2 55       	subi	r30, 0x52	; 82
    2584:	fe 4f       	sbci	r31, 0xFE	; 254
    2586:	60 83       	st	Z, r22
    2588:	08 95       	ret

0000258a <LCD_Clear>:
*
*	Purpose :		Clear the LCD
*
*****************************************************************************/
void LCD_Clear(void)
{
    258a:	80 e0       	ldi	r24, 0x00	; 0
    258c:	90 e0       	ldi	r25, 0x00	; 0
    uint8_t i; // char i;

    for (i=0; i<TEXTBUFFER_SIZE; i++) {
        gTextBuffer[i] = ' ';
    258e:	20 e2       	ldi	r18, 0x20	; 32
    2590:	fc 01       	movw	r30, r24
    2592:	e2 55       	subi	r30, 0x52	; 82
    2594:	fe 4f       	sbci	r31, 0xFE	; 254
    2596:	20 83       	st	Z, r18
    2598:	01 96       	adiw	r24, 0x01	; 1
*****************************************************************************/
void LCD_Clear(void)
{
    uint8_t i; // char i;

    for (i=0; i<TEXTBUFFER_SIZE; i++) {
    259a:	89 31       	cpi	r24, 0x19	; 25
    259c:	91 05       	cpc	r25, r1
    259e:	c1 f7       	brne	.-16     	; 0x2590 <LCD_Clear+0x6>
        gTextBuffer[i] = ' ';
    }

    gTextBuffer[TEXTBUFFER_SIZE - 1] = '\0'; // M. Loeffler 12/2009
    25a0:	10 92 c6 01 	sts	0x01C6, r1
}
    25a4:	08 95       	ret

000025a6 <LCD_Colon>:
*	Purpose :		Enable/disable colons on the LCD
*
*****************************************************************************/
void LCD_Colon(char show)
{
    gColon = show;
    25a6:	80 93 7c 01 	sts	0x017C, r24
}
    25aa:	08 95       	ret

000025ac <LCD_UpdateRequired>:
*
*	Purpose :		Tells the LCD that there is new data to be presented
*
*****************************************************************************/
void LCD_UpdateRequired(char update, char scrollmode)
{
    25ac:	98 2f       	mov	r25, r24

    while (gLCD_Update_Required);
    25ae:	80 91 79 01 	lds	r24, 0x0179
    25b2:	88 23       	and	r24, r24
    25b4:	e1 f7       	brne	.-8      	; 0x25ae <LCD_UpdateRequired+0x2>
    
    gScrollMode = scrollmode;
    25b6:	60 93 99 01 	sts	0x0199, r22
    gScroll = 0;
    25ba:	10 92 c7 01 	sts	0x01C7, r1

    gLCD_Update_Required = update;
    25be:	90 93 79 01 	sts	0x0179, r25
}
    25c2:	08 95       	ret

000025c4 <LCD_FlashReset>:
*	Purpose :		This function resets the blinking cycle of a flashing digit
*
*****************************************************************************/
void LCD_FlashReset(void)
{
    gFlashTimer = 0;
    25c4:	10 92 7b 01 	sts	0x017B, r1
}
    25c8:	08 95       	ret

000025ca <SetContrast>:
*
*	Purpose :		Adjust the LCD contrast
*
*****************************************************************************/
char SetContrast(char input)
{
    25ca:	ff 92       	push	r15
    25cc:	0f 93       	push	r16
    25ce:	1f 93       	push	r17
    25d0:	f8 2e       	mov	r15, r24
    static char enter = 1;
    char CH, CL;

    if (enter)
    25d2:	80 91 5d 01 	lds	r24, 0x015D
    25d6:	88 23       	and	r24, r24
    25d8:	19 f0       	breq	.+6      	; 0x25e0 <SetContrast+0x16>
    {
        LCD_Clear();
    25da:	d7 df       	rcall	.-82     	; 0x258a <LCD_Clear>
        enter = 0;
    25dc:	10 92 5d 01 	sts	0x015D, r1
    }

    CH = CHAR2BCD2(CONTRAST);
    25e0:	80 91 5c 01 	lds	r24, 0x015C
    25e4:	0e 94 98 09 	call	0x1330	; 0x1330 <CHAR2BCD2>
    25e8:	18 2f       	mov	r17, r24
    CL = (CH & 0x0F) + '0';
    CH = (CH >> 4) + '0';
    25ea:	08 2f       	mov	r16, r24
    25ec:	02 95       	swap	r16
    25ee:	0f 70       	andi	r16, 0x0F	; 15

    LCD_putc(0, 'C');
    25f0:	80 e0       	ldi	r24, 0x00	; 0
    25f2:	63 e4       	ldi	r22, 0x43	; 67
    25f4:	c2 df       	rcall	.-124    	; 0x257a <LCD_putc>
    LCD_putc(1, 'T');
    25f6:	81 e0       	ldi	r24, 0x01	; 1
    25f8:	64 e5       	ldi	r22, 0x54	; 84
    25fa:	bf df       	rcall	.-130    	; 0x257a <LCD_putc>
    LCD_putc(2, 'R');
    25fc:	82 e0       	ldi	r24, 0x02	; 2
    25fe:	62 e5       	ldi	r22, 0x52	; 82
    2600:	bc df       	rcall	.-136    	; 0x257a <LCD_putc>
    LCD_putc(3, ' ');
    2602:	83 e0       	ldi	r24, 0x03	; 3
    2604:	60 e2       	ldi	r22, 0x20	; 32
    2606:	b9 df       	rcall	.-142    	; 0x257a <LCD_putc>
    LCD_putc(4, CH);
    2608:	00 5d       	subi	r16, 0xD0	; 208
    260a:	84 e0       	ldi	r24, 0x04	; 4
    260c:	60 2f       	mov	r22, r16
    260e:	b5 df       	rcall	.-150    	; 0x257a <LCD_putc>
    LCD_putc(5, CL);
    2610:	1f 70       	andi	r17, 0x0F	; 15
    2612:	10 5d       	subi	r17, 0xD0	; 208
    2614:	85 e0       	ldi	r24, 0x05	; 5
    2616:	61 2f       	mov	r22, r17
    2618:	b0 df       	rcall	.-160    	; 0x257a <LCD_putc>

    LCD_UpdateRequired(TRUE, 0);
    261a:	81 e0       	ldi	r24, 0x01	; 1
    261c:	60 e0       	ldi	r22, 0x00	; 0
    261e:	c6 df       	rcall	.-116    	; 0x25ac <LCD_UpdateRequired>

    if (input == KEY_PLUS)
    2620:	84 e0       	ldi	r24, 0x04	; 4
    2622:	f8 16       	cp	r15, r24
    2624:	21 f4       	brne	.+8      	; 0x262e <SetContrast+0x64>
        CONTRAST++;
    2626:	80 91 5c 01 	lds	r24, 0x015C
    262a:	8f 5f       	subi	r24, 0xFF	; 255
    262c:	06 c0       	rjmp	.+12     	; 0x263a <SetContrast+0x70>
    else if (input == KEY_MINUS)
    262e:	85 e0       	ldi	r24, 0x05	; 5
    2630:	f8 16       	cp	r15, r24
    2632:	29 f4       	brne	.+10     	; 0x263e <SetContrast+0x74>
        CONTRAST--;
    2634:	80 91 5c 01 	lds	r24, 0x015C
    2638:	81 50       	subi	r24, 0x01	; 1
    263a:	80 93 5c 01 	sts	0x015C, r24

    if (CONTRAST == 255)
    263e:	80 91 5c 01 	lds	r24, 0x015C
    2642:	8f 3f       	cpi	r24, 0xFF	; 255
    2644:	11 f4       	brne	.+4      	; 0x264a <SetContrast+0x80>
        CONTRAST = 0;
    2646:	10 92 5c 01 	sts	0x015C, r1
    if (CONTRAST > 15)
    264a:	80 91 5c 01 	lds	r24, 0x015C
    264e:	80 31       	cpi	r24, 0x10	; 16
    2650:	18 f0       	brcs	.+6      	; 0x2658 <SetContrast+0x8e>
        CONTRAST = 15;
    2652:	8f e0       	ldi	r24, 0x0F	; 15
    2654:	80 93 5c 01 	sts	0x015C, r24

    LCD_CONTRAST_LEVEL(CONTRAST);
    2658:	90 91 e7 00 	lds	r25, 0x00E7
    265c:	80 91 5c 01 	lds	r24, 0x015C
    2660:	8f 70       	andi	r24, 0x0F	; 15
    2662:	90 7f       	andi	r25, 0xF0	; 240
    2664:	89 2b       	or	r24, r25
    2666:	80 93 e7 00 	sts	0x00E7, r24


    if (input == KEY_ENTER)
    266a:	81 e0       	ldi	r24, 0x01	; 1
    266c:	f8 16       	cp	r15, r24
    266e:	11 f0       	breq	.+4      	; 0x2674 <SetContrast+0xaa>
    2670:	8d e5       	ldi	r24, 0x5D	; 93
    2672:	03 c0       	rjmp	.+6      	; 0x267a <SetContrast+0xb0>
    {
        enter = 1;
    2674:	f0 92 5d 01 	sts	0x015D, r15
    2678:	8c e5       	ldi	r24, 0x5C	; 92
        return ST_OPTIONS_DISPLAY_CONTRAST;
    }

    return ST_OPTIONS_DISPLAY_CONTRAST_FUNC;
}
    267a:	1f 91       	pop	r17
    267c:	0f 91       	pop	r16
    267e:	ff 90       	pop	r15
    2680:	08 95       	ret

00002682 <LCD_WriteDigit>:
*   Purpose :       Stores LCD control data in the LCD_displayData buffer.
*                   (The LCD_displayData is latched in the LCD_SOF interrupt.)
*
*****************************************************************************/
void LCD_WriteDigit(char c, char digit)
{
    2682:	cf 93       	push	r28
    2684:	df 93       	push	r29
    2686:	98 2f       	mov	r25, r24
    char mask, nibble;
    volatile char *ptr;
    char i;


    if (digit > 5)                              // Skip if digit is illegal
    2688:	66 30       	cpi	r22, 0x06	; 6
    268a:	c8 f5       	brcc	.+114    	; 0x26fe <LCD_WriteDigit+0x7c>
        return;

    //Lookup character table for segmet data
    if ((c >= '*') && (c <= 'z'))
    268c:	8a 52       	subi	r24, 0x2A	; 42
    268e:	81 35       	cpi	r24, 0x51	; 81
    2690:	18 f0       	brcs	.+6      	; 0x2698 <LCD_WriteDigit+0x16>
    2692:	a0 e0       	ldi	r26, 0x00	; 0
    2694:	b0 e0       	ldi	r27, 0x00	; 0
    2696:	0c c0       	rjmp	.+24     	; 0x26b0 <LCD_WriteDigit+0x2e>
    {
        // c is a letter
        if (c >= 'a')                           // Convert to upper case
    2698:	91 36       	cpi	r25, 0x61	; 97
    269a:	08 f0       	brcs	.+2      	; 0x269e <LCD_WriteDigit+0x1c>
            c &= ~0x20;                         // if necessarry
    269c:	9f 7d       	andi	r25, 0xDF	; 223

        c -= '*';

        //mt seg = LCD_character_table[c];
        seg = (unsigned int) pgm_read_word(&LCD_character_table[(uint8_t)c]); 
    269e:	9a 52       	subi	r25, 0x2A	; 42
    26a0:	e9 2f       	mov	r30, r25
    26a2:	f0 e0       	ldi	r31, 0x00	; 0
    26a4:	ee 0f       	add	r30, r30
    26a6:	ff 1f       	adc	r31, r31
    26a8:	ec 58       	subi	r30, 0x8C	; 140
    26aa:	fa 4f       	sbci	r31, 0xFA	; 250
    26ac:	a5 91       	lpm	r26, Z+
    26ae:	b4 91       	lpm	r27, Z+
    }

    // Adjust mask according to LCD segment mapping
    if (digit & 0x01)
    26b0:	86 2f       	mov	r24, r22
    26b2:	90 e0       	ldi	r25, 0x00	; 0
    26b4:	ec 01       	movw	r28, r24
    26b6:	c1 70       	andi	r28, 0x01	; 1
    26b8:	d0 70       	andi	r29, 0x00	; 0
    26ba:	60 fd       	sbrc	r22, 0
    26bc:	02 c0       	rjmp	.+4      	; 0x26c2 <LCD_WriteDigit+0x40>
    26be:	90 ef       	ldi	r25, 0xF0	; 240
    26c0:	01 c0       	rjmp	.+2      	; 0x26c4 <LCD_WriteDigit+0x42>
    26c2:	9f e0       	ldi	r25, 0x0F	; 15
        mask = 0x0F;                // Digit 1, 3, 5
    else
        mask = 0xF0;                // Digit 0, 2, 4

    ptr = LCD_Data + (digit >> 1);  // digit = {0,0,1,1,2,2}
    26c4:	66 95       	lsr	r22
    26c6:	70 e0       	ldi	r23, 0x00	; 0
    26c8:	66 56       	subi	r22, 0x66	; 102
    26ca:	7e 4f       	sbci	r23, 0xFE	; 254
    26cc:	20 e0       	ldi	r18, 0x00	; 0
    26ce:	30 e0       	ldi	r19, 0x00	; 0
    26d0:	fb 01       	movw	r30, r22
    26d2:	e2 0f       	add	r30, r18
    26d4:	f3 1f       	adc	r31, r19

    for (i = 0; i < 4; i++)
    {
        nibble = seg & 0x000F;
    26d6:	4a 2f       	mov	r20, r26
    26d8:	4f 70       	andi	r20, 0x0F	; 15
        seg >>= 4;
    26da:	84 e0       	ldi	r24, 0x04	; 4
    26dc:	b6 95       	lsr	r27
    26de:	a7 95       	ror	r26
    26e0:	8a 95       	dec	r24
    26e2:	e1 f7       	brne	.-8      	; 0x26dc <LCD_WriteDigit+0x5a>
        if (digit & 0x01)
    26e4:	20 97       	sbiw	r28, 0x00	; 0
    26e6:	11 f0       	breq	.+4      	; 0x26ec <LCD_WriteDigit+0x6a>
            nibble <<= 4;
    26e8:	42 95       	swap	r20
    26ea:	40 7f       	andi	r20, 0xF0	; 240
        *ptr = (*ptr & mask) | nibble;
    26ec:	80 81       	ld	r24, Z
    26ee:	89 23       	and	r24, r25
    26f0:	48 2b       	or	r20, r24
    26f2:	40 83       	st	Z, r20
    26f4:	2b 5f       	subi	r18, 0xFB	; 251
    26f6:	3f 4f       	sbci	r19, 0xFF	; 255
    else
        mask = 0xF0;                // Digit 0, 2, 4

    ptr = LCD_Data + (digit >> 1);  // digit = {0,0,1,1,2,2}

    for (i = 0; i < 4; i++)
    26f8:	24 31       	cpi	r18, 0x14	; 20
    26fa:	31 05       	cpc	r19, r1
    26fc:	49 f7       	brne	.-46     	; 0x26d0 <LCD_WriteDigit+0x4e>
        if (digit & 0x01)
            nibble <<= 4;
        *ptr = (*ptr & mask) | nibble;
        ptr += 5;
    }
}
    26fe:	df 91       	pop	r29
    2700:	cf 91       	pop	r28
    2702:	08 95       	ret

00002704 <LCD_AllSegments>:
*****************************************************************************/
void LCD_AllSegments(char show)
{
    unsigned char i;

    if (show)
    2704:	81 11       	cpse	r24, r1
    2706:	8f ef       	ldi	r24, 0xFF	; 255
    2708:	20 e0       	ldi	r18, 0x00	; 0
    270a:	30 e0       	ldi	r19, 0x00	; 0
    270c:	f9 01       	movw	r30, r18
    270e:	e6 56       	subi	r30, 0x66	; 102
    2710:	fe 4f       	sbci	r31, 0xFE	; 254
        show = 0xFF;

    // Set/clear all bits in all LCD registers
    for (i=0; i < LCD_REGISTER_COUNT; i++)
        *(LCD_Data + i) = show;
    2712:	80 83       	st	Z, r24
    2714:	2f 5f       	subi	r18, 0xFF	; 255
    2716:	3f 4f       	sbci	r19, 0xFF	; 255

    if (show)
        show = 0xFF;

    // Set/clear all bits in all LCD registers
    for (i=0; i < LCD_REGISTER_COUNT; i++)
    2718:	24 31       	cpi	r18, 0x14	; 20
    271a:	31 05       	cpc	r19, r1
    271c:	b9 f7       	brne	.-18     	; 0x270c <LCD_AllSegments+0x8>
        *(LCD_Data + i) = show;
}
    271e:	08 95       	ret

00002720 <LCD_Init>:
*                   Set up the LCD (timing, contrast, etc.)
*
*****************************************************************************/
void LCD_Init(void)
{
    LCD_AllSegments(FALSE);                     // Clear segment buffer.
    2720:	80 e0       	ldi	r24, 0x00	; 0
    2722:	f0 df       	rcall	.-32     	; 0x2704 <LCD_AllSegments>

    LCD_CONTRAST_LEVEL(LCD_INITIAL_CONTRAST);    //Set the LCD contrast level
    2724:	a7 ee       	ldi	r26, 0xE7	; 231
    2726:	b0 e0       	ldi	r27, 0x00	; 0
    2728:	8c 91       	ld	r24, X
    272a:	8f 60       	ori	r24, 0x0F	; 15
    272c:	8c 93       	st	X, r24

    // Select asynchronous clock source, enable all COM pins and enable all
    // segment pins.
    LCDCRB = (1<<LCDCS) | (3<<LCDMUX0) | (7<<LCDPM0);
    272e:	87 eb       	ldi	r24, 0xB7	; 183
    2730:	80 93 e5 00 	sts	0x00E5, r24

    // Set LCD prescaler to give a framerate of 32,0 Hz
    LCDFRR = (0<<LCDPS0) | (7<<LCDCD0);    
    2734:	87 e0       	ldi	r24, 0x07	; 7
    2736:	80 93 e6 00 	sts	0x00E6, r24

    LCDCRA = (1<<LCDEN) | (1<<LCDAB);           // Enable LCD and set low power waveform
    273a:	e4 ee       	ldi	r30, 0xE4	; 228
    273c:	f0 e0       	ldi	r31, 0x00	; 0
    273e:	80 ec       	ldi	r24, 0xC0	; 192
    2740:	80 83       	st	Z, r24

    //Enable LCD start of frame interrupt
    LCDCRA |= (1<<LCDIE);
    2742:	80 81       	ld	r24, Z
    2744:	88 60       	ori	r24, 0x08	; 8
    2746:	80 83       	st	Z, r24

    //updated 2006-10-10, setting LCD drive time to 1150us in FW rev 07, 
    //instead of previous 300us in FW rev 06. Due to some variations on the LCD
    //glass provided to the AVR Butterfly production.
    LCDCCR |= (1<<LCDDC2) | (1<<LCDDC1) | (1<<LCDDC0);
    2748:	8c 91       	ld	r24, X
    274a:	80 6e       	ori	r24, 0xE0	; 224
    274c:	8c 93       	st	X, r24

    gLCD_Update_Required = FALSE;
    274e:	10 92 79 01 	sts	0x0179, r1


}
    2752:	08 95       	ret

00002754 <__vector_22>:
*   Purpose: Latch the LCD_displayData and Set LCD_status.updateComplete
*
*****************************************************************************/

ISR(LCD_vect)
{
    2754:	1f 92       	push	r1
    2756:	0f 92       	push	r0
    2758:	0f b6       	in	r0, 0x3f	; 63
    275a:	0f 92       	push	r0
    275c:	11 24       	eor	r1, r1
    275e:	ef 92       	push	r14
    2760:	ff 92       	push	r15
    2762:	0f 93       	push	r16
    2764:	1f 93       	push	r17
    2766:	2f 93       	push	r18
    2768:	3f 93       	push	r19
    276a:	4f 93       	push	r20
    276c:	5f 93       	push	r21
    276e:	6f 93       	push	r22
    2770:	7f 93       	push	r23
    2772:	8f 93       	push	r24
    2774:	9f 93       	push	r25
    2776:	af 93       	push	r26
    2778:	bf 93       	push	r27
    277a:	cf 93       	push	r28
    277c:	df 93       	push	r29
    277e:	ef 93       	push	r30
    2780:	ff 93       	push	r31
    static char auto_joystick_count;

    c_flash=0; // mt
    
/**************** Button timeout for the button.c, START ****************/
    if(!gButtonTimeout)
    2782:	80 91 71 01 	lds	r24, 0x0171
    2786:	88 23       	and	r24, r24
    2788:	61 f4       	brne	.+24     	; 0x27a2 <__vector_22+0x4e>
    {
        timeout_count++;
    278a:	80 91 7e 01 	lds	r24, 0x017E
    278e:	8f 5f       	subi	r24, 0xFF	; 255
    2790:	80 93 7e 01 	sts	0x017E, r24
        
        if(timeout_count > 3)
    2794:	84 30       	cpi	r24, 0x04	; 4
    2796:	28 f0       	brcs	.+10     	; 0x27a2 <__vector_22+0x4e>
        {
            gButtonTimeout = TRUE;
    2798:	81 e0       	ldi	r24, 0x01	; 1
    279a:	80 93 71 01 	sts	0x0171, r24
            timeout_count = 0;
    279e:	10 92 7e 01 	sts	0x017E, r1

/**************** Button timeout for the button.c, END ******************/

/**************** Auto press joystick for the main.c, START *************/

    if(gAutoPressJoystick == AUTO)
    27a2:	80 91 78 01 	lds	r24, 0x0178
    27a6:	83 30       	cpi	r24, 0x03	; 3
    27a8:	71 f4       	brne	.+28     	; 0x27c6 <__vector_22+0x72>
    {
        auto_joystick_count++;
    27aa:	80 91 7d 01 	lds	r24, 0x017D
    27ae:	8f 5f       	subi	r24, 0xFF	; 255
    27b0:	80 93 7d 01 	sts	0x017D, r24
        
        if(auto_joystick_count > 16)
    27b4:	81 31       	cpi	r24, 0x11	; 17
    27b6:	48 f0       	brcs	.+18     	; 0x27ca <__vector_22+0x76>
        {
            gAutoPressJoystick = TRUE;
    27b8:	81 e0       	ldi	r24, 0x01	; 1
    27ba:	80 93 78 01 	sts	0x0178, r24
            auto_joystick_count = 15;
    27be:	8f e0       	ldi	r24, 0x0F	; 15
    27c0:	80 93 7d 01 	sts	0x017D, r24
    27c4:	02 c0       	rjmp	.+4      	; 0x27ca <__vector_22+0x76>
        }
    }
    else
        auto_joystick_count = 0;
    27c6:	10 92 7d 01 	sts	0x017D, r1


/**************** Auto press joystick for the main.c, END ***************/    

    LCD_timer--;                    // Decreased every LCD frame
    27ca:	00 91 5e 01 	lds	r16, 0x015E
    27ce:	01 50       	subi	r16, 0x01	; 1
    27d0:	00 93 5e 01 	sts	0x015E, r16

    if (gScrollMode)
    27d4:	80 91 99 01 	lds	r24, 0x0199
    27d8:	88 23       	and	r24, r24
    27da:	81 f0       	breq	.+32     	; 0x27fc <__vector_22+0xa8>
    {
        // If we are in scroll mode, and the timer has expired,
        // we will update the LCD
        if (LCD_timer == 0)
    27dc:	00 23       	and	r16, r16
    27de:	81 f4       	brne	.+32     	; 0x2800 <__vector_22+0xac>
        {
            if (gLCD_Start_Scroll_Timer == 0)
    27e0:	80 91 7a 01 	lds	r24, 0x017A
    27e4:	88 23       	and	r24, r24
    27e6:	21 f4       	brne	.+8      	; 0x27f0 <__vector_22+0x9c>
            {
                gLCD_Update_Required = TRUE;
    27e8:	81 e0       	ldi	r24, 0x01	; 1
    27ea:	80 93 79 01 	sts	0x0179, r24
    27ee:	08 c0       	rjmp	.+16     	; 0x2800 <__vector_22+0xac>
            }
            else
                gLCD_Start_Scroll_Timer--;
    27f0:	80 91 7a 01 	lds	r24, 0x017A
    27f4:	81 50       	subi	r24, 0x01	; 1
    27f6:	80 93 7a 01 	sts	0x017A, r24
    27fa:	02 c0       	rjmp	.+4      	; 0x2800 <__vector_22+0xac>
    }
    else    
    {   // if not scrolling,
        // disble LCD start of frame interrupt
        // cbi(LCDCRA, LCDIE);   //DEBUG
        gScroll = 0;
    27fc:	10 92 c7 01 	sts	0x01C7, r1
    }


    EOL = FALSE;
    if (gLCD_Update_Required == TRUE)
    2800:	80 91 79 01 	lds	r24, 0x0179
    2804:	81 30       	cpi	r24, 0x01	; 1
    2806:	09 f0       	breq	.+2      	; 0x280a <__vector_22+0xb6>
    2808:	51 c0       	rjmp	.+162    	; 0x28ac <__vector_22+0x158>
    {
        // Duty cycle of flashing characters
        if (gFlashTimer < (LCD_FLASH_SEED >> 1))
    280a:	e0 90 7b 01 	lds	r14, 0x017B
    280e:	ff 24       	eor	r15, r15
    2810:	10 e0       	ldi	r17, 0x00	; 0
    2812:	c0 e0       	ldi	r28, 0x00	; 0
    2814:	d0 e0       	ldi	r29, 0x00	; 0
    2816:	6c 2f       	mov	r22, r28
            flash = 1;

        // Repeat for the six LCD characters
        for (i = 0; i < 6; i++)
        {
            if ((gScroll+i) >= 0 && (!EOL))
    2818:	80 91 c7 01 	lds	r24, 0x01C7
    281c:	99 27       	eor	r25, r25
    281e:	87 fd       	sbrc	r24, 7
    2820:	90 95       	com	r25
    2822:	8c 0f       	add	r24, r28
    2824:	9d 1f       	adc	r25, r29
    2826:	97 fd       	sbrc	r25, 7
    2828:	15 c0       	rjmp	.+42     	; 0x2854 <__vector_22+0x100>
    282a:	11 23       	and	r17, r17
    282c:	99 f4       	brne	.+38     	; 0x2854 <__vector_22+0x100>
            {
                // We have some visible characters
                c = gTextBuffer[i + gScroll];
    282e:	e0 91 c7 01 	lds	r30, 0x01C7
    2832:	ff 27       	eor	r31, r31
    2834:	e7 fd       	sbrc	r30, 7
    2836:	f0 95       	com	r31
    2838:	ec 0f       	add	r30, r28
    283a:	fd 1f       	adc	r31, r29
    283c:	e2 55       	subi	r30, 0x52	; 82
    283e:	fe 4f       	sbci	r31, 0xFE	; 254
    2840:	80 81       	ld	r24, Z
                c_flash = c & 0x80 ? 1 : 0;
    2842:	f8 2e       	mov	r15, r24
    2844:	ff 1c       	adc	r15, r15
    2846:	ff 24       	eor	r15, r15
    2848:	ff 1c       	adc	r15, r15
                c = c & 0x7F;
    284a:	8f 77       	andi	r24, 0x7F	; 127

                if (c == '\0')
    284c:	21 f4       	brne	.+8      	; 0x2856 <__vector_22+0x102>
    284e:	1c 2f       	mov	r17, r28
    2850:	1f 5f       	subi	r17, 0xFF	; 255
    2852:	01 c0       	rjmp	.+2      	; 0x2856 <__vector_22+0x102>
    2854:	80 e2       	ldi	r24, 0x20	; 32
            else
                c = ' ';

            // Check if this character is flashing

            if (c_flash && flash)
    2856:	ff 20       	and	r15, r15
    2858:	21 f0       	breq	.+8      	; 0x2862 <__vector_22+0x10e>
    285a:	94 e0       	ldi	r25, 0x04	; 4
    285c:	9e 15       	cp	r25, r14
    285e:	08 f4       	brcc	.+2      	; 0x2862 <__vector_22+0x10e>
                LCD_WriteDigit(' ', i);
    2860:	80 e2       	ldi	r24, 0x20	; 32
            else
                LCD_WriteDigit(c, i);
    2862:	0f df       	rcall	.-482    	; 0x2682 <LCD_WriteDigit>
    2864:	21 96       	adiw	r28, 0x01	; 1
            flash = 0;
        else
            flash = 1;

        // Repeat for the six LCD characters
        for (i = 0; i < 6; i++)
    2866:	c6 30       	cpi	r28, 0x06	; 6
    2868:	d1 05       	cpc	r29, r1
    286a:	a9 f6       	brne	.-86     	; 0x2816 <__vector_22+0xc2>
    286c:	ac ee       	ldi	r26, 0xEC	; 236
    286e:	b0 e0       	ldi	r27, 0x00	; 0
    2870:	fd 01       	movw	r30, r26
    2872:	e2 55       	subi	r30, 0x52	; 82
    2874:	ff 4f       	sbci	r31, 0xFF	; 255
                LCD_WriteDigit(c, i);
        }

        // Copy the segment buffer to the real segments
        for (i = 0; i < LCD_REGISTER_COUNT; i++)
            *(pLCDREG + i) = *(LCD_Data+i);
    2876:	80 81       	ld	r24, Z
    2878:	8d 93       	st	X+, r24
            else
                LCD_WriteDigit(c, i);
        }

        // Copy the segment buffer to the real segments
        for (i = 0; i < LCD_REGISTER_COUNT; i++)
    287a:	81 e0       	ldi	r24, 0x01	; 1
    287c:	a0 30       	cpi	r26, 0x00	; 0
    287e:	b8 07       	cpc	r27, r24
    2880:	b9 f7       	brne	.-18     	; 0x2870 <__vector_22+0x11c>
            *(pLCDREG + i) = *(LCD_Data+i);

        // Handle colon
        if (gColon)
    2882:	80 91 7c 01 	lds	r24, 0x017C
    2886:	88 23       	and	r24, r24
    2888:	21 f0       	breq	.+8      	; 0x2892 <__vector_22+0x13e>
            *(pLCDREG + 8) = 0x01;
    288a:	81 e0       	ldi	r24, 0x01	; 1
    288c:	80 93 f4 00 	sts	0x00F4, r24
    2890:	02 c0       	rjmp	.+4      	; 0x2896 <__vector_22+0x142>
        else
            *(pLCDREG + 8) = 0x00;
    2892:	10 92 f4 00 	sts	0x00F4, r1

        // If the text scrolled off the display,
        // we have to start over again.
        if (EOL == 1)
    2896:	11 30       	cpi	r17, 0x01	; 1
    2898:	11 f4       	brne	.+4      	; 0x289e <__vector_22+0x14a>
            gScroll = -6;
    289a:	8a ef       	ldi	r24, 0xFA	; 250
    289c:	03 c0       	rjmp	.+6      	; 0x28a4 <__vector_22+0x150>
        else
            gScroll++;
    289e:	80 91 c7 01 	lds	r24, 0x01C7
    28a2:	8f 5f       	subi	r24, 0xFF	; 255
    28a4:	80 93 c7 01 	sts	0x01C7, r24

        // No need to update anymore
        gLCD_Update_Required = FALSE;
    28a8:	10 92 79 01 	sts	0x0179, r1
    }


    // LCD_timer is used when scrolling text
    if (LCD_timer == 0)
    28ac:	00 23       	and	r16, r16
    28ae:	19 f4       	brne	.+6      	; 0x28b6 <__vector_22+0x162>
    {
/*        if ((gScroll <= 0) || EOL)
            LCD_timer = LCD_TIMER_SEED/2;
        else*/
            LCD_timer = LCD_TIMER_SEED;
    28b0:	83 e0       	ldi	r24, 0x03	; 3
    28b2:	80 93 5e 01 	sts	0x015E, r24
    }

    // gFlashTimer is used when flashing characters
    if (gFlashTimer == LCD_FLASH_SEED)
    28b6:	80 91 7b 01 	lds	r24, 0x017B
    28ba:	8a 30       	cpi	r24, 0x0A	; 10
    28bc:	19 f4       	brne	.+6      	; 0x28c4 <__vector_22+0x170>
        gFlashTimer= 0;
    28be:	10 92 7b 01 	sts	0x017B, r1
    28c2:	05 c0       	rjmp	.+10     	; 0x28ce <__vector_22+0x17a>
    else
        gFlashTimer++;
    28c4:	80 91 7b 01 	lds	r24, 0x017B
    28c8:	8f 5f       	subi	r24, 0xFF	; 255
    28ca:	80 93 7b 01 	sts	0x017B, r24

}
    28ce:	ff 91       	pop	r31
    28d0:	ef 91       	pop	r30
    28d2:	df 91       	pop	r29
    28d4:	cf 91       	pop	r28
    28d6:	bf 91       	pop	r27
    28d8:	af 91       	pop	r26
    28da:	9f 91       	pop	r25
    28dc:	8f 91       	pop	r24
    28de:	7f 91       	pop	r23
    28e0:	6f 91       	pop	r22
    28e2:	5f 91       	pop	r21
    28e4:	4f 91       	pop	r20
    28e6:	3f 91       	pop	r19
    28e8:	2f 91       	pop	r18
    28ea:	1f 91       	pop	r17
    28ec:	0f 91       	pop	r16
    28ee:	ff 90       	pop	r15
    28f0:	ef 90       	pop	r14
    28f2:	0f 90       	pop	r0
    28f4:	0f be       	out	0x3f, r0	; 63
    28f6:	0f 90       	pop	r0
    28f8:	1f 90       	pop	r1
    28fa:	18 95       	reti

000028fc <PlayClick>:
*
*   Purpose :       Plays the click-sound
*
*****************************************************************************/
void PlayClick(void)
{
    28fc:	1f 93       	push	r17
    28fe:	10 e0       	ldi	r17, 0x00	; 0
	unsigned char i;
	for (i = 0; i < 10; i++) {
		cbiBF(PORTB, 5);
    2900:	2d 98       	cbi	0x05, 5	; 5
		Delay(1);
    2902:	81 e0       	ldi	r24, 0x01	; 1
    2904:	90 e0       	ldi	r25, 0x00	; 0
    2906:	0e 94 23 06 	call	0xc46	; 0xc46 <Delay>
		sbiBF(PORTB, 5);
    290a:	2d 9a       	sbi	0x05, 5	; 5
		Delay(1);
    290c:	81 e0       	ldi	r24, 0x01	; 1
    290e:	90 e0       	ldi	r25, 0x00	; 0
    2910:	0e 94 23 06 	call	0xc46	; 0xc46 <Delay>
*
*****************************************************************************/
void PlayClick(void)
{
	unsigned char i;
	for (i = 0; i < 10; i++) {
    2914:	1f 5f       	subi	r17, 0xFF	; 255
    2916:	1a 30       	cpi	r17, 0x0A	; 10
    2918:	99 f7       	brne	.-26     	; 0x2900 <PlayClick+0x4>
		cbiBF(PORTB, 5);
		Delay(1);
		sbiBF(PORTB, 5);
		Delay(1);
	}
}
    291a:	1f 91       	pop	r17
    291c:	08 95       	ret

0000291e <Play_Tune>:
    unsigned int temp_tone;	// mt 200301
    int temp_hi;
    
    char loop;
    
    if(!Tone)
    291e:	80 91 80 01 	lds	r24, 0x0180
    2922:	88 23       	and	r24, r24
    2924:	69 f4       	brne	.+26     	; 0x2940 <Play_Tune+0x22>
    {
        Duration = 0;   
    2926:	10 92 81 01 	sts	0x0181, r1
        // mt Tempo = *(pSong + 0);
        Tempo = (uint8_t)pgm_read_word(pSong + 0);
    292a:	e0 91 c8 01 	lds	r30, 0x01C8
    292e:	f0 91 c9 01 	lds	r31, 0x01C9
    2932:	85 91       	lpm	r24, Z+
    2934:	94 91       	lpm	r25, Z+
    2936:	80 93 83 01 	sts	0x0183, r24
        Tone = 1;   //Start the song from the beginning
    293a:	81 e0       	ldi	r24, 0x01	; 1
    293c:	80 93 80 01 	sts	0x0180, r24
    }
    
    if(!Tempo)
    2940:	80 91 83 01 	lds	r24, 0x0183
    2944:	88 23       	and	r24, r24
    2946:	09 f0       	breq	.+2      	; 0x294a <Play_Tune+0x2c>
    2948:	6d c0       	rjmp	.+218    	; 0x2a24 <Play_Tune+0x106>
    {
        if(Duration)        // Check if the lenght of the tone has "expired"
    294a:	80 91 81 01 	lds	r24, 0x0181
    294e:	88 23       	and	r24, r24
    2950:	21 f0       	breq	.+8      	; 0x295a <Play_Tune+0x3c>
        {   
            Duration--;
    2952:	81 50       	subi	r24, 0x01	; 1
    2954:	80 93 81 01 	sts	0x0181, r24
    2958:	5e c0       	rjmp	.+188    	; 0x2a16 <Play_Tune+0xf8>
        }
        // mt: else if(*(pSong + Tone))    // If not the end of the song
        else if(pgm_read_word(pSong + Tone))  // If not the end of the song
    295a:	20 91 c8 01 	lds	r18, 0x01C8
    295e:	30 91 c9 01 	lds	r19, 0x01C9
    2962:	80 91 80 01 	lds	r24, 0x0180
    2966:	e8 2f       	mov	r30, r24
    2968:	f0 e0       	ldi	r31, 0x00	; 0
    296a:	ee 0f       	add	r30, r30
    296c:	ff 1f       	adc	r31, r31
    296e:	e2 0f       	add	r30, r18
    2970:	f3 1f       	adc	r31, r19
    2972:	65 91       	lpm	r22, Z+
    2974:	74 91       	lpm	r23, Z+
    2976:	48 2f       	mov	r20, r24
    2978:	4f 5f       	subi	r20, 0xFF	; 255
    297a:	61 15       	cp	r22, r1
    297c:	71 05       	cpc	r23, r1
    297e:	59 f1       	breq	.+86     	; 0x29d6 <Play_Tune+0xb8>
        {
            // mt: Duration = ( DURATION_SEED / *(pSong + Tone) );  // store the duration
            Duration = ( DURATION_SEED / pgm_read_word(pSong + Tone) );  // store the duration
    2980:	80 e2       	ldi	r24, 0x20	; 32
    2982:	90 e0       	ldi	r25, 0x00	; 0
    2984:	70 d4       	rcall	.+2272   	; 0x3266 <__udivmodhi4>
    2986:	60 93 81 01 	sts	0x0181, r22
        
            Tone++;                     // point to the next tone in the Song-table        

            temp_tone=pgm_read_word(pSong + Tone); // mt 200301
    298a:	e4 2f       	mov	r30, r20
    298c:	f0 e0       	ldi	r31, 0x00	; 0
    298e:	ee 0f       	add	r30, r30
    2990:	ff 1f       	adc	r31, r31
    2992:	e2 0f       	add	r30, r18
    2994:	f3 1f       	adc	r31, r19
    2996:	25 91       	lpm	r18, Z+
    2998:	34 91       	lpm	r19, Z+
            // mt: if( (*(pSong + Tone) == p) | (*(pSong + Tone) == P) ) // if pause
            // if( (pgm_read_word(pSong + Tone) == p) | (pgm_read_word(pSong + Tone) == P) ) // if pause
            if( (temp_tone == p) || (temp_tone == P) ) // if pause
    299a:	21 30       	cpi	r18, 0x01	; 1
    299c:	31 05       	cpc	r19, r1
    299e:	21 f4       	brne	.+8      	; 0x29a8 <Play_Tune+0x8a>
                cbiBF(TCCR1B, CS10);             // stop Timer1, prescaler(1)    
    29a0:	80 91 81 00 	lds	r24, 0x0081
    29a4:	8e 7f       	andi	r24, 0xFE	; 254
    29a6:	03 c0       	rjmp	.+6      	; 0x29ae <Play_Tune+0x90>
            else 
                sbiBF(TCCR1B, CS10);             // start Timer1, prescaler(1)  
    29a8:	80 91 81 00 	lds	r24, 0x0081
    29ac:	81 60       	ori	r24, 0x01	; 1
    29ae:	80 93 81 00 	sts	0x0081, r24
                
            cli(); // mt __disable_interrupt();
    29b2:	f8 94       	cli
            // mt temp_hi = *(pSong + Tone);      // read out the PWM-value
            // temp_hi = pgm_read_word(pSong + Tone);      // read out the PWM-value
            temp_hi = temp_tone;   // mt 200301
            temp_hi >>= 8;                  // move integer 8 bits to the rigth
                
            TCNT1H = 0;                     // reset TCNT1H/L
    29b4:	10 92 85 00 	sts	0x0085, r1
            TCNT1L = 0;
    29b8:	10 92 84 00 	sts	0x0084, r1
            
            ICR1H = temp_hi;                // load ICR1H/L
    29bc:	83 2f       	mov	r24, r19
    29be:	99 27       	eor	r25, r25
    29c0:	87 fd       	sbrc	r24, 7
    29c2:	9a 95       	dec	r25
    29c4:	80 93 87 00 	sts	0x0087, r24
            // mt: ICR1L = *(pSong + Tone);        
            // ICR1L = pgm_read_word(pSong + Tone);
            ICR1L = temp_tone;
    29c8:	20 93 86 00 	sts	0x0086, r18
            
            sei(); // mt: __enable_interrupt();
    29cc:	78 94       	sei
            
            Tone++;                     // point to the next tone in the Song-table
    29ce:	4f 5f       	subi	r20, 0xFF	; 255
    29d0:	40 93 80 01 	sts	0x0180, r20
    29d4:	20 c0       	rjmp	.+64     	; 0x2a16 <Play_Tune+0xf8>
        else    // the end of song
        {
            Tone++;         // point to the next tone in the Song-table        
            
            // mt: loop = *(pSong + Tone); // get the byte that tells if the song should loop or not
            loop = (uint8_t)pgm_read_word(pSong + Tone); // get the byte that tells if the song should loop or not
    29d6:	e4 2f       	mov	r30, r20
    29d8:	f0 e0       	ldi	r31, 0x00	; 0
    29da:	ee 0f       	add	r30, r30
    29dc:	ff 1f       	adc	r31, r31
    29de:	e2 0f       	add	r30, r18
    29e0:	f3 1f       	adc	r31, r19
    29e2:	85 91       	lpm	r24, Z+
    29e4:	94 91       	lpm	r25, Z+
            
            if( loop )  
    29e6:	88 23       	and	r24, r24
    29e8:	21 f0       	breq	.+8      	; 0x29f2 <Play_Tune+0xd4>
            {
                Tone = 1;
    29ea:	81 e0       	ldi	r24, 0x01	; 1
    29ec:	80 93 80 01 	sts	0x0180, r24
    29f0:	12 c0       	rjmp	.+36     	; 0x2a16 <Play_Tune+0xf8>
            }
            else        // if not looping the song
            {
                Tone = 0;
    29f2:	10 92 80 01 	sts	0x0180, r1
                gPlaying = FALSE;
    29f6:	10 92 7f 01 	sts	0x017F, r1
                cbiBF(TCCR1B, 0);                     // stop Playing
    29fa:	80 91 81 00 	lds	r24, 0x0081
    29fe:	8e 7f       	andi	r24, 0xFE	; 254
    2a00:	80 93 81 00 	sts	0x0081, r24
                Timer0_RemoveCallbackFunction(Play_Tune);
    2a04:	8f e8       	ldi	r24, 0x8F	; 143
    2a06:	94 e1       	ldi	r25, 0x14	; 20
    2a08:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <Timer0_RemoveCallbackFunction>
                TCCR1A = 0;
    2a0c:	10 92 80 00 	sts	0x0080, r1
                TCCR1B = 0;
    2a10:	10 92 81 00 	sts	0x0081, r1
                sbiBF(PORTB, 5);              // set OC1A high
    2a14:	2d 9a       	sbi	0x05, 5	; 5
            }
        }
        
        // mt: Tempo = *(pSong + 0);
        Tempo = (uint8_t)pgm_read_word(pSong + 0);
    2a16:	e0 91 c8 01 	lds	r30, 0x01C8
    2a1a:	f0 91 c9 01 	lds	r31, 0x01C9
    2a1e:	85 91       	lpm	r24, Z+
    2a20:	94 91       	lpm	r25, Z+
    2a22:	01 c0       	rjmp	.+2      	; 0x2a26 <Play_Tune+0x108>
    }
    else
        Tempo--;
    2a24:	81 50       	subi	r24, 0x01	; 1
    2a26:	80 93 83 01 	sts	0x0183, r24
    2a2a:	08 95       	ret

00002a2c <showSongName>:
*
*****************************************************************************/
// mt inserted local helper to save some flash-space
static void showSongName(unsigned char songnum)
{
    LCD_puts_f((PGM_P)pgm_read_word(&TEXT_SONG_TBL[songnum]), 1);  // mt   // Set up the a song in the LCD
    2a2c:	e8 2f       	mov	r30, r24
    2a2e:	f0 e0       	ldi	r31, 0x00	; 0
    2a30:	ee 0f       	add	r30, r30
    2a32:	ff 1f       	adc	r31, r31
    2a34:	ec 5a       	subi	r30, 0xAC	; 172
    2a36:	f4 4f       	sbci	r31, 0xF4	; 244
    2a38:	85 91       	lpm	r24, Z+
    2a3a:	94 91       	lpm	r25, Z+
    2a3c:	61 e0       	ldi	r22, 0x01	; 1
}
    2a3e:	3d cd       	rjmp	.-1414   	; 0x24ba <LCD_puts_f>

00002a40 <SelectSound>:

char SelectSound(char input)
{
    2a40:	1f 93       	push	r17
    2a42:	18 2f       	mov	r17, r24
    static char enter = 1;
    // mt static char song = 0;
    static uint8_t song = 0;
    
    
    if (enter)
    2a44:	80 91 61 01 	lds	r24, 0x0161
    2a48:	88 23       	and	r24, r24
    2a4a:	99 f0       	breq	.+38     	; 0x2a72 <SelectSound+0x32>
    {
        enter = 0;
    2a4c:	10 92 61 01 	sts	0x0161, r1
        
        // mt LCD_puts_f((PGM_P)pgm_read_word(&TEXT_SONG_TBL[song]), 1);  // mt   // Set up the a song in the LCD
        showSongName(song);
    2a50:	80 91 82 01 	lds	r24, 0x0182
    2a54:	eb df       	rcall	.-42     	; 0x2a2c <showSongName>

        // mt pSong = Songs[song];            // point to this song             
        pSong=(int*)pgm_read_word(&Songs[song]); // looks too complicated...
    2a56:	80 91 82 01 	lds	r24, 0x0182
    2a5a:	e8 2f       	mov	r30, r24
    2a5c:	f0 e0       	ldi	r31, 0x00	; 0
    2a5e:	ee 0f       	add	r30, r30
    2a60:	ff 1f       	adc	r31, r31
    2a62:	ee 5b       	subi	r30, 0xBE	; 190
    2a64:	f4 4f       	sbci	r31, 0xF4	; 244
    2a66:	85 91       	lpm	r24, Z+
    2a68:	94 91       	lpm	r25, Z+
    2a6a:	90 93 c9 01 	sts	0x01C9, r25
    2a6e:	80 93 c8 01 	sts	0x01C8, r24

    }      
        
    if (input == KEY_PLUS)  // shift to next song
    2a72:	14 30       	cpi	r17, 0x04	; 4
    2a74:	41 f5       	brne	.+80     	; 0x2ac6 <SelectSound+0x86>
    {
        if(!song)       // wrap around the table
    2a76:	80 91 82 01 	lds	r24, 0x0182
    2a7a:	88 23       	and	r24, r24
    2a7c:	99 f4       	brne	.+38     	; 0x2aa4 <SelectSound+0x64>
    2a7e:	21 e0       	ldi	r18, 0x01	; 1
        {
            for(song=1; pgm_read_word(&TEXT_SONG_TBL[song]); song++){}; // mt
    2a80:	e2 2f       	mov	r30, r18
    2a82:	f0 e0       	ldi	r31, 0x00	; 0
    2a84:	ee 0f       	add	r30, r30
    2a86:	ff 1f       	adc	r31, r31
    2a88:	ec 5a       	subi	r30, 0xAC	; 172
    2a8a:	f4 4f       	sbci	r31, 0xF4	; 244
    2a8c:	85 91       	lpm	r24, Z+
    2a8e:	94 91       	lpm	r25, Z+
    2a90:	32 2f       	mov	r19, r18
    2a92:	3f 5f       	subi	r19, 0xFF	; 255
    2a94:	89 2b       	or	r24, r25
    2a96:	11 f0       	breq	.+4      	; 0x2a9c <SelectSound+0x5c>
    2a98:	23 2f       	mov	r18, r19
    2a9a:	f2 cf       	rjmp	.-28     	; 0x2a80 <SelectSound+0x40>
            
            song--;
    2a9c:	21 50       	subi	r18, 0x01	; 1
    2a9e:	20 93 82 01 	sts	0x0182, r18
    2aa2:	03 c0       	rjmp	.+6      	; 0x2aaa <SelectSound+0x6a>
        }    
        else
            song--;
    2aa4:	81 50       	subi	r24, 0x01	; 1
    2aa6:	80 93 82 01 	sts	0x0182, r24

        // mt LCD_puts_f((PGM_P)pgm_read_word(&TEXT_SONG_TBL[song]), 1); // mt
        showSongName(song);
    2aaa:	80 91 82 01 	lds	r24, 0x0182
    2aae:	be df       	rcall	.-132    	; 0x2a2c <showSongName>
        
        // mt pSong = Songs[song];
        pSong=(int*)pgm_read_word(&Songs[song]); 
    2ab0:	80 91 82 01 	lds	r24, 0x0182
    2ab4:	e8 2f       	mov	r30, r24
    2ab6:	f0 e0       	ldi	r31, 0x00	; 0
    2ab8:	ee 0f       	add	r30, r30
    2aba:	ff 1f       	adc	r31, r31
    2abc:	ee 5b       	subi	r30, 0xBE	; 190
    2abe:	f4 4f       	sbci	r31, 0xF4	; 244
    2ac0:	85 91       	lpm	r24, Z+
    2ac2:	94 91       	lpm	r25, Z+
    2ac4:	20 c0       	rjmp	.+64     	; 0x2b06 <SelectSound+0xc6>

    }    
    else if (input == KEY_MINUS)    // shift to next song
    2ac6:	15 30       	cpi	r17, 0x05	; 5
    2ac8:	19 f5       	brne	.+70     	; 0x2b10 <SelectSound+0xd0>
    {
        song++;
    2aca:	80 91 82 01 	lds	r24, 0x0182
    2ace:	8f 5f       	subi	r24, 0xFF	; 255
    2ad0:	80 93 82 01 	sts	0x0182, r24

        if( !(pgm_read_word(&TEXT_SONG_TBL[song])) )       // wrap around the table
    2ad4:	e8 2f       	mov	r30, r24
    2ad6:	f0 e0       	ldi	r31, 0x00	; 0
    2ad8:	ee 0f       	add	r30, r30
    2ada:	ff 1f       	adc	r31, r31
    2adc:	ec 5a       	subi	r30, 0xAC	; 172
    2ade:	f4 4f       	sbci	r31, 0xF4	; 244
    2ae0:	85 91       	lpm	r24, Z+
    2ae2:	94 91       	lpm	r25, Z+
    2ae4:	89 2b       	or	r24, r25
    2ae6:	11 f4       	brne	.+4      	; 0x2aec <SelectSound+0xac>
            song = 0;
    2ae8:	10 92 82 01 	sts	0x0182, r1
        
        // mt LCD_puts_f((PGM_P)pgm_read_word(&TEXT_SONG_TBL[song]), 1);
        showSongName(song);
    2aec:	80 91 82 01 	lds	r24, 0x0182
    2af0:	9d df       	rcall	.-198    	; 0x2a2c <showSongName>
        
        // mt pSong = Songs[song];
        pSong=(int*)pgm_read_word(&Songs[song]);
    2af2:	80 91 82 01 	lds	r24, 0x0182
    2af6:	e8 2f       	mov	r30, r24
    2af8:	f0 e0       	ldi	r31, 0x00	; 0
    2afa:	ee 0f       	add	r30, r30
    2afc:	ff 1f       	adc	r31, r31
    2afe:	ee 5b       	subi	r30, 0xBE	; 190
    2b00:	f4 4f       	sbci	r31, 0xF4	; 244
    2b02:	85 91       	lpm	r24, Z+
    2b04:	94 91       	lpm	r25, Z+
    2b06:	90 93 c9 01 	sts	0x01C9, r25
    2b0a:	80 93 c8 01 	sts	0x01C8, r24
    2b0e:	08 c0       	rjmp	.+16     	; 0x2b20 <SelectSound+0xe0>
    }  
    else if(input == KEY_ENTER)     // start playing
    2b10:	11 30       	cpi	r17, 0x01	; 1
    2b12:	21 f4       	brne	.+8      	; 0x2b1c <SelectSound+0xdc>
    {
        enter = 1;
    2b14:	10 93 61 01 	sts	0x0161, r17
    2b18:	8b e2       	ldi	r24, 0x2B	; 43
    2b1a:	08 c0       	rjmp	.+16     	; 0x2b2c <SelectSound+0xec>
        return ST_MUSIC_PLAY;
    }
    else if (input == KEY_PREV)
    2b1c:	13 30       	cpi	r17, 0x03	; 3
    2b1e:	11 f0       	breq	.+4      	; 0x2b24 <SelectSound+0xe4>
    2b20:	8a e2       	ldi	r24, 0x2A	; 42
    2b22:	04 c0       	rjmp	.+8      	; 0x2b2c <SelectSound+0xec>
    {
        enter = 1;
    2b24:	81 e0       	ldi	r24, 0x01	; 1
    2b26:	80 93 61 01 	sts	0x0161, r24
    2b2a:	88 e2       	ldi	r24, 0x28	; 40
        return ST_MUSIC;
    }    
        
    return ST_MUSIC_SELECT;
}
    2b2c:	1f 91       	pop	r17
    2b2e:	08 95       	ret

00002b30 <Sound_Init>:
*   Purpose :       Set up Timer1 with PWM
*
*****************************************************************************/
void Sound_Init(void)
{
    TCCR1A = (1<<COM1A1);// | (1<<COM1A0); // Set OC1A when upcounting, clear when downcounting
    2b30:	80 e8       	ldi	r24, 0x80	; 128
    2b32:	80 93 80 00 	sts	0x0080, r24
    TCCR1B = (1<<WGM13);        // Phase/Freq-correct PWM, top value = ICR1
    2b36:	e1 e8       	ldi	r30, 0x81	; 129
    2b38:	f0 e0       	ldi	r31, 0x00	; 0
    2b3a:	80 e1       	ldi	r24, 0x10	; 16
    2b3c:	80 83       	st	Z, r24
    
    sbiBF(TCCR1B, CS10);             // start Timer1, prescaler(1)    
    2b3e:	80 81       	ld	r24, Z
    2b40:	81 60       	ori	r24, 0x01	; 1
    2b42:	80 83       	st	Z, r24
    
    OCR1AH = 0;        // Set a initial value in the OCR1A-register
    2b44:	10 92 89 00 	sts	0x0089, r1
    OCR1AL = Volume;   // This will adjust the volume on the buzzer, lower value => higher volume
    2b48:	80 91 5f 01 	lds	r24, 0x015F
    2b4c:	80 93 88 00 	sts	0x0088, r24
    
    Timer0_RegisterCallbackFunction(Play_Tune);     // Timer/Counter0 keeps the right beat
    2b50:	8f e8       	ldi	r24, 0x8F	; 143
    2b52:	94 e1       	ldi	r25, 0x14	; 20
    2b54:	0c 94 47 09 	jmp	0x128e	; 0x128e <Timer0_RegisterCallbackFunction>

00002b58 <Sound>:
*
*   Purpose :       Start/stop timers, adjust volume 
*
*****************************************************************************/
char Sound(char input)
{
    2b58:	1f 93       	push	r17
    2b5a:	18 2f       	mov	r17, r24
    static char enter = 1;

    if (enter)
    2b5c:	80 91 60 01 	lds	r24, 0x0160
    2b60:	88 23       	and	r24, r24
    2b62:	69 f0       	breq	.+26     	; 0x2b7e <Sound+0x26>
    {
        enter = 0;
    2b64:	10 92 60 01 	sts	0x0160, r1
        Tone = 0;
    2b68:	10 92 80 01 	sts	0x0180, r1
        Sound_Init();           // start playing
    2b6c:	e1 df       	rcall	.-62     	; 0x2b30 <Sound_Init>
        LCD_puts_f(PLAYING, 1);
    2b6e:	86 e6       	ldi	r24, 0x66	; 102
    2b70:	9b e0       	ldi	r25, 0x0B	; 11
    2b72:	61 e0       	ldi	r22, 0x01	; 1
    2b74:	a2 dc       	rcall	.-1724   	; 0x24ba <LCD_puts_f>
        gPlaying = TRUE;
    2b76:	81 e0       	ldi	r24, 0x01	; 1
    2b78:	80 93 7f 01 	sts	0x017F, r24
    2b7c:	0d c0       	rjmp	.+26     	; 0x2b98 <Sound+0x40>
    }        
    else if (!gPlaying)
    2b7e:	80 91 7f 01 	lds	r24, 0x017F
    2b82:	88 23       	and	r24, r24
    2b84:	49 f4       	brne	.+18     	; 0x2b98 <Sound+0x40>
    {
        Timer0_RemoveCallbackFunction(Play_Tune);
    2b86:	8f e8       	ldi	r24, 0x8F	; 143
    2b88:	94 e1       	ldi	r25, 0x14	; 20
    2b8a:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <Timer0_RemoveCallbackFunction>
        TCCR1A = 0;
    2b8e:	10 92 80 00 	sts	0x0080, r1
        TCCR1B = 0;
    2b92:	10 92 81 00 	sts	0x0081, r1
    2b96:	55 c0       	rjmp	.+170    	; 0x2c42 <Sound+0xea>
        enter = 1;
        return ST_MUSIC_SELECT;
    }
    
    if (input == KEY_PLUS)          // increase the volum
    2b98:	14 30       	cpi	r17, 0x04	; 4
    2b9a:	41 f4       	brne	.+16     	; 0x2bac <Sound+0x54>
    {
        if(Volume >= 80)
    2b9c:	80 91 5f 01 	lds	r24, 0x015F
    2ba0:	80 35       	cpi	r24, 0x50	; 80
    2ba2:	10 f0       	brcs	.+4      	; 0x2ba8 <Sound+0x50>
            Volume = 80;
    2ba4:	80 e5       	ldi	r24, 0x50	; 80
    2ba6:	0b c0       	rjmp	.+22     	; 0x2bbe <Sound+0x66>
        else
            Volume += 5;
    2ba8:	8b 5f       	subi	r24, 0xFB	; 251
    2baa:	09 c0       	rjmp	.+18     	; 0x2bbe <Sound+0x66>

        OCR1AH = 0;
        OCR1AL = Volume;
    }
    else if (input == KEY_MINUS)    // decrease the volum
    2bac:	15 30       	cpi	r17, 0x05	; 5
    2bae:	81 f4       	brne	.+32     	; 0x2bd0 <Sound+0x78>
    {
        if(Volume < 11)
    2bb0:	80 91 5f 01 	lds	r24, 0x015F
    2bb4:	8b 30       	cpi	r24, 0x0B	; 11
    2bb6:	10 f4       	brcc	.+4      	; 0x2bbc <Sound+0x64>
            Volume = 6;
    2bb8:	86 e0       	ldi	r24, 0x06	; 6
    2bba:	01 c0       	rjmp	.+2      	; 0x2bbe <Sound+0x66>
        else
            Volume -= 5;   
    2bbc:	85 50       	subi	r24, 0x05	; 5
    2bbe:	80 93 5f 01 	sts	0x015F, r24
        
        OCR1AH = 0;
    2bc2:	10 92 89 00 	sts	0x0089, r1
        OCR1AL = Volume;
    2bc6:	80 91 5f 01 	lds	r24, 0x015F
    2bca:	80 93 88 00 	sts	0x0088, r24
    2bce:	27 c0       	rjmp	.+78     	; 0x2c1e <Sound+0xc6>
    }         
    
    if (input == KEY_ENTER)         // start/stop playing
    2bd0:	11 30       	cpi	r17, 0x01	; 1
    2bd2:	19 f5       	brne	.+70     	; 0x2c1a <Sound+0xc2>
    {   
        if (gPlaying)
    2bd4:	80 91 7f 01 	lds	r24, 0x017F
    2bd8:	88 23       	and	r24, r24
    2bda:	99 f0       	breq	.+38     	; 0x2c02 <Sound+0xaa>
        {
            gPlaying = FALSE;
    2bdc:	10 92 7f 01 	sts	0x017F, r1
            cbiBF(TCCR1B, 0);                     // stop Playing
    2be0:	80 91 81 00 	lds	r24, 0x0081
    2be4:	8e 7f       	andi	r24, 0xFE	; 254
    2be6:	80 93 81 00 	sts	0x0081, r24
            Timer0_RemoveCallbackFunction(Play_Tune);
    2bea:	8f e8       	ldi	r24, 0x8F	; 143
    2bec:	94 e1       	ldi	r25, 0x14	; 20
    2bee:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <Timer0_RemoveCallbackFunction>
            TCCR1A = 0;
    2bf2:	10 92 80 00 	sts	0x0080, r1
            TCCR1B = 0;
    2bf6:	10 92 81 00 	sts	0x0081, r1
            sbiBF(PORTB, 5);              // set OC1A high
    2bfa:	2d 9a       	sbi	0x05, 5	; 5
            enter = 1;
    2bfc:	10 93 60 01 	sts	0x0160, r17
    2c00:	23 c0       	rjmp	.+70     	; 0x2c48 <Sound+0xf0>
            return ST_MUSIC_SELECT;
        }
        else
        {   
            Duration = 0;                       // start Playing
    2c02:	10 92 81 01 	sts	0x0181, r1
            Tone = 1;
    2c06:	10 93 80 01 	sts	0x0180, r17
            Sound_Init();
    2c0a:	92 df       	rcall	.-220    	; 0x2b30 <Sound_Init>
            LCD_puts_f(PLAYING, 1);            
    2c0c:	86 e6       	ldi	r24, 0x66	; 102
    2c0e:	9b e0       	ldi	r25, 0x0B	; 11
    2c10:	61 e0       	ldi	r22, 0x01	; 1
    2c12:	53 dc       	rcall	.-1882   	; 0x24ba <LCD_puts_f>
            gPlaying = TRUE;
    2c14:	10 93 7f 01 	sts	0x017F, r17
    2c18:	02 c0       	rjmp	.+4      	; 0x2c1e <Sound+0xc6>
        }
    }
    else if (input == KEY_PREV)
    2c1a:	13 30       	cpi	r17, 0x03	; 3
    2c1c:	11 f0       	breq	.+4      	; 0x2c22 <Sound+0xca>
    2c1e:	8b e2       	ldi	r24, 0x2B	; 43
    2c20:	14 c0       	rjmp	.+40     	; 0x2c4a <Sound+0xf2>
    {
        gPlaying = FALSE;
    2c22:	10 92 7f 01 	sts	0x017F, r1
        cbiBF(TCCR1B, 0);                     // stop Playing
    2c26:	80 91 81 00 	lds	r24, 0x0081
    2c2a:	8e 7f       	andi	r24, 0xFE	; 254
    2c2c:	80 93 81 00 	sts	0x0081, r24
        Timer0_RemoveCallbackFunction(Play_Tune);
    2c30:	8f e8       	ldi	r24, 0x8F	; 143
    2c32:	94 e1       	ldi	r25, 0x14	; 20
    2c34:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <Timer0_RemoveCallbackFunction>
        TCCR1A = 0;
    2c38:	10 92 80 00 	sts	0x0080, r1
        TCCR1B = 0;
    2c3c:	10 92 81 00 	sts	0x0081, r1
        sbiBF(PORTB, 5);              // set OC1A high
    2c40:	2d 9a       	sbi	0x05, 5	; 5
        enter = 1;
    2c42:	81 e0       	ldi	r24, 0x01	; 1
    2c44:	80 93 60 01 	sts	0x0160, r24
    2c48:	8a e2       	ldi	r24, 0x2A	; 42
        return ST_MUSIC_SELECT;
    }
        
    return ST_MUSIC_PLAY;
}
    2c4a:	1f 91       	pop	r17
    2c4c:	08 95       	ret

00002c4e <ErrorBeep>:
    // mtE
    while(1);                       //wait for WD-reset
}

void ErrorBeep(void)
{
    2c4e:	8f 92       	push	r8
    2c50:	9f 92       	push	r9
    2c52:	bf 92       	push	r11
    2c54:	cf 92       	push	r12
    2c56:	df 92       	push	r13
    2c58:	ef 92       	push	r14
    2c5a:	ff 92       	push	r15
    2c5c:	0f 93       	push	r16
    2c5e:	1f 93       	push	r17
    TCCR1A = (1<<COM1A1);// | (1<<COM1A0); // Set OC1A when upcounting, clear when downcounting
    2c60:	20 e8       	ldi	r18, 0x80	; 128
    2c62:	82 2e       	mov	r8, r18
    2c64:	91 2c       	mov	r9, r1
    2c66:	80 e8       	ldi	r24, 0x80	; 128
    2c68:	f4 01       	movw	r30, r8
    2c6a:	80 83       	st	Z, r24
    TCCR1B = (1<<WGM13) | (1<<CS10);        // Phase/Freq-correct PWM, top value = ICR1
    2c6c:	01 e8       	ldi	r16, 0x81	; 129
    2c6e:	10 e0       	ldi	r17, 0x00	; 0
    2c70:	81 e1       	ldi	r24, 0x11	; 17
    2c72:	f8 01       	movw	r30, r16
    2c74:	80 83       	st	Z, r24
    
    sbiBF(TCCR1B, 0);             // start Timer1, prescaler(1)    
    2c76:	80 81       	ld	r24, Z
    2c78:	81 60       	ori	r24, 0x01	; 1
    2c7a:	80 83       	st	Z, r24
    
    OCR1AH = 0;     // Set a initial value in the OCR1A-register
    2c7c:	10 92 89 00 	sts	0x0089, r1
    OCR1AL = 80;     // This will adjust the volume on the buzzer, lower value => higher volume
    2c80:	80 e5       	ldi	r24, 0x50	; 80
    2c82:	80 93 88 00 	sts	0x0088, r24
    
    ICR1H = 1;
    2c86:	97 e8       	ldi	r25, 0x87	; 135
    2c88:	c9 2e       	mov	r12, r25
    2c8a:	d1 2c       	mov	r13, r1
    2c8c:	bb 24       	eor	r11, r11
    2c8e:	b3 94       	inc	r11
    2c90:	f6 01       	movw	r30, r12
    2c92:	b0 82       	st	Z, r11
    ICR1L = 0x3F;
    2c94:	86 e8       	ldi	r24, 0x86	; 134
    2c96:	e8 2e       	mov	r14, r24
    2c98:	f1 2c       	mov	r15, r1
    2c9a:	8f e3       	ldi	r24, 0x3F	; 63
    2c9c:	f7 01       	movw	r30, r14
    2c9e:	80 83       	st	Z, r24

    Delay(50);
    2ca0:	82 e3       	ldi	r24, 0x32	; 50
    2ca2:	90 e0       	ldi	r25, 0x00	; 0
    2ca4:	0e 94 23 06 	call	0xc46	; 0xc46 <Delay>

    ICR1H = 1;
    2ca8:	f6 01       	movw	r30, r12
    2caa:	b0 82       	st	Z, r11
    ICR1L = 0xDE;
    2cac:	8e ed       	ldi	r24, 0xDE	; 222
    2cae:	f7 01       	movw	r30, r14
    2cb0:	80 83       	st	Z, r24

    Delay(300);
    2cb2:	8c e2       	ldi	r24, 0x2C	; 44
    2cb4:	91 e0       	ldi	r25, 0x01	; 1
    2cb6:	0e 94 23 06 	call	0xc46	; 0xc46 <Delay>
    
    TCCR1A = 0;
    2cba:	f4 01       	movw	r30, r8
    2cbc:	10 82       	st	Z, r1
    TCCR1B = 0;
    2cbe:	f8 01       	movw	r30, r16
    2cc0:	10 82       	st	Z, r1
}
    2cc2:	1f 91       	pop	r17
    2cc4:	0f 91       	pop	r16
    2cc6:	ff 90       	pop	r15
    2cc8:	ef 90       	pop	r14
    2cca:	df 90       	pop	r13
    2ccc:	cf 90       	pop	r12
    2cce:	bf 90       	pop	r11
    2cd0:	9f 90       	pop	r9
    2cd2:	8f 90       	pop	r8
    2cd4:	08 95       	ret

00002cd6 <TestWaitEnter>:
static void TestWaitEnter(void)
{
    char input = 0;
    while(input != KEY_ENTER)
    {
        input = getkey();           // Read buttons
    2cd6:	7f da       	rcall	.-2818   	; 0x21d6 <getkey>

// mtA
static void TestWaitEnter(void)
{
    char input = 0;
    while(input != KEY_ENTER)
    2cd8:	81 30       	cpi	r24, 0x01	; 1
    2cda:	e9 f7       	brne	.-6      	; 0x2cd6 <TestWaitEnter>
    {
        input = getkey();           // Read buttons
    }
}
    2cdc:	08 95       	ret

00002cde <Test>:
// mtE

void Test(void)
{
    2cde:	1f 93       	push	r17
    2ce0:	cf 93       	push	r28
    2ce2:	df 93       	push	r29
    char j;
    
    int integer;
    int temp_hi;
    
    TIMSK2 = 0; // Stop clock, the interrupt will disturb the sound-test cause
    2ce4:	10 92 70 00 	sts	0x0070, r1
                // the play-routine doesn't use interrupt...

//mtA    
    LCD_puts_f(PSTR("Test"),0); // mt LCD_puts("Test",0);
    2ce8:	86 ec       	ldi	r24, 0xC6	; 198
    2cea:	9b e0       	ldi	r25, 0x0B	; 11
    2cec:	60 e0       	ldi	r22, 0x00	; 0
    2cee:	e5 db       	rcall	.-2102   	; 0x24ba <LCD_puts_f>
    TestWaitEnter();
    2cf0:	f2 df       	rcall	.-28     	; 0x2cd6 <TestWaitEnter>
//mtE


//// //// //// //// JOYSTICK TEST //// //// //// ////

    LCD_puts_f(PSTR("Left"),0);// mt LCD_puts("Left",0);
    2cf2:	81 ec       	ldi	r24, 0xC1	; 193
    2cf4:	9b e0       	ldi	r25, 0x0B	; 11
    2cf6:	60 e0       	ldi	r22, 0x00	; 0
    2cf8:	e0 db       	rcall	.-2112   	; 0x24ba <LCD_puts_f>
    
    while(input != KEY_PREV)
    {
        input = getkey();           // Read buttons
    2cfa:	6d da       	rcall	.-2854   	; 0x21d6 <getkey>

//// //// //// //// JOYSTICK TEST //// //// //// ////

    LCD_puts_f(PSTR("Left"),0);// mt LCD_puts("Left",0);
    
    while(input != KEY_PREV)
    2cfc:	83 30       	cpi	r24, 0x03	; 3
    2cfe:	e9 f7       	brne	.-6      	; 0x2cfa <Test+0x1c>
    {
        input = getkey();           // Read buttons
    }
    
    LCD_puts_f(PSTR("Up"),0);// mt LCD_puts("Up",0);
    2d00:	8e eb       	ldi	r24, 0xBE	; 190
    2d02:	9b e0       	ldi	r25, 0x0B	; 11
    2d04:	60 e0       	ldi	r22, 0x00	; 0
    2d06:	d9 db       	rcall	.-2126   	; 0x24ba <LCD_puts_f>
    
    while(input != KEY_PLUS)
    {
        input = getkey();           // Read buttons
    2d08:	66 da       	rcall	.-2868   	; 0x21d6 <getkey>
        input = getkey();           // Read buttons
    }
    
    LCD_puts_f(PSTR("Up"),0);// mt LCD_puts("Up",0);
    
    while(input != KEY_PLUS)
    2d0a:	84 30       	cpi	r24, 0x04	; 4
    2d0c:	e9 f7       	brne	.-6      	; 0x2d08 <Test+0x2a>
    {
        input = getkey();           // Read buttons
    }
    
    LCD_puts_f(PSTR("Right"),0);// mt LCD_puts("Right",0);
    2d0e:	88 eb       	ldi	r24, 0xB8	; 184
    2d10:	9b e0       	ldi	r25, 0x0B	; 11
    2d12:	60 e0       	ldi	r22, 0x00	; 0
    2d14:	d2 db       	rcall	.-2140   	; 0x24ba <LCD_puts_f>
    
    while(input != KEY_NEXT)
    {
        input = getkey();           // Read buttons
    2d16:	5f da       	rcall	.-2882   	; 0x21d6 <getkey>
        input = getkey();           // Read buttons
    }
    
    LCD_puts_f(PSTR("Right"),0);// mt LCD_puts("Right",0);
    
    while(input != KEY_NEXT)
    2d18:	82 30       	cpi	r24, 0x02	; 2
    2d1a:	e9 f7       	brne	.-6      	; 0x2d16 <Test+0x38>
    {
        input = getkey();           // Read buttons
    }
    
    LCD_puts_f(PSTR("Down"),0);// mt LCD_puts("Down",0);
    2d1c:	83 eb       	ldi	r24, 0xB3	; 179
    2d1e:	9b e0       	ldi	r25, 0x0B	; 11
    2d20:	60 e0       	ldi	r22, 0x00	; 0
    2d22:	cb db       	rcall	.-2154   	; 0x24ba <LCD_puts_f>
    
    while(input != KEY_MINUS)
    {
        input = getkey();           // Read buttons
    2d24:	58 da       	rcall	.-2896   	; 0x21d6 <getkey>
        input = getkey();           // Read buttons
    }
    
    LCD_puts_f(PSTR("Down"),0);// mt LCD_puts("Down",0);
    
    while(input != KEY_MINUS)
    2d26:	85 30       	cpi	r24, 0x05	; 5
    2d28:	e9 f7       	brne	.-6      	; 0x2d24 <Test+0x46>



//// //// //// //// SOUND TEST //// //// //// ////
    
    LCD_puts_f(PSTR("Sound"),0);// mt LCD_puts("Sound",0);
    2d2a:	8d ea       	ldi	r24, 0xAD	; 173
    2d2c:	9b e0       	ldi	r25, 0x0B	; 11
    2d2e:	60 e0       	ldi	r22, 0x00	; 0
    2d30:	c4 db       	rcall	.-2168   	; 0x24ba <LCD_puts_f>
    TestWaitEnter();
    2d32:	d1 df       	rcall	.-94     	; 0x2cd6 <TestWaitEnter>
    
    TCCR1A = (1<<COM1A1);// | (1<<COM1A0); // Set OC1A when upcounting, clear when downcounting
    2d34:	80 e8       	ldi	r24, 0x80	; 128
    2d36:	80 93 80 00 	sts	0x0080, r24
    TCCR1B = (1<<WGM13) | (1<<CS10);        // Phase/Freq-correct PWM, top value = ICR1
    2d3a:	81 e1       	ldi	r24, 0x11	; 17
    2d3c:	80 93 81 00 	sts	0x0081, r24
    
    sbiBF(TCCR1B, 0);             // start Timer1, prescaler(1)    
    2d40:	80 91 81 00 	lds	r24, 0x0081
    2d44:	81 60       	ori	r24, 0x01	; 1
    2d46:	80 93 81 00 	sts	0x0081, r24
    
    OCR1AH = 0;     // Set a initial value in the OCR1A-register
    2d4a:	10 92 89 00 	sts	0x0089, r1
    OCR1AL = 80;     // This will adjust the volume on the buzzer, lower value => higher volume
    2d4e:	80 e5       	ldi	r24, 0x50	; 80
    2d50:	80 93 88 00 	sts	0x0088, r24
    2d54:	18 ec       	ldi	r17, 0xC8	; 200

    for(integer = 200; integer >= 100; integer -= 5)
    {
        temp_hi = integer;
        
        ICR1H = (temp_hi >>= 8);
    2d56:	10 92 87 00 	sts	0x0087, r1
        ICR1L = integer;
    2d5a:	10 93 86 00 	sts	0x0086, r17
    
        Delay(30);
    2d5e:	8e e1       	ldi	r24, 0x1E	; 30
    2d60:	90 e0       	ldi	r25, 0x00	; 0
    2d62:	0e 94 23 06 	call	0xc46	; 0xc46 <Delay>
    2d66:	15 50       	subi	r17, 0x05	; 5
    sbiBF(TCCR1B, 0);             // start Timer1, prescaler(1)    
    
    OCR1AH = 0;     // Set a initial value in the OCR1A-register
    OCR1AL = 80;     // This will adjust the volume on the buzzer, lower value => higher volume

    for(integer = 200; integer >= 100; integer -= 5)
    2d68:	1f 35       	cpi	r17, 0x5F	; 95
    2d6a:	a9 f7       	brne	.-22     	; 0x2d56 <Test+0x78>
    
        Delay(30);
    }


    TCCR1A = 0;
    2d6c:	10 92 80 00 	sts	0x0080, r1
    TCCR1B = 0;     //Stop timer1
    2d70:	10 92 81 00 	sts	0x0081, r1


//// //// //// //// LCD TEST //// //// //// ////    
    
    LCD_puts_f(PSTR("LCD test"),0);// mt LCD_puts("LCD test",0);
    2d74:	84 ea       	ldi	r24, 0xA4	; 164
    2d76:	9b e0       	ldi	r25, 0x0B	; 11
    2d78:	60 e0       	ldi	r22, 0x00	; 0
    2d7a:	9f db       	rcall	.-2242   	; 0x24ba <LCD_puts_f>

    //mtA
    // mt while(!(PINB & (1<<PORTB4)));
    while(!(PINB & (1<<PINB4)));
    2d7c:	1c 9b       	sbis	0x03, 4	; 3
    2d7e:	fe cf       	rjmp	.-4      	; 0x2d7c <Test+0x9e>
    TestWaitEnter();
    2d80:	aa df       	rcall	.-172    	; 0x2cd6 <TestWaitEnter>
    //mtE
    
    cbiBF(LCDCRA, LCDIE);
    2d82:	80 91 e4 00 	lds	r24, 0x00E4
    2d86:	87 7f       	andi	r24, 0xF7	; 247
    2d88:	80 93 e4 00 	sts	0x00E4, r24
    2d8c:	ec ee       	ldi	r30, 0xEC	; 236
    2d8e:	f0 e0       	ldi	r31, 0x00	; 0
    
    for(i = 0; i < 20; i++) // set all LCD segment register to the variable ucSegments
    {
        *(&pLCDREG_test + i) = 0xFF;
    2d90:	8f ef       	ldi	r24, 0xFF	; 255
    2d92:	81 93       	st	Z+, r24
    TestWaitEnter();
    //mtE
    
    cbiBF(LCDCRA, LCDIE);
    
    for(i = 0; i < 20; i++) // set all LCD segment register to the variable ucSegments
    2d94:	91 e0       	ldi	r25, 0x01	; 1
    2d96:	e0 30       	cpi	r30, 0x00	; 0
    2d98:	f9 07       	cpc	r31, r25
    2d9a:	d9 f7       	brne	.-10     	; 0x2d92 <Test+0xb4>
    {
        *(&pLCDREG_test + i) = 0xFF;
    }
    
    // mt while(!(PINB & (1<<PORTB4)));
    while(!(PINB & (1<<PINB4)));
    2d9c:	1c 9b       	sbis	0x03, 4	; 3
    2d9e:	fe cf       	rjmp	.-4      	; 0x2d9c <Test+0xbe>
    
    Delay(100);
    2da0:	84 e6       	ldi	r24, 0x64	; 100
    2da2:	90 e0       	ldi	r25, 0x00	; 0
    2da4:	0e 94 23 06 	call	0xc46	; 0xc46 <Delay>

    // mt while((PINB & (1<<PORTB4)));    //pull PINB cause the LCD interrupt is disabled which 
    while((PINB & (1<<PINB4)));    //pull PINB cause the LCD interrupt is disabled which
    2da8:	1c 99       	sbic	0x03, 4	; 3
    2daa:	fe cf       	rjmp	.-4      	; 0x2da8 <Test+0xca>
                                   //controls the button-bouncing
    sbiBF(LCDCRA, LCDIE);
    2dac:	80 91 e4 00 	lds	r24, 0x00E4
    2db0:	88 60       	ori	r24, 0x08	; 8
    2db2:	80 93 e4 00 	sts	0x00E4, r24


//// //// //// //// TEMPERATURE TEST //// //// //// ////
      
    ADC_init(0);
    2db6:	80 e0       	ldi	r24, 0x00	; 0
    2db8:	0e 94 07 0a 	call	0x140e	; 0x140e <ADC_init>

    integer = ADC_read();
    2dbc:	0e 94 cf 09 	call	0x139e	; 0x139e <ADC_read>
    
    //check if temperature is between 21 and 30 degree Celcius
    if( (integer < 452) || (integer > 586) )  
    2dc0:	84 5c       	subi	r24, 0xC4	; 196
    2dc2:	91 40       	sbci	r25, 0x01	; 1
    2dc4:	87 38       	cpi	r24, 0x87	; 135
    2dc6:	91 05       	cpc	r25, r1
    2dc8:	60 f0       	brcs	.+24     	; 0x2de2 <Test+0x104>
    {
        LCD_puts_f(PSTR("Error Temperature"),0);// mt LCD_puts("Error Temperature",0);
    2dca:	82 e9       	ldi	r24, 0x92	; 146
    2dcc:	9b e0       	ldi	r25, 0x0B	; 11
    2dce:	60 e0       	ldi	r22, 0x00	; 0
    2dd0:	74 db       	rcall	.-2328   	; 0x24ba <LCD_puts_f>
        ErrorBeep();
    2dd2:	3d df       	rcall	.-390    	; 0x2c4e <ErrorBeep>
        TestWaitEnter();
    2dd4:	80 df       	rcall	.-256    	; 0x2cd6 <TestWaitEnter>
        ADC_periphery();
    2dd6:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <ADC_periphery>
        LCD_UpdateRequired(TRUE, 0);
    2dda:	81 e0       	ldi	r24, 0x01	; 1
    2ddc:	60 e0       	ldi	r22, 0x00	; 0
    2dde:	e6 db       	rcall	.-2100   	; 0x25ac <LCD_UpdateRequired>
        TestWaitEnter();
    2de0:	7a df       	rcall	.-268    	; 0x2cd6 <TestWaitEnter>
    }


//// //// //// //// Voltage TEST //// //// //// ////    

    ADC_init(1);
    2de2:	81 e0       	ldi	r24, 0x01	; 1
    2de4:	0e 94 07 0a 	call	0x140e	; 0x140e <ADC_init>
    integer = ADC_read();
    2de8:	0e 94 cf 09 	call	0x139e	; 0x139e <ADC_read>

    //if measuring outside 4,8 to 5,2 V
    if( (integer < 298) || (integer > 320) )
    2dec:	8a 52       	subi	r24, 0x2A	; 42
    2dee:	91 40       	sbci	r25, 0x01	; 1
    2df0:	47 97       	sbiw	r24, 0x17	; 23
    2df2:	60 f0       	brcs	.+24     	; 0x2e0c <Test+0x12e>
    {
        LCD_puts_f(PSTR("Error Voltage"),0);// mt LCD_puts("Error Voltage",0);
    2df4:	84 e8       	ldi	r24, 0x84	; 132
    2df6:	9b e0       	ldi	r25, 0x0B	; 11
    2df8:	60 e0       	ldi	r22, 0x00	; 0
    2dfa:	5f db       	rcall	.-2370   	; 0x24ba <LCD_puts_f>
        ErrorBeep();
    2dfc:	28 df       	rcall	.-432    	; 0x2c4e <ErrorBeep>
        TestWaitEnter();
    2dfe:	6b df       	rcall	.-298    	; 0x2cd6 <TestWaitEnter>
        ADC_periphery();
    2e00:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <ADC_periphery>
        LCD_UpdateRequired(TRUE, 0);
    2e04:	81 e0       	ldi	r24, 0x01	; 1
    2e06:	60 e0       	ldi	r22, 0x00	; 0
    2e08:	d1 db       	rcall	.-2142   	; 0x25ac <LCD_UpdateRequired>
        TestWaitEnter();
    2e0a:	65 df       	rcall	.-310    	; 0x2cd6 <TestWaitEnter>
    }


//// //// //// //// LIGHT TEST //// //// //// ////    

    LCD_puts_f(PSTR("Light"),0);// mt LCD_puts("Light",0);
    2e0c:	8e e7       	ldi	r24, 0x7E	; 126
    2e0e:	9b e0       	ldi	r25, 0x0B	; 11
    2e10:	60 e0       	ldi	r22, 0x00	; 0
    2e12:	53 db       	rcall	.-2394   	; 0x24ba <LCD_puts_f>
    TestWaitEnter();
    2e14:	60 df       	rcall	.-320    	; 0x2cd6 <TestWaitEnter>

    ADC_init(2);
    2e16:	82 e0       	ldi	r24, 0x02	; 2
    2e18:	0e 94 07 0a 	call	0x140e	; 0x140e <ADC_init>
    input = 0;
    
    while(input != KEY_ENTER)
    {
        ADC_read();
    2e1c:	0e 94 cf 09 	call	0x139e	; 0x139e <ADC_read>
        ADC_periphery();
    2e20:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <ADC_periphery>
        // mt __no_operation();
        asm volatile ("nop"::);
    2e24:	00 00       	nop
        LCD_UpdateRequired(TRUE, 0);    
    2e26:	81 e0       	ldi	r24, 0x01	; 1
    2e28:	60 e0       	ldi	r22, 0x00	; 0
    2e2a:	c0 db       	rcall	.-2176   	; 0x25ac <LCD_UpdateRequired>
        input = getkey();           // Read buttons
    2e2c:	d4 d9       	rcall	.-3160   	; 0x21d6 <getkey>
    TestWaitEnter();

    ADC_init(2);
    input = 0;
    
    while(input != KEY_ENTER)
    2e2e:	81 30       	cpi	r24, 0x01	; 1
    2e30:	a9 f7       	brne	.-22     	; 0x2e1c <Test+0x13e>
        LCD_UpdateRequired(TRUE, 0);    
        input = getkey();           // Read buttons
    }


    DF_CS_inactive;
    2e32:	28 9a       	sbi	0x05, 0	; 5
    DF_CS_active;
    2e34:	28 98       	cbi	0x05, 0	; 5
    2e36:	c0 e0       	ldi	r28, 0x00	; 0
    2e38:	d0 e0       	ldi	r29, 0x00	; 0
    
    for(j=0;j<50;j++) {
        Buffer_Write_Byte (1,j,j);
    2e3a:	81 e0       	ldi	r24, 0x01	; 1
    2e3c:	be 01       	movw	r22, r28
    2e3e:	4c 2f       	mov	r20, r28
    2e40:	51 d9       	rcall	.-3422   	; 0x20e4 <Buffer_Write_Byte>
    2e42:	21 96       	adiw	r28, 0x01	; 1


    DF_CS_inactive;
    DF_CS_active;
    
    for(j=0;j<50;j++) {
    2e44:	c2 33       	cpi	r28, 0x32	; 50
    2e46:	d1 05       	cpc	r29, r1
    2e48:	c1 f7       	brne	.-16     	; 0x2e3a <Test+0x15c>
        Buffer_Write_Byte (1,j,j);
    }

    Buffer_To_Page (1,1);             //transfer to DataFlash
    2e4a:	81 e0       	ldi	r24, 0x01	; 1
    2e4c:	61 e0       	ldi	r22, 0x01	; 1
    2e4e:	70 e0       	ldi	r23, 0x00	; 0
    2e50:	61 d9       	rcall	.-3390   	; 0x2114 <Buffer_To_Page>

    DF_CS_inactive;
    2e52:	28 9a       	sbi	0x05, 0	; 5
    DF_CS_active;
    2e54:	28 98       	cbi	0x05, 0	; 5
    
    Cont_Flash_Read_Enable (1,0);
    2e56:	81 e0       	ldi	r24, 0x01	; 1
    2e58:	90 e0       	ldi	r25, 0x00	; 0
    2e5a:	60 e0       	ldi	r22, 0x00	; 0
    2e5c:	70 e0       	ldi	r23, 0x00	; 0
    2e5e:	86 d9       	rcall	.-3316   	; 0x216c <Cont_Flash_Read_Enable>
    2e60:	10 e0       	ldi	r17, 0x00	; 0

    for(j=0;j<50;j++)
    {
        
        if(j != DF_SPI_RW(0x00) )
    2e62:	80 e0       	ldi	r24, 0x00	; 0
    2e64:	18 d9       	rcall	.-3536   	; 0x2096 <DF_SPI_RW>
    2e66:	18 17       	cp	r17, r24
    2e68:	39 f0       	breq	.+14     	; 0x2e78 <Test+0x19a>
        {
            LCD_puts_f(PSTR("Error DataFlash"),0);// mt LCD_puts("Error Dataflash",0);
    2e6a:	8e e6       	ldi	r24, 0x6E	; 110
    2e6c:	9b e0       	ldi	r25, 0x0B	; 11
    2e6e:	60 e0       	ldi	r22, 0x00	; 0
    2e70:	24 db       	rcall	.-2488   	; 0x24ba <LCD_puts_f>
            ErrorBeep();
    2e72:	ed de       	rcall	.-550    	; 0x2c4e <ErrorBeep>
            TestWaitEnter();
    2e74:	30 df       	rcall	.-416    	; 0x2cd6 <TestWaitEnter>
    2e76:	03 c0       	rjmp	.+6      	; 0x2e7e <Test+0x1a0>
    DF_CS_inactive;
    DF_CS_active;
    
    Cont_Flash_Read_Enable (1,0);

    for(j=0;j<50;j++)
    2e78:	1f 5f       	subi	r17, 0xFF	; 255
    2e7a:	12 33       	cpi	r17, 0x32	; 50
    2e7c:	91 f7       	brne	.-28     	; 0x2e62 <Test+0x184>
            TestWaitEnter();
            break;
        }
    }

    DF_CS_inactive;
    2e7e:	28 9a       	sbi	0x05, 0	; 5


//// //// //// //// RESET //// //// //// ////


    WDTCR = (1<<WDCE) | (1<<WDE);   //Enable Watchdog Timer to give reset
    2e80:	88 e1       	ldi	r24, 0x18	; 24
    2e82:	80 93 60 00 	sts	0x0060, r24
    2e86:	ff cf       	rjmp	.-2      	; 0x2e86 <Test+0x1a8>

00002e88 <__subsf3>:
    2e88:	50 58       	subi	r21, 0x80	; 128

00002e8a <__addsf3>:
    2e8a:	bb 27       	eor	r27, r27
    2e8c:	aa 27       	eor	r26, r26
    2e8e:	0e d0       	rcall	.+28     	; 0x2eac <__addsf3x>
    2e90:	4d c1       	rjmp	.+666    	; 0x312c <__fp_round>
    2e92:	3e d1       	rcall	.+636    	; 0x3110 <__fp_pscA>
    2e94:	30 f0       	brcs	.+12     	; 0x2ea2 <__addsf3+0x18>
    2e96:	43 d1       	rcall	.+646    	; 0x311e <__fp_pscB>
    2e98:	20 f0       	brcs	.+8      	; 0x2ea2 <__addsf3+0x18>
    2e9a:	31 f4       	brne	.+12     	; 0x2ea8 <__addsf3+0x1e>
    2e9c:	9f 3f       	cpi	r25, 0xFF	; 255
    2e9e:	11 f4       	brne	.+4      	; 0x2ea4 <__addsf3+0x1a>
    2ea0:	1e f4       	brtc	.+6      	; 0x2ea8 <__addsf3+0x1e>
    2ea2:	33 c1       	rjmp	.+614    	; 0x310a <__fp_nan>
    2ea4:	0e f4       	brtc	.+2      	; 0x2ea8 <__addsf3+0x1e>
    2ea6:	e0 95       	com	r30
    2ea8:	e7 fb       	bst	r30, 7
    2eaa:	29 c1       	rjmp	.+594    	; 0x30fe <__fp_inf>

00002eac <__addsf3x>:
    2eac:	e9 2f       	mov	r30, r25
    2eae:	4f d1       	rcall	.+670    	; 0x314e <__fp_split3>
    2eb0:	80 f3       	brcs	.-32     	; 0x2e92 <__addsf3+0x8>
    2eb2:	ba 17       	cp	r27, r26
    2eb4:	62 07       	cpc	r22, r18
    2eb6:	73 07       	cpc	r23, r19
    2eb8:	84 07       	cpc	r24, r20
    2eba:	95 07       	cpc	r25, r21
    2ebc:	18 f0       	brcs	.+6      	; 0x2ec4 <__addsf3x+0x18>
    2ebe:	71 f4       	brne	.+28     	; 0x2edc <__addsf3x+0x30>
    2ec0:	9e f5       	brtc	.+102    	; 0x2f28 <__addsf3x+0x7c>
    2ec2:	67 c1       	rjmp	.+718    	; 0x3192 <__fp_zero>
    2ec4:	0e f4       	brtc	.+2      	; 0x2ec8 <__addsf3x+0x1c>
    2ec6:	e0 95       	com	r30
    2ec8:	0b 2e       	mov	r0, r27
    2eca:	ba 2f       	mov	r27, r26
    2ecc:	a0 2d       	mov	r26, r0
    2ece:	0b 01       	movw	r0, r22
    2ed0:	b9 01       	movw	r22, r18
    2ed2:	90 01       	movw	r18, r0
    2ed4:	0c 01       	movw	r0, r24
    2ed6:	ca 01       	movw	r24, r20
    2ed8:	a0 01       	movw	r20, r0
    2eda:	11 24       	eor	r1, r1
    2edc:	ff 27       	eor	r31, r31
    2ede:	59 1b       	sub	r21, r25
    2ee0:	99 f0       	breq	.+38     	; 0x2f08 <__addsf3x+0x5c>
    2ee2:	59 3f       	cpi	r21, 0xF9	; 249
    2ee4:	50 f4       	brcc	.+20     	; 0x2efa <__addsf3x+0x4e>
    2ee6:	50 3e       	cpi	r21, 0xE0	; 224
    2ee8:	68 f1       	brcs	.+90     	; 0x2f44 <__addsf3x+0x98>
    2eea:	1a 16       	cp	r1, r26
    2eec:	f0 40       	sbci	r31, 0x00	; 0
    2eee:	a2 2f       	mov	r26, r18
    2ef0:	23 2f       	mov	r18, r19
    2ef2:	34 2f       	mov	r19, r20
    2ef4:	44 27       	eor	r20, r20
    2ef6:	58 5f       	subi	r21, 0xF8	; 248
    2ef8:	f3 cf       	rjmp	.-26     	; 0x2ee0 <__addsf3x+0x34>
    2efa:	46 95       	lsr	r20
    2efc:	37 95       	ror	r19
    2efe:	27 95       	ror	r18
    2f00:	a7 95       	ror	r26
    2f02:	f0 40       	sbci	r31, 0x00	; 0
    2f04:	53 95       	inc	r21
    2f06:	c9 f7       	brne	.-14     	; 0x2efa <__addsf3x+0x4e>
    2f08:	7e f4       	brtc	.+30     	; 0x2f28 <__addsf3x+0x7c>
    2f0a:	1f 16       	cp	r1, r31
    2f0c:	ba 0b       	sbc	r27, r26
    2f0e:	62 0b       	sbc	r22, r18
    2f10:	73 0b       	sbc	r23, r19
    2f12:	84 0b       	sbc	r24, r20
    2f14:	ba f0       	brmi	.+46     	; 0x2f44 <__addsf3x+0x98>
    2f16:	91 50       	subi	r25, 0x01	; 1
    2f18:	a1 f0       	breq	.+40     	; 0x2f42 <__addsf3x+0x96>
    2f1a:	ff 0f       	add	r31, r31
    2f1c:	bb 1f       	adc	r27, r27
    2f1e:	66 1f       	adc	r22, r22
    2f20:	77 1f       	adc	r23, r23
    2f22:	88 1f       	adc	r24, r24
    2f24:	c2 f7       	brpl	.-16     	; 0x2f16 <__addsf3x+0x6a>
    2f26:	0e c0       	rjmp	.+28     	; 0x2f44 <__addsf3x+0x98>
    2f28:	ba 0f       	add	r27, r26
    2f2a:	62 1f       	adc	r22, r18
    2f2c:	73 1f       	adc	r23, r19
    2f2e:	84 1f       	adc	r24, r20
    2f30:	48 f4       	brcc	.+18     	; 0x2f44 <__addsf3x+0x98>
    2f32:	87 95       	ror	r24
    2f34:	77 95       	ror	r23
    2f36:	67 95       	ror	r22
    2f38:	b7 95       	ror	r27
    2f3a:	f7 95       	ror	r31
    2f3c:	9e 3f       	cpi	r25, 0xFE	; 254
    2f3e:	08 f0       	brcs	.+2      	; 0x2f42 <__addsf3x+0x96>
    2f40:	b3 cf       	rjmp	.-154    	; 0x2ea8 <__addsf3+0x1e>
    2f42:	93 95       	inc	r25
    2f44:	88 0f       	add	r24, r24
    2f46:	08 f0       	brcs	.+2      	; 0x2f4a <__addsf3x+0x9e>
    2f48:	99 27       	eor	r25, r25
    2f4a:	ee 0f       	add	r30, r30
    2f4c:	97 95       	ror	r25
    2f4e:	87 95       	ror	r24
    2f50:	08 95       	ret

00002f52 <__divsf3>:
    2f52:	0c d0       	rcall	.+24     	; 0x2f6c <__divsf3x>
    2f54:	eb c0       	rjmp	.+470    	; 0x312c <__fp_round>
    2f56:	e3 d0       	rcall	.+454    	; 0x311e <__fp_pscB>
    2f58:	40 f0       	brcs	.+16     	; 0x2f6a <__divsf3+0x18>
    2f5a:	da d0       	rcall	.+436    	; 0x3110 <__fp_pscA>
    2f5c:	30 f0       	brcs	.+12     	; 0x2f6a <__divsf3+0x18>
    2f5e:	21 f4       	brne	.+8      	; 0x2f68 <__divsf3+0x16>
    2f60:	5f 3f       	cpi	r21, 0xFF	; 255
    2f62:	19 f0       	breq	.+6      	; 0x2f6a <__divsf3+0x18>
    2f64:	cc c0       	rjmp	.+408    	; 0x30fe <__fp_inf>
    2f66:	51 11       	cpse	r21, r1
    2f68:	15 c1       	rjmp	.+554    	; 0x3194 <__fp_szero>
    2f6a:	cf c0       	rjmp	.+414    	; 0x310a <__fp_nan>

00002f6c <__divsf3x>:
    2f6c:	f0 d0       	rcall	.+480    	; 0x314e <__fp_split3>
    2f6e:	98 f3       	brcs	.-26     	; 0x2f56 <__divsf3+0x4>

00002f70 <__divsf3_pse>:
    2f70:	99 23       	and	r25, r25
    2f72:	c9 f3       	breq	.-14     	; 0x2f66 <__divsf3+0x14>
    2f74:	55 23       	and	r21, r21
    2f76:	b1 f3       	breq	.-20     	; 0x2f64 <__divsf3+0x12>
    2f78:	95 1b       	sub	r25, r21
    2f7a:	55 0b       	sbc	r21, r21
    2f7c:	bb 27       	eor	r27, r27
    2f7e:	aa 27       	eor	r26, r26
    2f80:	62 17       	cp	r22, r18
    2f82:	73 07       	cpc	r23, r19
    2f84:	84 07       	cpc	r24, r20
    2f86:	38 f0       	brcs	.+14     	; 0x2f96 <__divsf3_pse+0x26>
    2f88:	9f 5f       	subi	r25, 0xFF	; 255
    2f8a:	5f 4f       	sbci	r21, 0xFF	; 255
    2f8c:	22 0f       	add	r18, r18
    2f8e:	33 1f       	adc	r19, r19
    2f90:	44 1f       	adc	r20, r20
    2f92:	aa 1f       	adc	r26, r26
    2f94:	a9 f3       	breq	.-22     	; 0x2f80 <__divsf3_pse+0x10>
    2f96:	33 d0       	rcall	.+102    	; 0x2ffe <__divsf3_pse+0x8e>
    2f98:	0e 2e       	mov	r0, r30
    2f9a:	3a f0       	brmi	.+14     	; 0x2faa <__divsf3_pse+0x3a>
    2f9c:	e0 e8       	ldi	r30, 0x80	; 128
    2f9e:	30 d0       	rcall	.+96     	; 0x3000 <__divsf3_pse+0x90>
    2fa0:	91 50       	subi	r25, 0x01	; 1
    2fa2:	50 40       	sbci	r21, 0x00	; 0
    2fa4:	e6 95       	lsr	r30
    2fa6:	00 1c       	adc	r0, r0
    2fa8:	ca f7       	brpl	.-14     	; 0x2f9c <__divsf3_pse+0x2c>
    2faa:	29 d0       	rcall	.+82     	; 0x2ffe <__divsf3_pse+0x8e>
    2fac:	fe 2f       	mov	r31, r30
    2fae:	27 d0       	rcall	.+78     	; 0x2ffe <__divsf3_pse+0x8e>
    2fb0:	66 0f       	add	r22, r22
    2fb2:	77 1f       	adc	r23, r23
    2fb4:	88 1f       	adc	r24, r24
    2fb6:	bb 1f       	adc	r27, r27
    2fb8:	26 17       	cp	r18, r22
    2fba:	37 07       	cpc	r19, r23
    2fbc:	48 07       	cpc	r20, r24
    2fbe:	ab 07       	cpc	r26, r27
    2fc0:	b0 e8       	ldi	r27, 0x80	; 128
    2fc2:	09 f0       	breq	.+2      	; 0x2fc6 <__divsf3_pse+0x56>
    2fc4:	bb 0b       	sbc	r27, r27
    2fc6:	80 2d       	mov	r24, r0
    2fc8:	bf 01       	movw	r22, r30
    2fca:	ff 27       	eor	r31, r31
    2fcc:	93 58       	subi	r25, 0x83	; 131
    2fce:	5f 4f       	sbci	r21, 0xFF	; 255
    2fd0:	2a f0       	brmi	.+10     	; 0x2fdc <__divsf3_pse+0x6c>
    2fd2:	9e 3f       	cpi	r25, 0xFE	; 254
    2fd4:	51 05       	cpc	r21, r1
    2fd6:	68 f0       	brcs	.+26     	; 0x2ff2 <__divsf3_pse+0x82>
    2fd8:	92 c0       	rjmp	.+292    	; 0x30fe <__fp_inf>
    2fda:	dc c0       	rjmp	.+440    	; 0x3194 <__fp_szero>
    2fdc:	5f 3f       	cpi	r21, 0xFF	; 255
    2fde:	ec f3       	brlt	.-6      	; 0x2fda <__divsf3_pse+0x6a>
    2fe0:	98 3e       	cpi	r25, 0xE8	; 232
    2fe2:	dc f3       	brlt	.-10     	; 0x2fda <__divsf3_pse+0x6a>
    2fe4:	86 95       	lsr	r24
    2fe6:	77 95       	ror	r23
    2fe8:	67 95       	ror	r22
    2fea:	b7 95       	ror	r27
    2fec:	f7 95       	ror	r31
    2fee:	9f 5f       	subi	r25, 0xFF	; 255
    2ff0:	c9 f7       	brne	.-14     	; 0x2fe4 <__divsf3_pse+0x74>
    2ff2:	88 0f       	add	r24, r24
    2ff4:	91 1d       	adc	r25, r1
    2ff6:	96 95       	lsr	r25
    2ff8:	87 95       	ror	r24
    2ffa:	97 f9       	bld	r25, 7
    2ffc:	08 95       	ret
    2ffe:	e1 e0       	ldi	r30, 0x01	; 1
    3000:	66 0f       	add	r22, r22
    3002:	77 1f       	adc	r23, r23
    3004:	88 1f       	adc	r24, r24
    3006:	bb 1f       	adc	r27, r27
    3008:	62 17       	cp	r22, r18
    300a:	73 07       	cpc	r23, r19
    300c:	84 07       	cpc	r24, r20
    300e:	ba 07       	cpc	r27, r26
    3010:	20 f0       	brcs	.+8      	; 0x301a <__divsf3_pse+0xaa>
    3012:	62 1b       	sub	r22, r18
    3014:	73 0b       	sbc	r23, r19
    3016:	84 0b       	sbc	r24, r20
    3018:	ba 0b       	sbc	r27, r26
    301a:	ee 1f       	adc	r30, r30
    301c:	88 f7       	brcc	.-30     	; 0x3000 <__divsf3_pse+0x90>
    301e:	e0 95       	com	r30
    3020:	08 95       	ret

00003022 <__fixsfsi>:
    3022:	04 d0       	rcall	.+8      	; 0x302c <__fixunssfsi>
    3024:	68 94       	set
    3026:	b1 11       	cpse	r27, r1
    3028:	b5 c0       	rjmp	.+362    	; 0x3194 <__fp_szero>
    302a:	08 95       	ret

0000302c <__fixunssfsi>:
    302c:	98 d0       	rcall	.+304    	; 0x315e <__fp_splitA>
    302e:	88 f0       	brcs	.+34     	; 0x3052 <__fixunssfsi+0x26>
    3030:	9f 57       	subi	r25, 0x7F	; 127
    3032:	90 f0       	brcs	.+36     	; 0x3058 <__fixunssfsi+0x2c>
    3034:	b9 2f       	mov	r27, r25
    3036:	99 27       	eor	r25, r25
    3038:	b7 51       	subi	r27, 0x17	; 23
    303a:	a0 f0       	brcs	.+40     	; 0x3064 <__fixunssfsi+0x38>
    303c:	d1 f0       	breq	.+52     	; 0x3072 <__fixunssfsi+0x46>
    303e:	66 0f       	add	r22, r22
    3040:	77 1f       	adc	r23, r23
    3042:	88 1f       	adc	r24, r24
    3044:	99 1f       	adc	r25, r25
    3046:	1a f0       	brmi	.+6      	; 0x304e <__fixunssfsi+0x22>
    3048:	ba 95       	dec	r27
    304a:	c9 f7       	brne	.-14     	; 0x303e <__fixunssfsi+0x12>
    304c:	12 c0       	rjmp	.+36     	; 0x3072 <__fixunssfsi+0x46>
    304e:	b1 30       	cpi	r27, 0x01	; 1
    3050:	81 f0       	breq	.+32     	; 0x3072 <__fixunssfsi+0x46>
    3052:	9f d0       	rcall	.+318    	; 0x3192 <__fp_zero>
    3054:	b1 e0       	ldi	r27, 0x01	; 1
    3056:	08 95       	ret
    3058:	9c c0       	rjmp	.+312    	; 0x3192 <__fp_zero>
    305a:	67 2f       	mov	r22, r23
    305c:	78 2f       	mov	r23, r24
    305e:	88 27       	eor	r24, r24
    3060:	b8 5f       	subi	r27, 0xF8	; 248
    3062:	39 f0       	breq	.+14     	; 0x3072 <__fixunssfsi+0x46>
    3064:	b9 3f       	cpi	r27, 0xF9	; 249
    3066:	cc f3       	brlt	.-14     	; 0x305a <__fixunssfsi+0x2e>
    3068:	86 95       	lsr	r24
    306a:	77 95       	ror	r23
    306c:	67 95       	ror	r22
    306e:	b3 95       	inc	r27
    3070:	d9 f7       	brne	.-10     	; 0x3068 <__fixunssfsi+0x3c>
    3072:	3e f4       	brtc	.+14     	; 0x3082 <__fixunssfsi+0x56>
    3074:	90 95       	com	r25
    3076:	80 95       	com	r24
    3078:	70 95       	com	r23
    307a:	61 95       	neg	r22
    307c:	7f 4f       	sbci	r23, 0xFF	; 255
    307e:	8f 4f       	sbci	r24, 0xFF	; 255
    3080:	9f 4f       	sbci	r25, 0xFF	; 255
    3082:	08 95       	ret

00003084 <__floatunsisf>:
    3084:	e8 94       	clt
    3086:	09 c0       	rjmp	.+18     	; 0x309a <__floatsisf+0x12>

00003088 <__floatsisf>:
    3088:	97 fb       	bst	r25, 7
    308a:	3e f4       	brtc	.+14     	; 0x309a <__floatsisf+0x12>
    308c:	90 95       	com	r25
    308e:	80 95       	com	r24
    3090:	70 95       	com	r23
    3092:	61 95       	neg	r22
    3094:	7f 4f       	sbci	r23, 0xFF	; 255
    3096:	8f 4f       	sbci	r24, 0xFF	; 255
    3098:	9f 4f       	sbci	r25, 0xFF	; 255
    309a:	99 23       	and	r25, r25
    309c:	a9 f0       	breq	.+42     	; 0x30c8 <__floatsisf+0x40>
    309e:	f9 2f       	mov	r31, r25
    30a0:	96 e9       	ldi	r25, 0x96	; 150
    30a2:	bb 27       	eor	r27, r27
    30a4:	93 95       	inc	r25
    30a6:	f6 95       	lsr	r31
    30a8:	87 95       	ror	r24
    30aa:	77 95       	ror	r23
    30ac:	67 95       	ror	r22
    30ae:	b7 95       	ror	r27
    30b0:	f1 11       	cpse	r31, r1
    30b2:	f8 cf       	rjmp	.-16     	; 0x30a4 <__floatsisf+0x1c>
    30b4:	fa f4       	brpl	.+62     	; 0x30f4 <__floatsisf+0x6c>
    30b6:	bb 0f       	add	r27, r27
    30b8:	11 f4       	brne	.+4      	; 0x30be <__floatsisf+0x36>
    30ba:	60 ff       	sbrs	r22, 0
    30bc:	1b c0       	rjmp	.+54     	; 0x30f4 <__floatsisf+0x6c>
    30be:	6f 5f       	subi	r22, 0xFF	; 255
    30c0:	7f 4f       	sbci	r23, 0xFF	; 255
    30c2:	8f 4f       	sbci	r24, 0xFF	; 255
    30c4:	9f 4f       	sbci	r25, 0xFF	; 255
    30c6:	16 c0       	rjmp	.+44     	; 0x30f4 <__floatsisf+0x6c>
    30c8:	88 23       	and	r24, r24
    30ca:	11 f0       	breq	.+4      	; 0x30d0 <__floatsisf+0x48>
    30cc:	96 e9       	ldi	r25, 0x96	; 150
    30ce:	11 c0       	rjmp	.+34     	; 0x30f2 <__floatsisf+0x6a>
    30d0:	77 23       	and	r23, r23
    30d2:	21 f0       	breq	.+8      	; 0x30dc <__floatsisf+0x54>
    30d4:	9e e8       	ldi	r25, 0x8E	; 142
    30d6:	87 2f       	mov	r24, r23
    30d8:	76 2f       	mov	r23, r22
    30da:	05 c0       	rjmp	.+10     	; 0x30e6 <__floatsisf+0x5e>
    30dc:	66 23       	and	r22, r22
    30de:	71 f0       	breq	.+28     	; 0x30fc <__floatsisf+0x74>
    30e0:	96 e8       	ldi	r25, 0x86	; 134
    30e2:	86 2f       	mov	r24, r22
    30e4:	70 e0       	ldi	r23, 0x00	; 0
    30e6:	60 e0       	ldi	r22, 0x00	; 0
    30e8:	2a f0       	brmi	.+10     	; 0x30f4 <__floatsisf+0x6c>
    30ea:	9a 95       	dec	r25
    30ec:	66 0f       	add	r22, r22
    30ee:	77 1f       	adc	r23, r23
    30f0:	88 1f       	adc	r24, r24
    30f2:	da f7       	brpl	.-10     	; 0x30ea <__floatsisf+0x62>
    30f4:	88 0f       	add	r24, r24
    30f6:	96 95       	lsr	r25
    30f8:	87 95       	ror	r24
    30fa:	97 f9       	bld	r25, 7
    30fc:	08 95       	ret

000030fe <__fp_inf>:
    30fe:	97 f9       	bld	r25, 7
    3100:	9f 67       	ori	r25, 0x7F	; 127
    3102:	80 e8       	ldi	r24, 0x80	; 128
    3104:	70 e0       	ldi	r23, 0x00	; 0
    3106:	60 e0       	ldi	r22, 0x00	; 0
    3108:	08 95       	ret

0000310a <__fp_nan>:
    310a:	9f ef       	ldi	r25, 0xFF	; 255
    310c:	80 ec       	ldi	r24, 0xC0	; 192
    310e:	08 95       	ret

00003110 <__fp_pscA>:
    3110:	00 24       	eor	r0, r0
    3112:	0a 94       	dec	r0
    3114:	16 16       	cp	r1, r22
    3116:	17 06       	cpc	r1, r23
    3118:	18 06       	cpc	r1, r24
    311a:	09 06       	cpc	r0, r25
    311c:	08 95       	ret

0000311e <__fp_pscB>:
    311e:	00 24       	eor	r0, r0
    3120:	0a 94       	dec	r0
    3122:	12 16       	cp	r1, r18
    3124:	13 06       	cpc	r1, r19
    3126:	14 06       	cpc	r1, r20
    3128:	05 06       	cpc	r0, r21
    312a:	08 95       	ret

0000312c <__fp_round>:
    312c:	09 2e       	mov	r0, r25
    312e:	03 94       	inc	r0
    3130:	00 0c       	add	r0, r0
    3132:	11 f4       	brne	.+4      	; 0x3138 <__fp_round+0xc>
    3134:	88 23       	and	r24, r24
    3136:	52 f0       	brmi	.+20     	; 0x314c <__fp_round+0x20>
    3138:	bb 0f       	add	r27, r27
    313a:	40 f4       	brcc	.+16     	; 0x314c <__fp_round+0x20>
    313c:	bf 2b       	or	r27, r31
    313e:	11 f4       	brne	.+4      	; 0x3144 <__fp_round+0x18>
    3140:	60 ff       	sbrs	r22, 0
    3142:	04 c0       	rjmp	.+8      	; 0x314c <__fp_round+0x20>
    3144:	6f 5f       	subi	r22, 0xFF	; 255
    3146:	7f 4f       	sbci	r23, 0xFF	; 255
    3148:	8f 4f       	sbci	r24, 0xFF	; 255
    314a:	9f 4f       	sbci	r25, 0xFF	; 255
    314c:	08 95       	ret

0000314e <__fp_split3>:
    314e:	57 fd       	sbrc	r21, 7
    3150:	90 58       	subi	r25, 0x80	; 128
    3152:	44 0f       	add	r20, r20
    3154:	55 1f       	adc	r21, r21
    3156:	59 f0       	breq	.+22     	; 0x316e <__fp_splitA+0x10>
    3158:	5f 3f       	cpi	r21, 0xFF	; 255
    315a:	71 f0       	breq	.+28     	; 0x3178 <__fp_splitA+0x1a>
    315c:	47 95       	ror	r20

0000315e <__fp_splitA>:
    315e:	88 0f       	add	r24, r24
    3160:	97 fb       	bst	r25, 7
    3162:	99 1f       	adc	r25, r25
    3164:	61 f0       	breq	.+24     	; 0x317e <__fp_splitA+0x20>
    3166:	9f 3f       	cpi	r25, 0xFF	; 255
    3168:	79 f0       	breq	.+30     	; 0x3188 <__fp_splitA+0x2a>
    316a:	87 95       	ror	r24
    316c:	08 95       	ret
    316e:	12 16       	cp	r1, r18
    3170:	13 06       	cpc	r1, r19
    3172:	14 06       	cpc	r1, r20
    3174:	55 1f       	adc	r21, r21
    3176:	f2 cf       	rjmp	.-28     	; 0x315c <__fp_split3+0xe>
    3178:	46 95       	lsr	r20
    317a:	f1 df       	rcall	.-30     	; 0x315e <__fp_splitA>
    317c:	08 c0       	rjmp	.+16     	; 0x318e <__fp_splitA+0x30>
    317e:	16 16       	cp	r1, r22
    3180:	17 06       	cpc	r1, r23
    3182:	18 06       	cpc	r1, r24
    3184:	99 1f       	adc	r25, r25
    3186:	f1 cf       	rjmp	.-30     	; 0x316a <__fp_splitA+0xc>
    3188:	86 95       	lsr	r24
    318a:	71 05       	cpc	r23, r1
    318c:	61 05       	cpc	r22, r1
    318e:	08 94       	sec
    3190:	08 95       	ret

00003192 <__fp_zero>:
    3192:	e8 94       	clt

00003194 <__fp_szero>:
    3194:	bb 27       	eor	r27, r27
    3196:	66 27       	eor	r22, r22
    3198:	77 27       	eor	r23, r23
    319a:	cb 01       	movw	r24, r22
    319c:	97 f9       	bld	r25, 7
    319e:	08 95       	ret

000031a0 <__mulsf3>:
    31a0:	0b d0       	rcall	.+22     	; 0x31b8 <__mulsf3x>
    31a2:	c4 cf       	rjmp	.-120    	; 0x312c <__fp_round>
    31a4:	b5 df       	rcall	.-150    	; 0x3110 <__fp_pscA>
    31a6:	28 f0       	brcs	.+10     	; 0x31b2 <__mulsf3+0x12>
    31a8:	ba df       	rcall	.-140    	; 0x311e <__fp_pscB>
    31aa:	18 f0       	brcs	.+6      	; 0x31b2 <__mulsf3+0x12>
    31ac:	95 23       	and	r25, r21
    31ae:	09 f0       	breq	.+2      	; 0x31b2 <__mulsf3+0x12>
    31b0:	a6 cf       	rjmp	.-180    	; 0x30fe <__fp_inf>
    31b2:	ab cf       	rjmp	.-170    	; 0x310a <__fp_nan>
    31b4:	11 24       	eor	r1, r1
    31b6:	ee cf       	rjmp	.-36     	; 0x3194 <__fp_szero>

000031b8 <__mulsf3x>:
    31b8:	ca df       	rcall	.-108    	; 0x314e <__fp_split3>
    31ba:	a0 f3       	brcs	.-24     	; 0x31a4 <__mulsf3+0x4>

000031bc <__mulsf3_pse>:
    31bc:	95 9f       	mul	r25, r21
    31be:	d1 f3       	breq	.-12     	; 0x31b4 <__mulsf3+0x14>
    31c0:	95 0f       	add	r25, r21
    31c2:	50 e0       	ldi	r21, 0x00	; 0
    31c4:	55 1f       	adc	r21, r21
    31c6:	62 9f       	mul	r22, r18
    31c8:	f0 01       	movw	r30, r0
    31ca:	72 9f       	mul	r23, r18
    31cc:	bb 27       	eor	r27, r27
    31ce:	f0 0d       	add	r31, r0
    31d0:	b1 1d       	adc	r27, r1
    31d2:	63 9f       	mul	r22, r19
    31d4:	aa 27       	eor	r26, r26
    31d6:	f0 0d       	add	r31, r0
    31d8:	b1 1d       	adc	r27, r1
    31da:	aa 1f       	adc	r26, r26
    31dc:	64 9f       	mul	r22, r20
    31de:	66 27       	eor	r22, r22
    31e0:	b0 0d       	add	r27, r0
    31e2:	a1 1d       	adc	r26, r1
    31e4:	66 1f       	adc	r22, r22
    31e6:	82 9f       	mul	r24, r18
    31e8:	22 27       	eor	r18, r18
    31ea:	b0 0d       	add	r27, r0
    31ec:	a1 1d       	adc	r26, r1
    31ee:	62 1f       	adc	r22, r18
    31f0:	73 9f       	mul	r23, r19
    31f2:	b0 0d       	add	r27, r0
    31f4:	a1 1d       	adc	r26, r1
    31f6:	62 1f       	adc	r22, r18
    31f8:	83 9f       	mul	r24, r19
    31fa:	a0 0d       	add	r26, r0
    31fc:	61 1d       	adc	r22, r1
    31fe:	22 1f       	adc	r18, r18
    3200:	74 9f       	mul	r23, r20
    3202:	33 27       	eor	r19, r19
    3204:	a0 0d       	add	r26, r0
    3206:	61 1d       	adc	r22, r1
    3208:	23 1f       	adc	r18, r19
    320a:	84 9f       	mul	r24, r20
    320c:	60 0d       	add	r22, r0
    320e:	21 1d       	adc	r18, r1
    3210:	82 2f       	mov	r24, r18
    3212:	76 2f       	mov	r23, r22
    3214:	6a 2f       	mov	r22, r26
    3216:	11 24       	eor	r1, r1
    3218:	9f 57       	subi	r25, 0x7F	; 127
    321a:	50 40       	sbci	r21, 0x00	; 0
    321c:	8a f0       	brmi	.+34     	; 0x3240 <__mulsf3_pse+0x84>
    321e:	e1 f0       	breq	.+56     	; 0x3258 <__mulsf3_pse+0x9c>
    3220:	88 23       	and	r24, r24
    3222:	4a f0       	brmi	.+18     	; 0x3236 <__mulsf3_pse+0x7a>
    3224:	ee 0f       	add	r30, r30
    3226:	ff 1f       	adc	r31, r31
    3228:	bb 1f       	adc	r27, r27
    322a:	66 1f       	adc	r22, r22
    322c:	77 1f       	adc	r23, r23
    322e:	88 1f       	adc	r24, r24
    3230:	91 50       	subi	r25, 0x01	; 1
    3232:	50 40       	sbci	r21, 0x00	; 0
    3234:	a9 f7       	brne	.-22     	; 0x3220 <__mulsf3_pse+0x64>
    3236:	9e 3f       	cpi	r25, 0xFE	; 254
    3238:	51 05       	cpc	r21, r1
    323a:	70 f0       	brcs	.+28     	; 0x3258 <__mulsf3_pse+0x9c>
    323c:	60 cf       	rjmp	.-320    	; 0x30fe <__fp_inf>
    323e:	aa cf       	rjmp	.-172    	; 0x3194 <__fp_szero>
    3240:	5f 3f       	cpi	r21, 0xFF	; 255
    3242:	ec f3       	brlt	.-6      	; 0x323e <__mulsf3_pse+0x82>
    3244:	98 3e       	cpi	r25, 0xE8	; 232
    3246:	dc f3       	brlt	.-10     	; 0x323e <__mulsf3_pse+0x82>
    3248:	86 95       	lsr	r24
    324a:	77 95       	ror	r23
    324c:	67 95       	ror	r22
    324e:	b7 95       	ror	r27
    3250:	f7 95       	ror	r31
    3252:	e7 95       	ror	r30
    3254:	9f 5f       	subi	r25, 0xFF	; 255
    3256:	c1 f7       	brne	.-16     	; 0x3248 <__mulsf3_pse+0x8c>
    3258:	fe 2b       	or	r31, r30
    325a:	88 0f       	add	r24, r24
    325c:	91 1d       	adc	r25, r1
    325e:	96 95       	lsr	r25
    3260:	87 95       	ror	r24
    3262:	97 f9       	bld	r25, 7
    3264:	08 95       	ret

00003266 <__udivmodhi4>:
    3266:	aa 1b       	sub	r26, r26
    3268:	bb 1b       	sub	r27, r27
    326a:	51 e1       	ldi	r21, 0x11	; 17
    326c:	07 c0       	rjmp	.+14     	; 0x327c <__udivmodhi4_ep>

0000326e <__udivmodhi4_loop>:
    326e:	aa 1f       	adc	r26, r26
    3270:	bb 1f       	adc	r27, r27
    3272:	a6 17       	cp	r26, r22
    3274:	b7 07       	cpc	r27, r23
    3276:	10 f0       	brcs	.+4      	; 0x327c <__udivmodhi4_ep>
    3278:	a6 1b       	sub	r26, r22
    327a:	b7 0b       	sbc	r27, r23

0000327c <__udivmodhi4_ep>:
    327c:	88 1f       	adc	r24, r24
    327e:	99 1f       	adc	r25, r25
    3280:	5a 95       	dec	r21
    3282:	a9 f7       	brne	.-22     	; 0x326e <__udivmodhi4_loop>
    3284:	80 95       	com	r24
    3286:	90 95       	com	r25
    3288:	bc 01       	movw	r22, r24
    328a:	cd 01       	movw	r24, r26
    328c:	08 95       	ret

0000328e <__divmodsi4>:
    328e:	97 fb       	bst	r25, 7
    3290:	09 2e       	mov	r0, r25
    3292:	05 26       	eor	r0, r21
    3294:	0e d0       	rcall	.+28     	; 0x32b2 <__divmodsi4_neg1>
    3296:	57 fd       	sbrc	r21, 7
    3298:	04 d0       	rcall	.+8      	; 0x32a2 <__divmodsi4_neg2>
    329a:	14 d0       	rcall	.+40     	; 0x32c4 <__udivmodsi4>
    329c:	0a d0       	rcall	.+20     	; 0x32b2 <__divmodsi4_neg1>
    329e:	00 1c       	adc	r0, r0
    32a0:	38 f4       	brcc	.+14     	; 0x32b0 <__divmodsi4_exit>

000032a2 <__divmodsi4_neg2>:
    32a2:	50 95       	com	r21
    32a4:	40 95       	com	r20
    32a6:	30 95       	com	r19
    32a8:	21 95       	neg	r18
    32aa:	3f 4f       	sbci	r19, 0xFF	; 255
    32ac:	4f 4f       	sbci	r20, 0xFF	; 255
    32ae:	5f 4f       	sbci	r21, 0xFF	; 255

000032b0 <__divmodsi4_exit>:
    32b0:	08 95       	ret

000032b2 <__divmodsi4_neg1>:
    32b2:	f6 f7       	brtc	.-4      	; 0x32b0 <__divmodsi4_exit>
    32b4:	90 95       	com	r25
    32b6:	80 95       	com	r24
    32b8:	70 95       	com	r23
    32ba:	61 95       	neg	r22
    32bc:	7f 4f       	sbci	r23, 0xFF	; 255
    32be:	8f 4f       	sbci	r24, 0xFF	; 255
    32c0:	9f 4f       	sbci	r25, 0xFF	; 255
    32c2:	08 95       	ret

000032c4 <__udivmodsi4>:
    32c4:	a1 e2       	ldi	r26, 0x21	; 33
    32c6:	1a 2e       	mov	r1, r26
    32c8:	aa 1b       	sub	r26, r26
    32ca:	bb 1b       	sub	r27, r27
    32cc:	fd 01       	movw	r30, r26
    32ce:	0d c0       	rjmp	.+26     	; 0x32ea <__udivmodsi4_ep>

000032d0 <__udivmodsi4_loop>:
    32d0:	aa 1f       	adc	r26, r26
    32d2:	bb 1f       	adc	r27, r27
    32d4:	ee 1f       	adc	r30, r30
    32d6:	ff 1f       	adc	r31, r31
    32d8:	a2 17       	cp	r26, r18
    32da:	b3 07       	cpc	r27, r19
    32dc:	e4 07       	cpc	r30, r20
    32de:	f5 07       	cpc	r31, r21
    32e0:	20 f0       	brcs	.+8      	; 0x32ea <__udivmodsi4_ep>
    32e2:	a2 1b       	sub	r26, r18
    32e4:	b3 0b       	sbc	r27, r19
    32e6:	e4 0b       	sbc	r30, r20
    32e8:	f5 0b       	sbc	r31, r21

000032ea <__udivmodsi4_ep>:
    32ea:	66 1f       	adc	r22, r22
    32ec:	77 1f       	adc	r23, r23
    32ee:	88 1f       	adc	r24, r24
    32f0:	99 1f       	adc	r25, r25
    32f2:	1a 94       	dec	r1
    32f4:	69 f7       	brne	.-38     	; 0x32d0 <__udivmodsi4_loop>
    32f6:	60 95       	com	r22
    32f8:	70 95       	com	r23
    32fa:	80 95       	com	r24
    32fc:	90 95       	com	r25
    32fe:	9b 01       	movw	r18, r22
    3300:	ac 01       	movw	r20, r24
    3302:	bd 01       	movw	r22, r26
    3304:	cf 01       	movw	r24, r30
    3306:	08 95       	ret

00003308 <_exit>:
    3308:	f8 94       	cli

0000330a <__stop_program>:
    330a:	ff cf       	rjmp	.-2      	; 0x330a <__stop_program>
